// -----------------------------------------------------------------------
// PortfolioReviewWorker - Generates LLM-powered portfolio review from portfolio documents
// Consumes portfolio documents (generated by navexa_portfolio or other workers)
// and uses LLM to produce a portfolio analysis summary.
// Generic design: accepts any document with the required schema (portfolio, holdings).
// -----------------------------------------------------------------------

package portfolio

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/ternarybob/arbor"
	"github.com/ternarybob/quaero/internal/interfaces"
	"github.com/ternarybob/quaero/internal/models"
	"github.com/ternarybob/quaero/internal/queue"
	"github.com/ternarybob/quaero/internal/services/llm"
)

// PortfolioReviewWorker generates LLM-powered portfolio reviews from portfolio documents.
// It consumes documents via filter_tags (from a previous pipeline step) or direct document ID.
// The input document must have the required schema: portfolio metadata and holdings array.
type PortfolioReviewWorker struct {
	documentStorage interfaces.DocumentStorage
	kvStorage       interfaces.KeyValueStorage
	searchService   interfaces.SearchService
	logger          arbor.ILogger
	jobMgr          *queue.Manager
	providerFactory *llm.ProviderFactory
	debugEnabled    bool
}

// Compile-time assertion
var _ interfaces.DefinitionWorker = (*PortfolioReviewWorker)(nil)

// NewPortfolioReviewWorker creates a new portfolio review worker
func NewPortfolioReviewWorker(
	documentStorage interfaces.DocumentStorage,
	kvStorage interfaces.KeyValueStorage,
	searchService interfaces.SearchService,
	logger arbor.ILogger,
	jobMgr *queue.Manager,
	providerFactory *llm.ProviderFactory,
	debugEnabled bool,
) *PortfolioReviewWorker {
	return &PortfolioReviewWorker{
		documentStorage: documentStorage,
		kvStorage:       kvStorage,
		searchService:   searchService,
		logger:          logger,
		jobMgr:          jobMgr,
		providerFactory: providerFactory,
		debugEnabled:    debugEnabled,
	}
}

// GetType returns WorkerTypePortfolioReview
func (w *PortfolioReviewWorker) GetType() models.WorkerType {
	return models.WorkerTypePortfolioReview
}

// ReturnsChildJobs returns false - this worker executes inline
func (w *PortfolioReviewWorker) ReturnsChildJobs() bool {
	return false
}

// ValidateConfig validates the worker configuration
// Requires either filter_tags or portfolio_document_id to identify the input document
func (w *PortfolioReviewWorker) ValidateConfig(step models.JobStep) error {
	if step.Config == nil {
		return fmt.Errorf("config is required for portfolio_review")
	}

	// Check for filter_tags
	if tags := w.extractFilterTags(step.Config); len(tags) > 0 {
		return nil
	}

	// Check for portfolio_document_id
	if docID, ok := step.Config["portfolio_document_id"].(string); ok && docID != "" {
		return nil
	}

	return fmt.Errorf("either filter_tags or portfolio_document_id is required in config")
}

// Init initializes the portfolio review worker
func (w *PortfolioReviewWorker) Init(ctx context.Context, step models.JobStep, jobDef models.JobDefinition) (*interfaces.WorkerInitResult, error) {
	stepConfig := step.Config
	if stepConfig == nil {
		return nil, fmt.Errorf("step config is required for portfolio_review")
	}

	// Get model from config or use default
	model := "gemini"
	if m, ok := stepConfig["model"].(string); ok && m != "" {
		model = m
	}

	// Extract filter_tags or document_id for identification
	filterTags := w.extractFilterTags(stepConfig)
	docID, _ := stepConfig["portfolio_document_id"].(string)

	w.logger.Info().
		Str("phase", "init").
		Str("step_name", step.Name).
		Strs("filter_tags", filterTags).
		Str("portfolio_document_id", docID).
		Str("model", model).
		Msg("Portfolio review worker initialized")

	return &interfaces.WorkerInitResult{
		WorkItems: []interfaces.WorkItem{
			{
				ID:     fmt.Sprintf("portfolio-review-%s", step.Name),
				Name:   "Generate portfolio review from document",
				Type:   "portfolio_review",
				Config: stepConfig,
			},
		},
		TotalCount:           1,
		Strategy:             interfaces.ProcessingStrategyInline,
		SuggestedConcurrency: 1,
		Metadata: map[string]interface{}{
			"filter_tags":           filterTags,
			"portfolio_document_id": docID,
			"model":                 model,
			"step_config":           stepConfig,
		},
	}, nil
}

// CreateJobs reads portfolio document, generates LLM review, and stores result document
func (w *PortfolioReviewWorker) CreateJobs(ctx context.Context, step models.JobStep, jobDef models.JobDefinition, stepID string, initResult *interfaces.WorkerInitResult) (string, error) {
	if initResult == nil {
		var err error
		initResult, err = w.Init(ctx, step, jobDef)
		if err != nil {
			return "", fmt.Errorf("failed to initialize portfolio_review worker: %w", err)
		}
	}

	filterTags, _ := initResult.Metadata["filter_tags"].([]string)
	docID, _ := initResult.Metadata["portfolio_document_id"].(string)
	model, _ := initResult.Metadata["model"].(string)
	stepConfig, _ := initResult.Metadata["step_config"].(map[string]interface{})

	// Step 1: Get portfolio document
	if w.jobMgr != nil {
		if len(filterTags) > 0 {
			w.jobMgr.AddJobLog(ctx, stepID, "info",
				fmt.Sprintf("Searching for portfolio document with tags: %v", filterTags))
		} else {
			w.jobMgr.AddJobLog(ctx, stepID, "info",
				fmt.Sprintf("Fetching portfolio document by ID: %s", docID))
		}
	}

	portfolioDoc, err := w.getPortfolioDocument(ctx, filterTags, docID)
	if err != nil {
		return "", fmt.Errorf("failed to get portfolio document: %w", err)
	}

	// Debug: Log document details to help diagnose metadata issues
	w.logger.Debug().
		Str("document_id", portfolioDoc.ID).
		Str("source_type", portfolioDoc.SourceType).
		Strs("tags", portfolioDoc.Tags).
		Bool("has_metadata", portfolioDoc.Metadata != nil).
		Int("metadata_keys", len(portfolioDoc.Metadata)).
		Msg("Portfolio document found for review")

	if w.jobMgr != nil && portfolioDoc.Metadata != nil {
		// Log metadata keys for debugging
		var keys []string
		for k := range portfolioDoc.Metadata {
			keys = append(keys, k)
		}
		w.jobMgr.AddJobLog(ctx, stepID, "debug",
			fmt.Sprintf("Document %s metadata keys: %v", portfolioDoc.ID, keys))
	}

	// Step 2: Extract portfolio data from document metadata
	portfolioName, portfolioID, holdings, err := w.extractPortfolioData(portfolioDoc)
	if err != nil {
		return "", fmt.Errorf("failed to extract portfolio data from document: %w", err)
	}

	w.logger.Info().
		Str("document_id", portfolioDoc.ID).
		Int("portfolio_id", portfolioID).
		Str("portfolio_name", portfolioName).
		Int("holdings_count", len(holdings)).
		Msg("Portfolio data extracted from document")

	if w.jobMgr != nil {
		w.jobMgr.AddJobLog(ctx, stepID, "info",
			fmt.Sprintf("Found portfolio '%s' with %d holdings in document %s", portfolioName, len(holdings), portfolioDoc.ID))
	}

	// Step 3: Build portfolio data for LLM prompt
	portfolioData := w.buildPortfolioDataSection(holdings, portfolioName)

	// Get custom prompt or use default
	prompt := w.getPrompt(stepConfig)

	// Step 4: Generate LLM review
	if w.jobMgr != nil {
		w.jobMgr.AddJobLog(ctx, stepID, "info",
			fmt.Sprintf("Generating LLM review for %d holdings using %s", len(holdings), model))
	}

	review, err := w.generateReview(ctx, prompt, portfolioData, model, stepID)
	if err != nil {
		return "", fmt.Errorf("failed to generate portfolio review: %w", err)
	}

	// Step 5: Build output tags
	dateTag := fmt.Sprintf("date:%s", time.Now().Format("2006-01-02"))
	tags := []string{"portfolio-review", portfolioName, dateTag}

	// Add output_tags from step config
	if outputTags, ok := stepConfig["output_tags"].([]interface{}); ok {
		for _, tag := range outputTags {
			if tagStr, ok := tag.(string); ok {
				tags = append(tags, tagStr)
			}
		}
	} else if outputTags, ok := stepConfig["output_tags"].([]string); ok {
		tags = append(tags, outputTags...)
	}

	// Step 6: Create output document
	now := time.Now()
	doc := &models.Document{
		ID:              uuid.New().String(),
		Title:           fmt.Sprintf("Portfolio Review - %s", portfolioName),
		URL:             portfolioDoc.URL,
		SourceType:      "portfolio_review",
		SourceID:        fmt.Sprintf("portfolio:%d:review", portfolioID),
		ContentMarkdown: review,
		Tags:            tags,
		CreatedAt:       now,
		UpdatedAt:       now,
		LastSynced:      &now,
		Metadata: map[string]interface{}{
			"portfolio_id":        portfolioID,
			"portfolio_name":      portfolioName,
			"holding_count":       len(holdings),
			"model":               model,
			"generated_at":        now.Format(time.RFC3339),
			"source_document_id":  portfolioDoc.ID,
			"source_document_url": portfolioDoc.URL,
		},
	}

	if err := w.documentStorage.SaveDocument(doc); err != nil {
		return "", fmt.Errorf("failed to store portfolio review document: %w", err)
	}

	if w.jobMgr != nil {
		w.jobMgr.AddJobLog(ctx, stepID, "info",
			fmt.Sprintf("Portfolio review generated for %s with %d holdings", portfolioName, len(holdings)))
	}

	w.logger.Info().
		Int("portfolio_id", portfolioID).
		Str("portfolio_name", portfolioName).
		Int("holding_count", len(holdings)).
		Str("document_id", doc.ID).
		Str("source_document_id", portfolioDoc.ID).
		Msg("Portfolio review generated and stored")

	return stepID, nil
}

// getPortfolioDocument retrieves the portfolio document by filter_tags or direct ID
func (w *PortfolioReviewWorker) getPortfolioDocument(ctx context.Context, filterTags []string, docID string) (*models.Document, error) {
	// Option 1: Direct document ID lookup
	if docID != "" {
		doc, err := w.documentStorage.GetDocument(docID)
		if err != nil {
			return nil, fmt.Errorf("failed to get document by ID '%s': %w", docID, err)
		}
		return doc, nil
	}

	// Option 2: Search by filter_tags
	if len(filterTags) > 0 && w.searchService != nil {
		opts := interfaces.SearchOptions{
			Tags:  filterTags,
			Limit: 1,
		}

		docs, err := w.searchService.Search(ctx, "", opts)
		if err != nil {
			return nil, fmt.Errorf("failed to search for documents with tags %v: %w", filterTags, err)
		}

		if len(docs) == 0 {
			return nil, fmt.Errorf("no portfolio document found with tags: %v", filterTags)
		}

		return docs[0], nil
	}

	return nil, fmt.Errorf("either filter_tags or portfolio_document_id is required")
}

// extractPortfolioData extracts portfolio name, ID, and holdings from document metadata
// Returns: portfolioName, portfolioID, holdings, error
func (w *PortfolioReviewWorker) extractPortfolioData(doc *models.Document) (string, int, []PortfolioHolding, error) {
	if doc.Metadata == nil {
		return "", 0, nil, fmt.Errorf("document has no metadata")
	}

	// Extract portfolio info
	var portfolioID int
	var portfolioName string

	if portfolio, ok := doc.Metadata["portfolio"].(map[string]interface{}); ok {
		// Standard schema from navexa_portfolio worker
		if id, ok := portfolio["id"].(float64); ok {
			portfolioID = int(id)
		} else if id, ok := portfolio["id"].(int); ok {
			portfolioID = id
		}
		if name, ok := portfolio["name"].(string); ok {
			portfolioName = name
		}
	} else {
		// Fallback: try direct fields in metadata
		if id, ok := doc.Metadata["portfolio_id"].(float64); ok {
			portfolioID = int(id)
		} else if id, ok := doc.Metadata["portfolio_id"].(int); ok {
			portfolioID = id
		}
		if name, ok := doc.Metadata["portfolio_name"].(string); ok {
			portfolioName = name
		}
	}

	// Default portfolio name from document title if not in metadata
	if portfolioName == "" && doc.Title != "" {
		portfolioName = doc.Title
	}

	// Extract holdings - handle both []interface{} and []map[string]interface{} types
	// The type can vary depending on whether the document was just created or deserialized from storage
	var holdingMaps []map[string]interface{}

	switch holdings := doc.Metadata["holdings"].(type) {
	case []interface{}:
		// When deserialized from JSON, holdings is []interface{}
		holdingMaps = make([]map[string]interface{}, 0, len(holdings))
		for _, h := range holdings {
			if holdingMap, ok := h.(map[string]interface{}); ok {
				holdingMaps = append(holdingMaps, holdingMap)
			}
		}
	case []map[string]interface{}:
		// When freshly created in memory, holdings is []map[string]interface{}
		holdingMaps = holdings
	default:
		if holdings == nil {
			return "", 0, nil, fmt.Errorf("document metadata missing 'holdings' array")
		}
		return "", 0, nil, fmt.Errorf("document metadata 'holdings' has unexpected type %T", holdings)
	}

	parsedHoldings := make([]PortfolioHolding, 0, len(holdingMaps))
	for _, holdingMap := range holdingMaps {
		holding := PortfolioHolding{
			Symbol:   getStringField(holdingMap, "symbol"),
			Name:     getStringField(holdingMap, "name"),
			Exchange: getStringField(holdingMap, "exchange"),
		}

		// Handle numeric fields with type flexibility
		if qty, ok := holdingMap["quantity"].(float64); ok {
			holding.Quantity = qty
		}
		if price, ok := holdingMap["avgBuyPrice"].(float64); ok {
			holding.AvgBuyPrice = price
		}
		if value, ok := holdingMap["currentValue"].(float64); ok {
			holding.CurrentValue = value
		}
		if weight, ok := holdingMap["holdingWeight"].(float64); ok {
			holding.HoldingWeight = weight
		}
		if currency, ok := holdingMap["currencyCode"].(string); ok {
			holding.CurrencyCode = currency
		}

		parsedHoldings = append(parsedHoldings, holding)
	}

	if len(parsedHoldings) == 0 {
		return "", 0, nil, fmt.Errorf("no valid holdings found in document")
	}

	return portfolioName, portfolioID, parsedHoldings, nil
}

// extractFilterTags extracts filter_tags from step config
func (w *PortfolioReviewWorker) extractFilterTags(stepConfig map[string]interface{}) []string {
	if tags, ok := stepConfig["filter_tags"].([]interface{}); ok {
		result := make([]string, 0, len(tags))
		for _, tag := range tags {
			if s, ok := tag.(string); ok {
				result = append(result, s)
			}
		}
		return result
	}
	if tags, ok := stepConfig["filter_tags"].([]string); ok {
		return tags
	}
	return nil
}

// getStringField safely extracts a string field from a map
func getStringField(m map[string]interface{}, key string) string {
	if v, ok := m[key].(string); ok {
		return v
	}
	return ""
}

// buildPortfolioDataSection creates a structured text section with holdings data for the LLM
func (w *PortfolioReviewWorker) buildPortfolioDataSection(holdings []PortfolioHolding, portfolioName string) string {
	var sb strings.Builder

	// Calculate total portfolio value
	var totalValue float64
	for _, h := range holdings {
		totalValue += h.CurrentValue
	}

	sb.WriteString(fmt.Sprintf("## Portfolio: %s\n\n", portfolioName))
	sb.WriteString(fmt.Sprintf("**Total Holdings**: %d\n", len(holdings)))
	sb.WriteString(fmt.Sprintf("**Total Value**: %s\n\n", formatMoney(totalValue)))
	sb.WriteString("### Holdings Data\n\n")
	sb.WriteString("| Ticker | Name | Quantity | Avg Price | Value | Weight |\n")
	sb.WriteString("|--------|------|----------|-----------|-------|--------|\n")

	for _, h := range holdings {
		ticker := h.Symbol
		if ticker == "" {
			ticker = "-"
		}
		name := h.Name
		if len(name) > 30 {
			name = name[:27] + "..."
		}

		sb.WriteString(fmt.Sprintf("| %s | %s | %.2f | %s | %s | %.1f%% |\n",
			ticker, name, h.Quantity, formatMoney(h.AvgBuyPrice), formatMoney(h.CurrentValue), h.HoldingWeight))
	}

	// Add exchange breakdown
	sb.WriteString("\n### Exchange Breakdown\n\n")
	exchangeWeights := make(map[string]float64)
	for _, h := range holdings {
		exchange := h.Exchange
		if exchange == "" {
			exchange = "Unknown"
		}
		exchangeWeights[exchange] += h.HoldingWeight
	}

	sb.WriteString("| Exchange | Weight |\n")
	sb.WriteString("|----------|--------|\n")
	for exchange, weight := range exchangeWeights {
		sb.WriteString(fmt.Sprintf("| %s | %.1f%% |\n", exchange, weight))
	}

	return sb.String()
}

// getPrompt returns the custom prompt from config or the default prompt
func (w *PortfolioReviewWorker) getPrompt(stepConfig map[string]interface{}) string {
	if prompt, ok := stepConfig["prompt"].(string); ok && prompt != "" {
		return prompt
	}

	return `You are an expert investment analyst reviewing a portfolio. Analyze the holdings provided and generate a comprehensive portfolio review.

Your review should include:

1. **Portfolio Overview**: A brief summary of what this portfolio contains including total value and number of holdings
2. **Position Analysis**: Analysis of position sizes, weights, and any significant concentrations
3. **Key Observations**: Notable patterns, large positions, or gaps in the portfolio
4. **Risk Assessment**: Potential risks based on position concentrations and portfolio composition
5. **Recommendations**: Suggestions for improving portfolio diversification or balance

Be specific about the actual holdings in the portfolio. Reference specific tickers, their weights, and values.
Format your response in clear markdown with appropriate headers and bullet points.`
}

// generateReview calls the LLM to generate a portfolio review
func (w *PortfolioReviewWorker) generateReview(ctx context.Context, prompt, portfolioData, modelOverride, stepID string) (string, error) {
	// Build the full prompt
	currentDate := time.Now().Format("January 2, 2006")

	systemPrompt := fmt.Sprintf(`%s

## Analysis Date
Today's date is %s.

## Portfolio Data

%s

## Instructions
Generate a detailed portfolio review based on the holdings data above. Focus on actionable insights.`,
		prompt, currentDate, portfolioData)

	// Detect provider and normalize model
	provider := w.providerFactory.DetectProvider(modelOverride)
	model := w.providerFactory.NormalizeModel(modelOverride)

	// Use default model for provider if not specified or if model is just a provider shorthand
	// e.g., "gemini" or "claude" should resolve to the default model for that provider
	if model == "" || model == "gemini" || model == "claude" {
		model = w.providerFactory.GetDefaultModel(provider)
	}

	w.logger.Debug().
		Str("step_id", stepID).
		Str("model", model).
		Str("provider", string(provider)).
		Msg("Executing portfolio review generation with provider")

	// Execute with timeout
	reviewCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	// Build content request for provider factory
	request := &llm.ContentRequest{
		Messages: []interfaces.Message{
			{Role: "user", Content: systemPrompt},
		},
		Model:       model,
		Temperature: 0.3,
	}

	// Generate content using provider factory
	resp, err := w.providerFactory.GenerateContent(reviewCtx, request)
	if err != nil {
		return "", fmt.Errorf("failed to generate portfolio review: %w", err)
	}

	if resp.Text == "" {
		return "", fmt.Errorf("empty response from %s API", resp.Provider)
	}

	w.logger.Debug().
		Str("provider", string(resp.Provider)).
		Str("model", resp.Model).
		Int("response_length", len(resp.Text)).
		Msg("Portfolio review generation completed")

	return resp.Text, nil
}
