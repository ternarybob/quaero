<!DOCTYPE html>
<html lang="en">

<head>
    {{template "head.html" .}}
    <title>Job Details - Quaero</title>
</head>

<body>

    {{template "navbar.html" .}}

    <main class="page-container" x-data="jobDetailPage">

        <!-- Breadcrumb Navigation -->
        <nav class="breadcrumb">
            <a href="/queue" class="breadcrumb-link">
                <i class="fas fa-arrow-left"></i> Back to Jobs
            </a>
            <span class="breadcrumb-separator">â€º</span>
            <span class="breadcrumb-current" x-text="job.name || 'Job Details'"></span>
        </nav>

        <!-- Job Header -->
        <div class="job-header">
            <div class="job-header-info">
                <h1 x-text="job.name || 'Job Details'"></h1>
                <div class="job-header-status">
                    <span class="label" :class="getStatusBadgeClass(job.status)" x-text="getStatusText(job.status)"></span>
                </div>
            </div>
            <div class="job-header-actions">
                <button class="btn btn-sm" @click="refreshJob()" title="Refresh">
                    <i class="fa-solid fa-rotate-right"></i>
                </button>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs mb-4">
            <button class="tab" :class="{'active': activeTab === 'details'}" @click="activeTab = 'details'">
                Details
            </button>
            <button class="tab" :class="{'active': activeTab === 'output'}" @click="activeTab = 'output'">
                Output
            </button>
        </div>

        <!-- Details Tab -->
        <div x-show="activeTab === 'details'" x-cloak>

            <!-- Job Details Section -->
            <section class="card" style="margin-bottom: 1.5rem;">
                <div class="card-header">
                    <h3>Job Details</h3>
                </div>
                <div class="card-body">
                    <div class="columns">
                        <div class="column col-3">
                            <p class="text-small text-gray">Status</p>
                            <p class="text-small" x-text="getStatusText(job.status) || 'N/A'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Job ID</p>
                            <p class="text-small" style="font-family: monospace;" x-text="job.id || 'N/A'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Job Type</p>
                            <p class="text-small" x-text="job.job_type || 'Unknown Type'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Created</p>
                            <p class="text-small" x-text="formatTimestamp(job.created_at) || 'N/A'"></p>
                        </div>
                    </div>
                    <div class="columns" style="margin-top: 1rem;">
                        <div class="column col-3">
                            <p class="text-small text-gray">Started</p>
                            <p class="text-small" x-text="formatTimestamp(job.started_at) || 'N/A'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Finished</p>
                            <p class="text-small" x-text="formatTimestamp(job.finished_at) || 'N/A'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Source</p>
                            <p class="text-small" x-text="job.source_type || 'job_definition'"></p>
                        </div>
                        <div class="column col-3">
                            <p class="text-small text-gray">Parent</p>
                            <p class="text-small" x-text="job.parent_id || 'None'"></p>
                        </div>
                    </div>
                    <div class="columns" style="margin-top: 1rem;">
                        <div class="column col-3">
                            <p class="text-small text-gray">Documents Created</p>
                            <p class="text-small" x-text="job.result_count || '0'"></p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Configuration Section -->
            <section class="card" style="margin-bottom: 1.5rem;" x-show="job.config">
                <div class="card-header">
                    <h3>Configuration</h3>
                </div>
                <div class="card-body">
                    <pre class="code" data-lang="JSON"><code x-text="formatJSON(job.config)"></code></pre>
                </div>
            </section>

        </div>

        <!-- Output Tab -->
        <div x-show="activeTab === 'output'" x-cloak>

            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Logs</h3>
                        </section>
                        <section class="navbar-section">
                            <!-- Log Level Filter -->
                            <select class="form-select select-sm" x-model="selectedLogLevel" title="Filter by log level" style="margin-right: 0.5rem;">
                                <option value="all">All Levels</option>
                                <option value="error">Error</option>
                                <option value="warning">Warning</option>
                                <option value="info">Info</option>
                                <option value="debug">Debug</option>
                            </select>

                            <button class="btn btn-sm" @click="toggleAutoScroll()" :title="autoScroll ? 'Pause Auto-Scroll' : 'Resume Auto-Scroll'">
                                <i :class="autoScroll ? 'fas fa-pause' : 'fas fa-play'"></i>
                            </button>
                            <button class="btn btn-sm" @click="refreshLogs()" title="Refresh Logs">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body">
                    <template x-if="loading">
                        <div class="text-center" style="padding: 2rem;">
                            <div class="loading loading-lg"></div>
                            <p class="text-secondary" style="margin-top: 1rem;">Loading logs...</p>
                        </div>
                    </template>

                    <div class="terminal" x-ref="logContainer" x-show="!loading">
                        <template x-if="filteredLogs.length === 0">
                            <div style="text-align: center; color: var(--text-secondary);">
                                No logs available for this job
                            </div>
                        </template>
                        <template x-for="log in filteredLogs" :key="log.timestamp + log.message">
                            <div class="terminal-line">
                                <span class="terminal-time" x-text="`[${log.timestamp}]`"></span>
                                <span :class="log.levelClass" x-text="`[${log.level.toUpperCase()}]`"></span>
                                <span x-text="log.message"></span>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

        </div>

    </main>

    {{template "footer.html" .}}
    {{template "snackbar.html" .}}

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('jobDetailPage', () => ({
                job: {},
                logs: [],
                loading: true,
                selectedLogLevel: 'all',
                autoScroll: true,
                jobId: null,
                activeTab: 'details',

                init() {
                    // Get job ID from URL query parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    this.jobId = urlParams.get('id');

                    if (!this.jobId) {
                        window.showNotification('No job ID provided', 'error');
                        setTimeout(() => {
                            window.location.href = '/queue';
                        }, 2000);
                        return;
                    }

                    this.loadJob();
                    this.loadJobLogs();

                    // Start auto-refresh for running jobs
                    this.startAutoRefresh();

                    // Watch selectedLogLevel and reload logs when it changes
                    this.$watch('selectedLogLevel', () => {
                        this.loadJobLogs();
                    });

                    // Watch selectedLogType and reload logs when it changes
                    this.$watch('selectedLogType', () => {
                        this.loadJobLogs();
                    });
                },

                get filteredLogs() {
                    if (this.selectedLogLevel === 'all') {
                        return this.logs;
                    }

                    return this.logs.filter(log => {
                        const logLevel = log.level.toUpperCase();
                        const filterLevel = this.selectedLogLevel.toUpperCase();

                        // Exact match
                        if (logLevel === filterLevel) {
                            return true;
                        }

                        // Handle variations
                        if (filterLevel === 'ERROR' && (logLevel === 'ERR' || logLevel === 'ERROR')) {
                            return true;
                        }
                        if (filterLevel === 'WARNING' && (logLevel === 'WARN' || logLevel === 'WARNING')) {
                            return true;
                        }

                        return false;
                    });
                },

                async loadJob() {
                    try {
                        const response = await fetch(`/api/jobs/${this.jobId}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch job details');
                        }
                        this.job = await response.json();
                    } catch (error) {
                        console.error('Error loading job:', error);
                        window.showNotification('Failed to load job details: ' + error.message, 'error');
                    }
                },

                async loadJobLogs() {
                    this.loading = true;
                    try {
                        // Build query string with level parameter for server-side filtering
                        const qs = this.selectedLogLevel === 'all' ? '' : ('?level=' + encodeURIComponent(this.selectedLogLevel));
                        const response = await fetch(`/api/jobs/${this.jobId}/logs${qs}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch job logs');
                        }

                        const data = await response.json();
                        const rawLogs = data.logs || [];

                        // Parse logs into flat array
                        this.logs = rawLogs.map(log => this._parseLogEntry(log));

                        // Auto-scroll to bottom after loading logs
                        if (this.autoScroll) {
                            this.$nextTick(() => {
                                const container = this.$refs.logContainer;
                                if (container) {
                                    container.scrollTop = container.scrollHeight;
                                }
                            });
                        }

                    } catch (error) {
                        console.error('Error loading job logs:', error);
                        window.showNotification('Failed to load logs: ' + error.message, 'error');
                        this.logs = [];
                    } finally {
                        this.loading = false;
                    }
                },

                _parseLogEntry(log) {
                    return {
                        timestamp: this.formatLogTimestamp(log.timestamp),
                        level: log.level || 'info',
                        levelClass: this.getLevelClass(log.level || 'info'),
                        message: log.message || ''
                    };
                },

                formatLogTimestamp(timestamp) {
                    if (!timestamp) return '';
                    // Handle both ISO 8601 strings and Unix timestamps
                    const date = typeof timestamp === 'string' ? new Date(timestamp) : new Date(timestamp * 1000);
                    return date.toLocaleTimeString();
                },

                getLevelClass(level) {
                    const levelUpper = level.toUpperCase();
                    if (levelUpper === 'ERROR' || levelUpper === 'ERR') return 'terminal-error';
                    if (levelUpper === 'WARNING' || levelUpper === 'WARN') return 'terminal-warning';
                    if (levelUpper === 'INFO') return 'terminal-info';
                    if (levelUpper === 'DEBUG') return 'terminal-debug';
                    return 'terminal-info';
                },

                async refreshJob() {
                    await this.loadJob();
                    window.showNotification('Job details refreshed', 'success');
                },

                async refreshLogs() {
                    await this.loadJobLogs();
                    window.showNotification('Logs refreshed', 'success');
                },

                toggleAutoScroll() {
                    this.autoScroll = !this.autoScroll;
                    if (this.autoScroll) {
                        this.$nextTick(() => {
                            const container = this.$refs.logContainer;
                            if (container) {
                                container.scrollTop = container.scrollHeight;
                            }
                        });
                    }
                },

                startAutoRefresh() {
                    // Auto-refresh every 5 seconds for running jobs
                    setInterval(async () => {
                        if (this.job.status === 'running' || this.job.status === 'pending') {
                            await this.loadJob();
                            if (this.activeTab === 'output') {
                                await this.loadJobLogs();
                            }
                        }
                    }, 5000);
                },

                getStatusText(status) {
                    if (!status) return 'Unknown';
                    return status.charAt(0).toUpperCase() + status.slice(1);
                },

                getStatusBadgeClass(status) {
                    if (!status) return 'label-secondary';
                    switch (status.toLowerCase()) {
                        case 'completed':
                        case 'success':
                            return 'label-success';
                        case 'running':
                        case 'pending':
                            return 'label-primary';
                        case 'failed':
                        case 'error':
                            return 'label-error';
                        case 'cancelled':
                            return 'label-warning';
                        default:
                            return 'label-secondary';
                    }
                },

                formatTimestamp(timestamp) {
                    if (!timestamp) return 'N/A';
                    // Handle both ISO 8601 strings and Unix timestamps
                    const date = typeof timestamp === 'string' ? new Date(timestamp) : new Date(timestamp * 1000);
                    if (isNaN(date.getTime())) return 'Invalid Date';
                    return date.toLocaleString();
                },

                formatJSON(obj) {
                    if (!obj) return '';
                    if (typeof obj === 'string') {
                        try {
                            obj = JSON.parse(obj);
                        } catch (e) {
                            return obj;
                        }
                    }
                    return JSON.stringify(obj, null, 2);
                }
            }));
        });
    </script>
</body>

</html>