<!DOCTYPE html>
<html lang="en">

<head>
    {{template "head.html" .}}
    <title>Job Detail - Quaero</title>
</head>

<body>

    {{template "navbar.html" .}}

    <main class="page-container" x-data="jobDetailPage">

        <!-- Breadcrumb Navigation -->
        <nav style="margin-bottom: 1rem; font-size: 0.875rem;">
            <a href="/queue" style="color: var(--color-primary); text-decoration: none;"><i class="fas fa-arrow-left"></i> Back to Queue</a>
        </nav>

        <!-- Job Header -->
        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);">
            <div style="font-size: 2rem;" :class="'text-' + job.status">
                <i :class="getStatusIcon(job.status)"></i>
            </div>
            <div style="flex: 1;">
                <h2 style="margin: 0; font-size: 1.5rem;" x-text="job.name || 'Job ' + (job.id ? job.id.substring(0, 8) : 'Unknown')"></h2>
                <div class="text-secondary" style="margin-top: 0.25rem; font-size: 0.875rem;">
                    <span x-text="getStatusText(job.status)"></span>
                    <template x-if="job.created_at">
                        · <span x-text="formatRelativeTime(job.created_at)"></span>
                    </template>
                    <template x-if="job.duration">
                        · Duration: <span x-text="formatDuration(job.duration)"></span>
                    </template>
                </div>
            </div>
            <div>
                <button class="btn btn-sm" @click="refreshJob()" title="Refresh">
                    <i class="fa-solid fa-rotate-right"></i>
                </button>
            </div>
        </div>

        <!-- Job Actions and Info -->
        <section class="card" style="margin-bottom: 1.5rem;">
            <div class="card-body">
                <div class="columns">
                    <div class="column col-3">
                        <p class="text-small text-gray">Job ID</p>
                        <p class="text-small" style="font-family: monospace;" x-text="job.id || 'N/A'"></p>
                    </div>
                    <div class="column col-3">
                        <p class="text-small text-gray">Source Type</p>
                        <p class="text-small" x-text="job.source_type || 'N/A'"></p>
                    </div>
                    <div class="column col-3">
                        <p class="text-small text-gray">Documents Processed</p>
                        <p class="text-small" x-text="getDocumentCount()"></p>
                    </div>
                    <div class="column col-3" x-show="spawnedChildren.length > 0" x-cloak>
                        <p class="text-small text-gray">No. of Child Jobs</p>
                        <p class="text-small" x-text="spawnedChildren.length"></p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Job Logs -->
        <section>
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Logs</h3>
                        </section>
                        <section class="navbar-section">
                            <select class="form-select select-sm log-level-filter" x-model="selectedLogLevel" title="Filter by log level">
                                <option value="all">All Levels</option>
                                <option value="error">Error</option>
                                <option value="warning">Warning</option>
                                <option value="info">Info</option>
                                <option value="debug">Debug</option>
                            </select>
                            <button class="btn btn-sm" @click="toggleAutoScroll()" :title="autoScroll ? 'Pause Auto-Scroll' : 'Resume Auto-Scroll'">
                                <i :class="autoScroll ? 'fas fa-pause' : 'fas fa-play'"></i>
                            </button>
                            <button class="btn btn-sm" @click="refreshJob()" title="Refresh Logs">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body">
                    <template x-if="loading">
                        <div class="text-center" style="padding: 2rem;">
                            <div class="loading loading-lg"></div>
                            <p class="text-secondary" style="margin-top: 1rem;">Loading logs...</p>
                        </div>
                    </template>

                    <div class="terminal" x-ref="logContainer" x-show="!loading">
                        <template x-if="filteredLogs.length === 0">
                            <div style="text-align: center; color: var(--text-secondary);">
                                No logs available for this job
                            </div>
                        </template>
                        <template x-for="log in filteredLogs" :key="log.timestamp + log.message">
                            <div class="terminal-line">
                                <span class="terminal-time" x-text="`[${log.timestamp}]`"></span>
                                <span :class="log.levelClass" x-text="`[${log.level.toUpperCase()}]`"></span>
                                <span x-text="log.message"></span>
                            </div>
                        </template>
                    </div>
                </div>
            </div>
        </section>

        <!-- Service Logs -->
        {{template "service-logs.html" .}}

    </main>

    {{template "footer.html" .}}
    {{template "snackbar.html" .}}

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('jobDetailPage', () => ({
                job: {},
                logs: [],
                spawnedChildren: [],
                loading: true,
                selectedLogLevel: 'all',
                autoScroll: true,
                jobId: null,

                init() {
                    // Get job ID from URL query parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    this.jobId = urlParams.get('id');

                    if (!this.jobId) {
                        window.showNotification('No job ID provided', 'error');
                        setTimeout(() => {
                            window.location.href = '/queue';
                        }, 2000);
                        return;
                    }

                    this.loadJob();
                    this.loadJobLogs();
                    this.loadSpawnedChildren();
                    this.subscribeToJobSpawns();

                    // Start auto-refresh for running jobs
                    this.startAutoRefresh();
                },

                get filteredLogs() {
                    if (this.selectedLogLevel === 'all') {
                        return this.logs;
                    }

                    return this.logs.filter(log => {
                        const logLevel = log.level.toUpperCase();
                        const filterLevel = this.selectedLogLevel.toUpperCase();

                        // Exact match
                        if (logLevel === filterLevel) {
                            return true;
                        }

                        // Handle variations
                        if (filterLevel === 'ERROR' && (logLevel === 'ERR' || logLevel === 'ERROR')) {
                            return true;
                        }
                        if (filterLevel === 'WARNING' && (logLevel === 'WARN' || logLevel === 'WARNING')) {
                            return true;
                        }

                        return false;
                    });
                },

                async loadJob() {
                    try {
                        const response = await fetch(`/api/jobs/${this.jobId}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch job details');
                        }
                        this.job = await response.json();
                    } catch (error) {
                        console.error('Error loading job:', error);
                        window.showNotification('Failed to load job details: ' + error.message, 'error');
                    }
                },

                async loadJobLogs() {
                    this.loading = true;
                    try {
                        const response = await fetch(`/api/jobs/${this.jobId}/logs`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch job logs');
                        }

                        const data = await response.json();
                        const rawLogs = data.logs || [];

                        // Parse logs into flat array
                        this.logs = rawLogs.map(log => this._parseLogEntry(log));

                        // Auto-scroll to bottom after loading logs
                        if (this.autoScroll) {
                            this.$nextTick(() => {
                                const container = this.$refs.logContainer;
                                if (container) {
                                    container.scrollTop = container.scrollHeight;
                                }
                            });
                        }

                    } catch (error) {
                        console.error('Error loading job logs:', error);
                        window.showNotification('Failed to load logs: ' + error.message, 'error');
                        this.logs = [];
                    } finally {
                        this.loading = false;
                    }
                },

                _parseLogEntry(logData) {
                    const timestamp = logData.timestamp || logData.time || new Date().toISOString();
                    const level = (logData.level || 'INFO').toUpperCase();
                    const message = logData.message || logData.msg || '';

                    return {
                        timestamp: this._formatLogTime(timestamp),
                        level: level,
                        levelClass: this._getLevelClass(level),
                        message: message
                    };
                },

                _formatLogTime(timestamp) {
                    // If timestamp is already formatted as HH:MM:SS, return as-is
                    if (typeof timestamp === 'string' && /^\d{2}:\d{2}:\d{2}$/.test(timestamp)) {
                        return timestamp;
                    }

                    // Otherwise try to parse as date
                    const date = new Date(timestamp);
                    if (isNaN(date.getTime())) {
                        return timestamp; // Return original if can't parse
                    }

                    return date.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },

                _getLevelClass(level) {
                    const levelMap = {
                        'ERROR': 'terminal-error',
                        'WARN': 'terminal-warning',
                        'WARNING': 'terminal-warning',
                        'INFO': 'terminal-info',
                        'DEBUG': 'terminal-time'
                    };
                    return levelMap[level] || 'terminal-info';
                },

                async loadSpawnedChildren() {
                    try {
                        // Fetch spawned children from job spawn events
                        const response = await fetch(`/api/jobs?parent_id=${this.jobId}`);
                        if (response.ok) {
                            const data = await response.json();
                            this.spawnedChildren = data.jobs || [];
                        }
                    } catch (error) {
                        console.error('Error loading spawned children:', error);
                        this.spawnedChildren = [];
                    }
                },

                subscribeToJobSpawns() {
                    // Subscribe to WebSocket job_spawn events for real-time child job count
                    if (typeof WebSocketManager !== 'undefined') {
                        WebSocketManager.subscribe('job_spawn', (data) => {
                            // Only count spawns for this job as parent
                            if (data.parent_job_id === this.jobId) {
                                // Check if this child is already tracked
                                const exists = this.spawnedChildren.some(
                                    child => child.child_job_id === data.child_job_id
                                );

                                if (!exists) {
                                    this.spawnedChildren.push({
                                        child_job_id: data.child_job_id,
                                        job_type: data.job_type || 'unknown',
                                        url: data.url || '',
                                        depth: data.depth || 0,
                                        status: 'pending'
                                    });
                                }
                            }
                        });
                    }
                },

                toggleAutoScroll() {
                    this.autoScroll = !this.autoScroll;
                    if (this.autoScroll) {
                        // When re-enabling auto-scroll, scroll to latest logs immediately
                        this.$nextTick(() => {
                            const container = this.$refs.logContainer;
                            if (container) container.scrollTop = container.scrollHeight;
                        });
                    }
                },

                refreshJob() {
                    this.loadJob();
                    this.loadJobLogs();
                    this.loadSpawnedChildren();
                },

                startAutoRefresh() {
                    // Auto-refresh every 5 seconds if job is running
                    setInterval(() => {
                        if (this.job.status === 'running') {
                            this.refreshJob();
                        }
                    }, 5000);
                },

                getStatusIcon(status) {
                    const icons = {
                        'completed': 'fas fa-check-circle',
                        'failed': 'fas fa-times-circle',
                        'running': 'fas fa-spinner fa-pulse',
                        'pending': 'fas fa-clock',
                        'cancelled': 'fas fa-ban'
                    };
                    return icons[status] || 'fas fa-question-circle';
                },

                getStatusText(status) {
                    const texts = {
                        'completed': 'succeeded',
                        'failed': 'failed',
                        'running': 'running',
                        'pending': 'pending',
                        'cancelled': 'cancelled'
                    };
                    return texts[status] || 'unknown';
                },

                getDocumentCount() {
                    if (!this.job.progress) return 'N/A';

                    try {
                        const progress = typeof this.job.progress === 'string' ?
                            JSON.parse(this.job.progress) : this.job.progress;

                        if (progress && progress.completed_urls !== undefined) {
                            return progress.completed_urls;
                        }
                    } catch (error) {
                        console.warn('Failed to parse job progress:', error);
                    }

                    return 'N/A';
                },

                formatRelativeTime(timestamp) {
                    const now = new Date();
                    const then = new Date(timestamp);
                    const diffMs = now - then;
                    const diffSecs = Math.floor(diffMs / 1000);
                    const diffMins = Math.floor(diffSecs / 60);
                    const diffHours = Math.floor(diffMins / 60);
                    const diffDays = Math.floor(diffHours / 24);

                    if (diffDays > 0) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
                    if (diffHours > 0) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
                    if (diffMins > 0) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
                    return `${diffSecs} second${diffSecs !== 1 ? 's' : ''} ago`;
                },

                formatDuration(seconds) {
                    if (!seconds) return 'N/A';
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    if (mins > 0) {
                        return `${mins}m ${secs}s`;
                    }
                    return `${secs}s`;
                }
            }));
        });
    </script>
</body>

</html>
