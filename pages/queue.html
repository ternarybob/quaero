<!DOCTYPE html>
<html lang="en">

<head>
    {{template "head.html" .}}
    <title>Queue Management - Quaero</title>
</head>

<body>

    {{template "navbar.html" .}}

    <main class="container">

        <!-- Page Title -->
        <div class="page-title">
            <h1>Queue Management</h1>
            <p>Monitor and manage running crawler jobs</p>
            <div class="text-small text-gray" style="margin-top: 0.5rem;">
                <i class="fa-solid fa-lightbulb"></i>
                To create or edit job definitions, visit the <a href="/jobs">Jobs</a> page
            </div>
        </div>

        <!-- Queue Metrics -->
        <section x-data="jobStatsHeader" x-init="init()">
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Queue Metrics</h3>
                        </section>
                        <section class="navbar-section">
                            <button class="btn btn-sm" @click="loadStats()">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body">
                    <div class="columns">
                        <div class="column text-center">
                            <p class="text-small text-gray">TOTAL JOBS</p>
                            <p class="h2" x-text="totalJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">PENDING</p>
                            <p class="h2 text-warning" x-text="pendingJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">RUNNING</p>
                            <p class="h2 text-primary" x-text="runningJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">COMPLETED</p>
                            <p class="h2 text-success" x-text="completedJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">FAILED</p>
                            <p class="h2 text-error" x-text="failedJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">CANCELLED</p>
                            <p class="h2 text-warning" x-text="cancelledJobs"></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Job Queue -->
        <section>
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Queue</h3>
                        </section>
                        <section class="navbar-section">
                            <button id="delete-selected-btn" class="btn btn-sm btn-error" onclick="deleteSelectedJobs()" title="Delete Selected" style="display: none; margin-left: 0.5rem;">
                                <i class="fa-solid fa-trash"></i>
                                <span id="delete-selected-text">Delete Selected</span>
                            </button>
                            <button class="btn btn-sm" onclick="event.preventDefault(); window.dispatchEvent(new CustomEvent('jobList:load'))" title="Refresh Jobs">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body" x-data="jobList" x-init="init()">
                    <!-- Filter Button and Chips -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <button type="button" class="btn btn-sm" onclick="showFilterModal()">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                        <div id="filter-chips-container"></div>
                    </div>

                    <!-- Select All Checkbox -->
                    <div style="margin-bottom: 0.8rem;">
                        <label class="form-checkbox">
                            <input type="checkbox" id="select-all-checkbox" @change="toggleSelectAll()">
                            <i class="form-icon"></i> Select All
                        </label>
                    </div>

                    <!-- Error Display -->
                    <template x-if="loadError">
                        <div class="toast toast-error" style="margin-bottom: 1rem; padding: 1rem; border: 1px solid #ef4444; border-radius: 4px;">
                            <i class="fas fa-exclamation-circle"></i>
                            <span x-text="'Failed to load jobs: ' + loadError"></span>
                            <button class="btn btn-sm btn-primary" @click="retryLoadJobs()" style="margin-left: 1rem;">
                                <i class="fas fa-redo"></i> Retry
                            </button>
                            <span x-show="retryCount > 0" x-text="'(Attempt ' + retryCount + '/' + maxRetries + ')'" style="margin-left: 0.5rem; font-size: 0.85rem;"></span>
                        </div>
                    </template>

                    <!-- Stale Data Indicator -->
                    <template x-if="loadError && lastSuccessfulJobs.length > 0">
                        <div class="toast toast-warning" style="margin-bottom: 1rem; padding: 0.75rem; border: 1px solid #fbbf24; border-radius: 4px; background-color: #fef3c7;">
                            <i class="fas fa-exclamation-triangle" style="color: #92400e;"></i>
                            <span style="color: #92400e; margin-left: 0.5rem;">Showing cached data. Data may be
                                outdated.</span>
                            <button class="btn btn-sm" @click="retryLoadJobs()" style="margin-left: 1rem;">
                                <i class="fas fa-redo"></i> Refresh
                            </button>
                        </div>
                    </template>

                    <!-- Jobs Cards Container -->
                    <div id="jobs-cards-container">
                        <template x-for="(item, index) in itemsToRender" :key="item.job.id + '-' + (item.type || 'flat') + (item.step ? '-step-' + item.step.index : '') + (item.childIndex ? '-child-' + item.childIndex : '')">
                            <div :data-item-type="item.type" :data-item-index="index">
                                <!-- Loading indicator for expanding parents -->
                                <template x-if="item.type === 'loading'">

                                    <div class="loading-children" style="margin-left: 2rem; margin-bottom: 0.8rem; padding: 0.5rem; color: #888;">
                                        <i class="fas fa-spinner fa-pulse"></i>
                                        <span>Loading children...</span>
                                    </div>
                                </template>

                                <!-- Step row for multi-step jobs -->
                                <template x-if="item.type === 'step'">
                                    <div class="step-row" style="margin-left: 2rem; margin-bottom: 0.5rem; padding: 0.75rem 1rem; background-color: #f8f9fa; border-left: 3px solid #6c757d; border-radius: 4px;">
                                        <div class="columns" style="align-items: center;">
                                            <div class="column">
                                                <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                                                    <span :class="{
                                                        'text-warning': item.step.status === 'running',
                                                        'text-success': item.step.status === 'completed',
                                                        'text-error': item.step.status === 'failed',
                                                        'text-gray': item.step.status === 'pending',
                                                        'text-primary': item.step.status === 'spawned'
                                                    }">
                                                        <i class="fas" :class="{
                                                            'fa-spinner fa-pulse': item.step.status === 'running',
                                                            'fa-check-circle': item.step.status === 'completed',
                                                            'fa-times-circle': item.step.status === 'failed',
                                                            'fa-clock': item.step.status === 'pending',
                                                            'fa-sitemap': item.step.status === 'spawned'
                                                        }"></i>
                                                    </span>
                                                    <span class="step-name">
                                                        Step <span x-text="item.step.index + 1"></span>/<span x-text="item.step.totalSteps"></span>:
                                                        <span x-text="item.step.name"></span>
                                                    </span>
                                                    <span class="label label-secondary step-label-sm" x-text="item.step.stepType"></span>
                                                    <!-- Show status badge for terminal states and spawned -->
                                                    <template x-if="item.step.status === 'completed' || item.step.status === 'failed' || item.step.status === 'cancelled' || item.step.status === 'spawned'">
                                                        <span class="label step-status-label" :class="{
                                                            'label-success': item.step.status === 'completed',
                                                            'label-error': item.step.status === 'failed',
                                                            'bg-gray': item.step.status === 'cancelled',
                                                            'label-primary': item.step.status === 'spawned'
                                                        }" x-text="item.step.status"></span>
                                                    </template>
                                                    <template x-if="item.step.documentCount > 0">
                                                        <span class="label bg-info step-label-sm">
                                                            <i class="fas fa-file-alt"></i> <span x-text="item.step.documentCount"></span> docs
                                                        </span>
                                                    </template>
                                                    <!-- Step queue stats removed - was showing inaccurate global counts instead of step-specific counts -->
                                                </div>
                                                <template x-if="item.step.description">
                                                    <div class="step-description" x-text="item.step.description"></div>
                                                </template>
                                                <!-- Step Events Panel -->
                                                <div class="step-events-panel" :data-step-events-panel="item.job.id + ':' + item.step.name">
                                                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                                                        <button class="btn btn-sm step-events-btn" :data-events-count="getStepLogs(item.job.id, item.step.name).length" @click.stop="toggleStepLogsExpand(item.job.id, item.step.name)">
                                                            <i class="fas" :class="isStepLogsExpanded(item.job.id, item.step.name) ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                                                            <i class="fas fa-stream"></i>
                                                            <span class="events-count-text" x-text="'logs: ' + getStepLogs(item.job.id, item.step.name).length + '/' + getStepLogsTotal(item.job.id, item.step.name)"></span>
                                                        </button>
                                                        <!-- Filter dropdown (only show when expanded) - matching settings-logs.html pattern exactly -->
                                                        <template x-if="isStepLogsExpanded(item.job.id, item.step.name)">
                                                            <div class="dropdown">
                                                                <a href="#" class="btn btn-sm dropdown-toggle" :class="!isAllLevelsSelected(item.job.id, item.step.name) ? 'btn-primary' : ''" tabindex="0">
                                                                    <i class="fas fa-filter"></i> Filter
                                                                </a>
                                                                <ul class="menu">
                                                                    <li class="menu-item">
                                                                        <label class="form-checkbox">
                                                                            <input type="checkbox" :checked="isLevelSelected(item.job.id, item.step.name, 'debug')" @change="toggleLevelFilter(item.job.id, item.step.name, 'debug')">
                                                                            <i class="form-icon"></i> Debug
                                                                        </label>
                                                                    </li>
                                                                    <li class="menu-item">
                                                                        <label class="form-checkbox">
                                                                            <input type="checkbox" :checked="isLevelSelected(item.job.id, item.step.name, 'info')" @change="toggleLevelFilter(item.job.id, item.step.name, 'info')">
                                                                            <i class="form-icon"></i> Info
                                                                        </label>
                                                                    </li>
                                                                    <li class="menu-item">
                                                                        <label class="form-checkbox">
                                                                            <input type="checkbox" :checked="isLevelSelected(item.job.id, item.step.name, 'warn')" @change="toggleLevelFilter(item.job.id, item.step.name, 'warn')">
                                                                            <i class="form-icon"></i> Warn
                                                                        </label>
                                                                    </li>
                                                                    <li class="menu-item">
                                                                        <label class="form-checkbox">
                                                                            <input type="checkbox" :checked="isLevelSelected(item.job.id, item.step.name, 'error')" @change="toggleLevelFilter(item.job.id, item.step.name, 'error')">
                                                                            <i class="form-icon"></i> Error
                                                                        </label>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        </template>
                                                    </div>
                                                    <!-- Expanded step logs list -->
                                                    <template x-if="isStepLogsExpanded(item.job.id, item.step.name)">
                                                        <div class="terminal step-logs-container" :data-step-logs-container="item.job.id + ':' + item.step.name" style="min-height: auto; max-height: 300px;">
                                                            <template x-if="getStepLogs(item.job.id, item.step.name).length === 0">
                                                                <div class="step-logs-empty" style="color: var(--code-color);">
                                                                    <i class="fas fa-info-circle"></i>
                                                                    <span x-text="!isAllLevelsSelected(item.job.id, item.step.name) ? 'No logs matching filter for this step.' : 'No logs yet for this step.'"></span>
                                                                </div>
                                                            </template>
                                                            <template x-for="(log, logIndex) in getStepLogs(item.job.id, item.step.name)" :key="logIndex">
                                                                <div class="terminal-line" :data-log-index="logIndex">
                                                                    <span class="terminal-time" x-text="formatLogTime(log.full_timestamp || log.timestamp)"></span>
                                                                    <span :class="getTerminalLevelClass(log.level)" x-text="getLogLevelTag(log.level)"></span>
                                                                    <span x-show="log.originator" x-text="'[' + log.originator + ']'" style="color: #61AFEF;"></span>
                                                                    <span x-show="log.phase" x-text="'[' + log.phase + ']'" style="color: #98C379;"></span>
                                                                    <span x-text="log.message"></span>
                                                                </div>
                                                            </template>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </template>

                                <!-- Child job row - compact display for child jobs under parent -->
                                <template x-if="item.type === 'child'">
                                    <div class="child-row" :data-type="item.type" :data-job-id="item.job?.id"
                                        style="margin-left: 2rem; margin-bottom: 0.5rem; padding: 0.75rem 1rem; background-color: #fafafa; border-left: 3px solid #17a2b8; border-radius: 4px;">
                                        <div class="columns" style="align-items: center;">
                                            <div class="column">
                                                <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                                                    <!-- Status icon -->
                                                    <span :class="{
                                                        'text-warning': item.job.status === 'pending',
                                                        'text-primary': item.job.status === 'running',
                                                        'text-success': item.job.status === 'completed',
                                                        'text-error': item.job.status === 'failed',
                                                        'text-gray': item.job.status === 'cancelled'
                                                    }">
                                                        <i class="fas" :class="{
                                                            'fa-clock': item.job.status === 'pending',
                                                            'fa-spinner fa-pulse': item.job.status === 'running',
                                                            'fa-check-circle': item.job.status === 'completed',
                                                            'fa-times-circle': item.job.status === 'failed',
                                                            'fa-ban': item.job.status === 'cancelled'
                                                        }"></i>
                                                    </span>
                                                    <!-- Child index and name -->
                                                    <span style="font-weight: 500;">
                                                        <span x-text="item.childIndex"></span>/<span x-text="item.totalChildren"></span>:
                                                        <span x-text="item.job.name || ('Child ' + item.job.id.substring(0, 8))"></span>
                                                    </span>
                                                    <!-- Job type badge -->
                                                    <template x-if="item.job.job_type">
                                                        <span class="label label-secondary" style="font-size: 0.7rem;" x-text="item.job.job_type"></span>
                                                    </template>
                                                    <!-- Status badge -->
                                                    <span class="label" :class="{
                                                        'label-warning': item.job.status === 'pending',
                                                        'label-primary': item.job.status === 'running',
                                                        'label-success': item.job.status === 'completed',
                                                        'label-error': item.job.status === 'failed',
                                                        'bg-gray': item.job.status === 'cancelled'
                                                    }" style="font-size: 0.7rem; text-transform: capitalize;" x-text="item.job.status"></span>
                                                    <!-- Document count -->
                                                    <span class="label bg-secondary" style="font-size: 0.7rem;">
                                                        <i class="fas fa-file-alt"></i> <span x-text="getDocumentsCount(item.job)"></span> docs
                                                    </span>
                                                </div>
                                                <!-- URL display for crawler child jobs -->
                                                <template x-if="item.job.seed_urls && item.job.seed_urls.length > 0">
                                                    <div style="margin-top: 0.25rem; font-size: 0.75rem; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                                        <i class="fas fa-link" style="margin-right: 0.25rem;"></i>
                                                        <a :href="item.job.seed_urls[0]" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;" @click.stop x-text="item.job.seed_urls[0]"></a>
                                                    </div>
                                                </template>
                                                <!-- Error display for failed children -->
                                                <template x-if="item.job.status === 'failed' && item.job.error">
                                                    <div style="margin-top: 0.25rem; font-size: 0.75rem; color: #dc3545;">
                                                        <i class="fas fa-exclamation-circle"></i>
                                                        <span x-text="item.job.error.substring(0, 100) + (item.job.error.length > 100 ? '...' : '')"></span>
                                                    </div>
                                                </template>
                                            </div>
                                            <!-- Action buttons -->
                                            <div class="column col-auto" @click.stop>
                                                <a :href="'/job?id=' + item.job.id" class="btn btn-sm" title="View Job Details" @click.stop>
                                                    <i class="fas fa-info-circle"></i>
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                </template>

                                <!-- Job card (parent or flat jobs only) -->
                                <template x-if="item.type !== 'loading' && item.type !== 'step' && item.type !== 'child'">

                                    <div class="card job-card-clickable" :class="{
                                            'bg-gray': selectedJob && selectedJob.id === item.job.id,
                                            'job-card-parent': item.type === 'parent',
                                            'job-card-child': item.type === 'child',
                                            'job-card-flat': item.type === 'flat'
                                        }" style="margin-bottom: 0.8rem; cursor: pointer;" :data-job-id="item.job.id" @click="toggleJobStepsCollapse(item.job.id)">
                                        <div class="card-body">
                                            <div class="columns" style="gap: 0.5rem;">
                                                <!-- Left side: Checkbox and Content -->
                                                <div class="column col-auto" @click.stop style="padding-right: 0;">
                                                    <label class="form-checkbox" style="margin: 0;">
                                                        <input type="checkbox" class="job-checkbox" :data-job-id="item.job.id" @change="toggleJobSelection(item.job.id)" :checked="selectedJobIds.has(item.job.id)">
                                                        <i class="form-icon"></i>
                                                    </label>
                                                </div>
                                                <div class="column col-9" style="padding-left: 0;padding-right: 0;">
                                                    <div class="card-title h5" :title="'Job ID: ' + (item.job.id || 'N/A')">
                                                        <i class="fas" :class="{
                                                    'fa-file job-type-icon child-icon': item.type === 'child',
                                                    'fa-folder job-type-icon parent-icon': item.type === 'parent'
                                                }"></i>
                                                        <span x-text="item.job.name || ('Job ' + (item.job.id ? item.job.id.substring(0, 8) : 'N/A'))"></span>
                                                        <span class="text-gray" style="font-size: 0.8rem; font-weight: normal;">
                                                            (<span x-text="item.job.id ? item.job.id.substring(0, 8) : 'N/A'"></span>)
                                                        </span>
                                                        <template x-if="item.type === 'parent'">
                                                            <span class="parent-job-badge">PARENT</span>
                                                        </template>
                                                        <template x-if="item.type === 'parent' && item.job.entity_type === 'job_definition'">
                                                            <span class="label label-info" style="margin-left: 0.5rem; font-size: 0.7rem;">JOB
                                                                DEFINITION</span>
                                                        </template>
                                                        <!-- Expand/Collapse button for parent jobs with children (only for non-multi-step jobs) -->
                                                        <!-- For multi-step jobs, children expand under their respective step rows -->
                                                        <template x-if="item.type === 'parent' && item.job.child_count > 0 && !(item.job.metadata?.step_definitions?.length > 0)">
                                                            <button class="btn btn-sm" style="margin-left: 0.5rem; padding: 0.1rem 0.5rem; font-size: 0.75rem;" @click.stop="toggleParentExpand(item.job.id)"
                                                                :title="isParentExpanded(item.job.id) ? 'Collapse children' : 'Expand children'">
                                                                <i class="fas" :class="isParentExpanded(item.job.id) ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                                                                <span x-text="item.job.child_count + ' children'"></span>
                                                            </button>
                                                        </template>
                                                    </div>
                                                    <!-- Source field removed - redundant for parent jobs -->

                                                    <!-- URL Display for Crawler Jobs -->
                                                    <template x-if="item.job.seed_urls && item.job.seed_urls.length > 0">
                                                        <div style="margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: #555;">
                                                            <i class="fas fa-link" style="color: #3b82f6;"></i>
                                                            <a :href="item.job.seed_urls[0]" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;" @click.stop>
                                                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 600px;" :title="item.job.seed_urls[0]" x-text="item.job.seed_urls[0]"></span>
                                                                <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                                            </a>
                                                            <template x-if="item.job.seed_urls.length > 1">
                                                                <span class="text-gray" style="font-size: 0.8rem; margin-left: 0.5rem;" x-text="'+' + (item.job.seed_urls.length - 1) + ' more'"></span>
                                                            </template>
                                                        </div>
                                                    </template>
                                                    <template x-if="(!item.job.seed_urls || item.job.seed_urls.length === 0) && item.job.progress && item.job.progress.current_url">
                                                        <div style="margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: #555;">
                                                            <i class="fas fa-link" style="color: #3b82f6;"></i>
                                                            <a :href="item.job.progress.current_url" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;" @click.stop>
                                                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 600px;" :title="item.job.progress.current_url" x-text="item.job.progress.current_url"></span>
                                                                <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                                            </a>
                                                        </div>
                                                    </template>

                                                    <!-- Metadata row - clicking anywhere on job card toggles step collapse -->
                                                    <div style="margin-top: 0.8rem; display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem;">
                                                        <!-- Collapse/Expand indicator for multi-step jobs -->
                                                        <template x-if="item.job.metadata?.step_definitions?.length > 0">
                                                            <div style="display: flex; align-items: center; margin-right: 0.25rem;" :title="isJobStepsCollapsed(item.job.id) ? 'Click to expand steps' : 'Click to collapse steps'">
                                                                <i class="fas" :class="isJobStepsCollapsed(item.job.id) ? 'fa-chevron-right' : 'fa-chevron-down'" style="color: #666;"></i>
                                                            </div>
                                                        </template>
                                                        <!-- Status Badge -->
                                                        <div>
                                                            <span class="label" :class="getStatusBadgeClass(item.type, item.job.status, item.job)" :data-job-id="item.job.id" :data-status="item.job.status">
                                                                <i class="fas" :class="getStatusIcon(item.type === 'parent' && item.job.child_count > 0 ? deriveParentStatus(item.job).status : item.job.status)" style="margin-right: 0.25rem;"></i>
                                                                <span x-text="getStatusBadgeText(item.type, item.job.status, item.job)"></span>
                                                            </span>
                                                        </div>
                                                        <!-- Job Type Badge -->
                                                        <template x-if="item.job.job_type && item.job.job_type !== 'parent'">
                                                            <div>
                                                                <span class="label" :class="window.getJobTypeBadgeClass(item.job.job_type)" :title="window.getJobTypeDisplayName(item.job.job_type)">
                                                                    <i class="fas" :class="window.getJobTypeIcon(item.job.job_type)"></i>
                                                                    <span x-text="window.getJobTypeDisplayName(item.job.job_type)"></span>
                                                                </span>
                                                            </div>
                                                        </template>
                                                        <!-- Documents (only for non-multi-step jobs - multi-step jobs show docs per step) -->
                                                        <template x-if="!item.job.metadata?.step_definitions || item.job.metadata.step_definitions.length === 0">
                                                            <div>
                                                                <i class="fas fa-file-alt"></i>
                                                                <span x-text="(() => { const count = getDocumentsCount(item.job); return (typeof count === 'number' ? count : 'N/A') + ' Documents'; })()"></span>
                                                            </div>
                                                        </template>
                                                        <!-- Created Time -->
                                                        <div>
                                                            <i class="fas fa-calendar"></i>
                                                            <span x-text="'created: ' + getCreatedDate(item.job)"></span>
                                                        </div>
                                                        <!-- Started Time -->
                                                        <template x-if="item.job.started_at">
                                                            <div>
                                                                <i class="fas fa-clock"></i>
                                                                <span x-text="'started: ' + getStartedDate(item.job)"></span>
                                                            </div>
                                                        </template>
                                                        <!-- Ended Time (for completed/failed/cancelled jobs) -->
                                                        <template x-if="item.job.finished_at && ['completed', 'failed', 'cancelled'].includes(item.job.status)">
                                                            <div>
                                                                <i class="fas fa-flag-checkered"></i>
                                                                <span x-text="'ended: ' + getFinishedDate(item.job)"></span>
                                                            </div>
                                                        </template>
                                                        <!-- Job Details Link -->
                                                        <div>
                                                            <a :href="'/job?id=' + item.job.id" class="text-primary" @click.stop>
                                                                <i class="fas fa-info-circle"></i> Job Details
                                                            </a>
                                                        </div>
                                                    </div>

                                                    <!-- Failure Reason Display - only show for terminal failed state -->
                                                    <template x-if="(item.type === 'parent' ? deriveParentStatus(item.job).status === 'failed' : item.job.status === 'failed') && item.job.error">
                                                        <div class="job-error-alert" style="margin-top: 0.8rem; padding: 0.75rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-size: 0.875rem;">
                                                            <i class="fas fa-exclamation-circle" style="color: var(--color-danger); margin-right: 0.5rem;"></i>
                                                            <strong>Failure Reason:</strong>
                                                            <span x-show="item.job.error.length <= 100" x-text="item.job.error"></span>
                                                            <span x-show="item.job.error.length > 100">
                                                                <span x-text="item.job.error.substring(0, 100) + '...'"></span>
                                                                <a href="#" class="text-primary" @click.prevent="openErrorDetailsModal(item.job)" style="margin-left: 0.5rem;">[View Details]</a>
                                                            </span>
                                                        </div>
                                                    </template>

                                                    <!-- Parent progress display from backend status_report -->
                                                    <template x-if="item.type === 'parent'">
                                                        <div class="parent-progress-container">
                                                            <!-- Enhanced Crawler Progress Display (Inline) -->
                                                            <template x-if="isCrawlerJob(item.job)">
                                                                <div class="crawler-progress-inline" style="margin-top: 0.8rem;">
                                                                    <!-- Progress Text Inline -->
                                                                    <div style="display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem; align-items: center;">
                                                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                                            <i class="fas fa-tasks" style="color: #666;"></i>
                                                                            <span x-text="getCrawlerProgressText(item.job)" style="font-weight: 500;"></span>
                                                                        </div>
                                                                        <template x-if="item.job.progress || item.job.status_report">
                                                                            <div style="display: flex; align-items: center; gap: 1rem; font-size: 0.75rem; color: #666;">
                                                                                <span>
                                                                                    <i class="fas fa-link" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_found') || '0'"></span>
                                                                                    found
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-filter" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_filtered') || '0'"></span>
                                                                                    filtered
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-arrow-right" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_followed') || '0'"></span>
                                                                                    followed
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-layer-group" style="margin-right: 0.25rem;"></i>
                                                                                    depth <span x-text="getCrawlerStat(item.job, 'max_depth') || '1'"></span>
                                                                                </span>
                                                                            </div>
                                                                        </template>
                                                                    </div>
                                                                </div>
                                                            </template>

                                                            <!-- Errors from backend -->
                                                            <template x-if="item.job.status_report?.errors && item.job.status_report.errors.length > 0">
                                                                <div style="margin-top: 0.5rem; padding: 0.5rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-size: 0.875rem;">
                                                                    <strong style="color: var(--color-danger);"><i class="fas fa-exclamation-circle"></i>
                                                                        Errors:</strong>
                                                                    <ul style="margin: 0.25rem 0 0 1.5rem; padding: 0;">
                                                                        <template x-for="error in item.job.status_report.errors" :key="error">
                                                                            <li x-text="error"></li>
                                                                        </template>
                                                                    </ul>
                                                                </div>
                                                            </template>

                                                            <!-- Warnings from backend -->
                                                            <template x-if="item.job.status_report?.warnings && item.job.status_report.warnings.length > 0">
                                                                <div style="margin-top: 0.5rem; padding: 0.5rem; background-color: #fff3cd; border-left: 4px solid var(--color-warning); border-radius: 4px; font-size: 0.875rem;">
                                                                    <strong style="color: #856404;"><i class="fas fa-exclamation-triangle"></i>
                                                                        Warnings:</strong>
                                                                    <ul style="margin: 0.25rem 0 0 1.5rem; padding: 0;">
                                                                        <template x-for="warning in item.job.status_report.warnings" :key="warning">
                                                                            <li x-text="warning"></li>
                                                                        </template>
                                                                    </ul>
                                                                </div>
                                                            </template>

                                                            <!-- Job Logs Panel moved to step rows -->
                                                        </div>
                                                    </template>
                                                </div>

                                                <!-- Right side: Actions -->
                                                <div class="column col-auto align-right" @click.stop>
                                                    <!-- Refresh button for parent jobs -->
                                                    <template x-if="item.type === 'parent'">
                                                        <button class="btn btn-sm" @click="refreshParentJob(item.job.id)" title="Refresh Job Stats">
                                                            <i class="fa-solid fa-sync"></i>
                                                        </button>
                                                    </template>
                                                    <template x-if="item.job.status !== 'running'">
                                                        <button class="btn btn-sm" @click="window.rerunJob(item.job.id, $event)" title="Copy Job and Add to Queue">
                                                            <i class="fa-solid fa-rotate-right"></i>
                                                        </button>
                                                    </template>
                                                    <template x-if="item.job.status === 'running'">
                                                        <button class="btn btn-sm btn-warning" @click="window.cancelJob(item.job.id, $event)" title="Cancel Job">
                                                            <i class="fas fa-stop"></i>
                                                        </button>
                                                    </template>
                                                    <template x-if="item.job.status !== 'running'">
                                                        <button class="btn btn-sm btn-error" @click="window.deleteJob(item.job.id, $event)" title="Delete Job">
                                                            <i class="fas fa-trash"></i>
                                                        </button>
                                                    </template>
                                                </div>
                                            </div>

                                            <!-- Inline Tree View (shown when job is expanded) - Light Theme -->
                                            <template x-if="item.type === 'parent' && (item.job.metadata?.step_definitions?.length > 0 || jobTreeData[item.job.id]) && !isJobStepsCollapsed(item.job.id)">
                                                <div class="inline-tree-view" @click.stop style="margin-top: 1rem; background-color: #f5f5f5; border-radius: 6px; overflow: hidden; border: 1px solid #ddd;">
                                                    <!-- Tree header with job details and search -->
                                                    <div style="padding: 0.5rem 1rem; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; background-color: #e8e8e8; font-size: 0.8rem;">
                                                        <span style="color: #333; font-family: monospace;">
                                                            <template x-if="jobTreeData[item.job.id]">
                                                                <span>
                                                                    <span x-text="jobTreeData[item.job.id].steps?.length || 0"></span>
                                                                    steps
                                                                </span>
                                                            </template>
                                                        </span>
                                                        <span style="color: #666;">
                                                            <i class="fas fa-calendar" style="margin-right: 0.25rem;"></i>
                                                            <span x-text="getCreatedDate(item.job)"></span>
                                                        </span>
                                                        <template x-if="item.job.started_at">
                                                            <span style="color: #666;">
                                                                <i class="fas fa-play" style="margin-right: 0.25rem;"></i>
                                                                <span x-text="getStartedDate(item.job)"></span>
                                                            </span>
                                                        </template>
                                                        <template x-if="item.job.finished_at">
                                                            <span style="color: #666;">
                                                                <i class="fas fa-flag-checkered" style="margin-right: 0.25rem;"></i>
                                                                <span x-text="getFinishedDate(item.job)"></span>
                                                            </span>
                                                        </template>
                                                        <span style="flex: 1;"></span>
                                                        <!-- Log level filter dropdown with checkboxes (matching settings-logs.html style exactly) -->
                                                        <div class="dropdown">
                                                            <a href="#" class="btn btn-sm dropdown-toggle" :class="!isAllLevelsSelected(item.job.id) ? 'btn-primary' : ''" tabindex="0">
                                                                <i class="fas fa-filter"></i> Filter
                                                            </a>
                                                            <ul class="menu">
                                                                <li class="menu-item">
                                                                    <label class="form-checkbox">
                                                                        <input type="checkbox" :checked="getTreeLogLevelChecked(item.job.id, 'debug')" @change="toggleTreeLogLevel(item.job.id, 'debug')">
                                                                        <i class="form-icon"></i> Debug
                                                                    </label>
                                                                </li>
                                                                <li class="menu-item">
                                                                    <label class="form-checkbox">
                                                                        <input type="checkbox" :checked="getTreeLogLevelChecked(item.job.id, 'info')" @change="toggleTreeLogLevel(item.job.id, 'info')">
                                                                        <i class="form-icon"></i> Info
                                                                    </label>
                                                                </li>
                                                                <li class="menu-item">
                                                                    <label class="form-checkbox">
                                                                        <input type="checkbox" :checked="getTreeLogLevelChecked(item.job.id, 'warn')" @change="toggleTreeLogLevel(item.job.id, 'warn')">
                                                                        <i class="form-icon"></i> Warn
                                                                    </label>
                                                                </li>
                                                                <li class="menu-item">
                                                                    <label class="form-checkbox">
                                                                        <input type="checkbox" :checked="getTreeLogLevelChecked(item.job.id, 'error')" @change="toggleTreeLogLevel(item.job.id, 'error')">
                                                                        <i class="form-icon"></i> Error
                                                                    </label>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                        <button class="btn btn-sm" @click.stop="refreshJobTreeData(item.job.id)">
                                                            <i class="fa-solid fa-rotate-right" :class="jobTreeLoading[item.job.id] ? 'fa-spin' : ''"></i>
                                                        </button>
                                                    </div>

                                                    <!-- Loading state -->
                                                    <template x-if="jobTreeLoading[item.job.id] && !jobTreeData[item.job.id]">
                                                        <div style="padding: 2rem; text-align: center; color: #666;">
                                                            <i class="fas fa-spinner fa-pulse"></i> Loading...
                                                        </div>
                                                    </template>

                                                    <!-- Tree content -->
                                                    <template x-if="jobTreeData[item.job.id]">
                                                        <div class="tree-step-container">
                                                            <template x-for="(step, stepIndex) in jobTreeData[item.job.id].steps" :key="stepIndex">
                                                                <div class="tree-step">
                                                                    <!-- Step header -->
                                                                    <div class="tree-step-header" :class="{ 'step-failed': step.status === 'failed' }" @click.stop="toggleTreeStep(item.job.id, stepIndex)">
                                                                        <!-- Expand/collapse indicator -->
                                                                        <span class="tree-step-chevron">
                                                                            <i class="fas" :class="isTreeStepExpanded(item.job.id, stepIndex) ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                                                                        </span>
                                                                        <!-- Status icon -->
                                                                        <span class="tree-step-status" :class="{
                                                                            'text-warning': step.status === 'pending',
                                                                            'text-primary': step.status === 'running',
                                                                            'text-success': step.status === 'completed',
                                                                            'text-error': step.status === 'failed',
                                                                            'text-gray': step.status === 'cancelled'
                                                                        }">
                                                                            <i class="fas" :class="{
                                                                                'fa-clock': step.status === 'pending',
                                                                                'fa-spinner fa-pulse': step.status === 'running',
                                                                                'fa-check-circle': step.status === 'completed',
                                                                                'fa-times-circle': step.status === 'failed',
                                                                                'fa-ban': step.status === 'cancelled'
                                                                            }"></i>
                                                                        </span>
                                                                        <!-- Step name -->
                                                                        <span class="tree-step-name" x-text="step.name"></span>
                                                                        <!-- Step status badge -->
                                                                        <span class="label" style="font-size: 0.65rem; padding: 0.1rem 0.4rem;" :class="{
                                                                                'label-warning': step.status === 'pending',
                                                                                'label-primary': step.status === 'running',
                                                                                'label-success': step.status === 'completed',
                                                                                'label-error': step.status === 'failed',
                                                                                'bg-gray': step.status === 'cancelled'
                                                                            }" x-text="step.status"></span>
                                                                        <!-- Log count display - shows total log count -->
                                                                        <template x-if="step.logs && step.logs.length > 0">
                                                                            <span class="label bg-secondary" style="font-size: 0.65rem; padding: 0.1rem 0.4rem; margin-left: 0.25rem;">
                                                                                <i class="fas fa-file-lines" style="margin-right: 0.15rem;"></i>
                                                                                <span
                                                                                    x-text="step.unfilteredLogCount || step.totalLogCount || step.logs.length"></span>
                                                                            </span>
                                                                        </template>
                                                                        <!-- Download logs button (enabled when step is completed/failed) -->
                                                                        <template x-if="step.status === 'completed' || step.status === 'failed'">
                                                                            <button class="btn btn-sm btn-link step-download-btn" @click.stop="downloadStepLogs(item.job.id, step.name, step.step_id)" title="Download step logs"
                                                                                style="margin-left: auto; padding: 0.1rem 0.3rem;">
                                                                                <i class="fas fa-download"></i>
                                                                            </button>
                                                                        </template>
                                                                    </div>

                                                                    <!-- Step logs (collapsible) -->
                                                                    <template x-if="isTreeStepExpanded(item.job.id, stepIndex)">
                                                                        <div class="tree-step-logs" @click.stop>
                                                                            <!-- Error groups -->
                                                                            <template x-if="step.child_summary && step.child_summary.error_groups && step.child_summary.error_groups.length > 0">
                                                                                <div>
                                                                                    <template x-for="(errGroup, errIdx) in step.child_summary.error_groups" :key="errIdx">
                                                                                        <div class="tree-error-group">
                                                                                            <i class="fas fa-times"></i>
                                                                                            <span x-text="errGroup.message"></span>
                                                                                            <span style="opacity: 0.7; margin-left: 0.5rem;" x-text="'(' + errGroup.count + ')'"></span>
                                                                                        </div>
                                                                                    </template>
                                                                                </div>
                                                                            </template>

                                                                            <!-- Log lines (limited to step-specific limit, earliest-to-latest) -->
                                                                            <template x-for="(log, logIdx) in getFilteredTreeLogs(getStepLogs(item.job.id, step.name), item.job.id, step.name)" :key="logIdx">
                                                                                <div class="tree-log-line" :class="{ 'log-error': log.level === 'error' }">
                                                                                    <!-- Line number: always use server-provided line_number for accurate ordering -->
                                                                                    <span class="tree-log-num" x-text="log.line_number || (logIdx + 1)"></span>
                                                                                    <!-- Log level badge -->
                                                                                    <span :class="getTerminalLevelClass(log.level)" x-text="getLogLevelTag(log.level)" style="margin-right: 0.5rem; font-weight: 500;"></span>
                                                                                    <!-- Log text -->
                                                                                    <span class="tree-log-text" x-text="log.text || log.message"></span>
                                                                                </div>
                                                                            </template>

                                                                            <!-- Loading logs message (shown while fetch is in progress) -->
                                                                            <template x-if="(!step.logs || step.logs.length === 0) && isStepLogsLoading(item.job.id, step.name)">
                                                                                <div class="tree-logs-empty" style="color: #888;">
                                                                                    <i class="fas fa-spinner fa-spin" style="margin-right: 0.5rem;"></i>
                                                                                    Loading logs...
                                                                                </div>
                                                                            </template>
                                                                            <!-- Empty logs message (shown only when fetch is complete and no logs exist) -->
                                                                            <template x-if="(!step.logs || step.logs.length === 0) && !isStepLogsLoading(item.job.id, step.name)">
                                                                                <div class="tree-logs-empty">
                                                                                    No logs for this step
                                                                                </div>
                                                                            </template>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                            </template>

                                                            <!-- No steps message -->
                                                            <template x-if="!jobTreeData[item.job.id].steps || jobTreeData[item.job.id].steps.length === 0">
                                                                <div style="padding: 1rem; text-align: center; color: #666;">
                                                                    No steps found for this job
                                                                </div>
                                                            </template>
                                                        </div>
                                                    </template>
                                                </div>
                                            </template>
                                            <!-- Job Configuration (Collapsible JSON) -->
                                            <div :id="'job-json-' + $id(item.job.id)" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                                                <pre
                                                    style="background-color: #ffffff; padding: 1rem; border: 1px solid #e0e0e0; border-radius: 4px; overflow-x: auto; max-height: 400px;"><code class="language-json" x-text="JSON.stringify(item.job, null, 2)"></code></pre>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </template>

                        <!-- No jobs message -->
                        <template x-if="itemsToRender.length === 0 && !isLoading && !loadError">
                            <div class="text-center text-gray" style="padding: 2rem;">
                                <span x-text="filteredJobs.length === 0 ? 'No jobs found matching the current filters.' : ''"></span>
                            </div>
                        </template>

                        <!-- Loading indicator when no jobs yet (initial load) -->
                        <template x-if="itemsToRender.length === 0 && isLoading && isInitialLoad">
                            <div class="text-center" style="padding: 2rem;">
                                <div class="loading loading-lg" style="margin-bottom: 1rem;"></div>
                                <span class="text-secondary">Loading jobs...</span>
                            </div>
                        </template>
                    </div>

                    <!-- Pagination Controls -->
                    <div id="job-pagination-container" class="pagination-container">
                        <!-- Pagination handled by separate function -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Service Logs -->
        <section>
            {{template "service-logs.html" .}}
        </section>

    </main>

    {{template "footer.html" .}}

    {{template "snackbar.html" .}}

    <!-- Filter Modal -->
    <div id="filter-modal" class="modal">
        <a href="#close" class="modal-overlay" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
                <div class="modal-title h5">Filter Crawler Jobs</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Status Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Status</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="pending" checked>
                            <i class="form-icon"></i> Pending
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="running" checked>
                            <i class="form-icon"></i> Running
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="completed" checked>
                            <i class="form-icon"></i> Completed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="failed" checked>
                            <i class="form-icon"></i> Failed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="cancelled" checked>
                            <i class="form-icon"></i> Cancelled
                        </label>
                    </div>

                    <!-- Source Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Source Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="jira">
                            <i class="form-icon"></i> Jira
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="confluence">
                            <i class="form-icon"></i> Confluence
                        </label>
                    </div>

                    <!-- Entity Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Entity Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="projects">
                            <i class="form-icon"></i> Projects
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="spaces">
                            <i class="form-icon"></i> Spaces
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="repos">
                            <i class="form-icon"></i> Repos
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" onclick="clearAllFilters()">Clear All</button>
                <button type="button" class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="modal" x-data="deleteConfirmModal" x-init="init()">
        <a href="#close" class="modal-overlay" aria-label="Close" @click.prevent="closeModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true" style="max-width: 800px;">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" @click.prevent="closeModal()"></a>
                <div class="modal-title h5">Confirm Job Deletion</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Warning Message -->
                    <div class="toast toast-warning" style="margin-bottom: 1rem;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span x-text="`You are about to delete ${jobs.length} job${jobs.length > 1 ? 's' : ''}. This action cannot be undone.`"></span>
                    </div>

                    <!-- Cascade Warning -->
                    <template x-if="totalChildren > 0">
                        <div class="toast toast-error" style="margin-bottom: 1rem;">
                            <i class="fas fa-info-circle"></i>
                            <span x-text="`This will also delete ${totalChildren} child job${totalChildren > 1 ? 's' : ''}.`"></span>
                        </div>
                    </template>

                    <!-- Jobs Table -->
                    <div class="table-container" style="max-height: 300px; overflow-y: auto; margin-bottom: 1rem;">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Job ID</th>
                                    <th>Name</th>
                                    <th>Status</th>
                                    <th>Children</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="job in jobs" :key="job.id">
                                    <tr>
                                        <td>
                                            <code x-text="job.id.substring(0, 8)"></code>
                                        </td>
                                        <td x-text="job.name"></td>
                                        <td>
                                            <span class="label" :class="getStatusBadgeClass(job.status)">
                                                <span x-text="getStatusDisplayText(job.status)"></span>
                                            </span>
                                        </td>
                                        <td x-text="job.childCount"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>

                    <!-- Confirmation Checkbox -->
                    <div class="form-group">
                        <label class="form-checkbox">
                            <input type="checkbox" x-model="checkboxChecked">
                            <i class="form-icon"></i>
                            <span>I understand this action is permanent and cannot be undone</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" @click="closeModal()">Cancel</button>
                <button type="button" class="btn btn-error" :disabled="!checkboxChecked" @click="confirm()">
                    <i class="fas fa-trash"></i>
                    <span>Delete</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Error Details Modal -->
    <div id="error-details-modal" class="modal" x-data="errorDetailsModal" x-init="init()">
        <a href="#close" class="modal-overlay" aria-label="Close" @click.prevent="closeModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true" style="max-width: 800px;">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" @click.prevent="closeModal()"></a>
                <div class="modal-title h5">Error Details</div>
            </div>

            <div class="modal-body">

                <div class="content">

                    <!-- Job Context -->
                    <div class="form-group">

                        <label class="form-label"><strong>Job Information</strong></label>

                        <div style="padding: 0.75rem; background-color: #f5f5f5; border-radius: 4px; margin-bottom: 1rem;">
                            <div style="margin-bottom: 0.5rem;">
                                <strong>Job ID:</strong>
                                <code x-text="job ? job.id.substring(0, 8) : 'N/A'"></code>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job && job.name">
                                <strong>Name:</strong>
                                <span x-text="job ? job.name : ''"></span>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job">
                                <strong>Status:</strong>
                                <span>
                                    <span class="label" :class="job ? getStatusBadgeClass(job.status) : ''">
                                        <span x-text="job ? getStatusDisplayText(job.status) : ''"></span>
                                    </span>
                                </span>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job && job.created_at">
                                <strong>Created:</strong>
                                <span x-text="job ? new Date(job.created_at).toLocaleString() : ''"></span>
                            </div>
                            <div x-show="job && getJobURL(job)">
                                <strong>URL:</strong>
                                <a :href="getJobURL(job)" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;">
                                    <span x-text="getJobURL(job)"></span>
                                    <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                </a>
                            </div>
                        </div>
                    </div>

                    <!-- Error Message -->
                    <div class="form-group">
                        <label class="form-label"><strong>Error Message</strong></label>
                        <div x-show="job && job.error" style="padding: 0.75rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-family: monospace; white-space: pre-wrap; word-wrap: break-word;">
                            <span x-text="job ? job.error : ''"></span>
                        </div>
                        <div x-show="!job || !job.error" style="padding: 0.75rem; color: #666; font-style: italic;">
                            No error details available
                        </div>
                    </div>

                </div>

            </div>

            <div class="modal-footer">
                <button type="button" class="btn" @click="closeModal()">Close</button>
            </div>

        </div>

    </div>

    <script>
        // State management (moved to Alpine component jobList)
        let allJobs = [];
        let filteredJobs = [];
        let selectedJob = null;

        // Hierarchy state management
        let expandedParents = new Set(); // Track expanded parent jobs

        // WebSocket connection state (using global WebSocketManager)
        let wsConnected = false;
        let wsUnsubscribers = []; // Track WebSocketManager subscriptions for cleanup

        // Default filters - include all statuses
        const defaultFilters = {
            status: new Set(['pending', 'running', 'completed', 'failed', 'cancelled']),
            source: new Set(),
            entity: new Set()
        };

        // Filter state - initialize immediately with defaults to prevent undefined errors
        let activeFilters = {
            status: new Set(defaultFilters.status),
            source: new Set(defaultFilters.source),
            entity: new Set(defaultFilters.entity)
        };

        // Initialize filters immediately on script load
        window.activeFilters = activeFilters;

        // Modal resolver map for event-based API
        window.deleteModalResolvers = new Map();

        // Load filters from localStorage
        function loadFiltersFromStorage() {
            try {
                const stored = localStorage.getItem('quaero-job-filters');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    activeFilters.status = new Set(parsed.status || []);
                    activeFilters.source = new Set(parsed.source || []);
                    activeFilters.entity = new Set(parsed.entity || []);

                    // If no filters were saved, use defaults
                    if (activeFilters.status.size === 0 && activeFilters.source.size === 0 && activeFilters.entity.size === 0) {
                        activeFilters = {
                            status: new Set(defaultFilters.status),
                            source: new Set(defaultFilters.source),
                            entity: new Set(defaultFilters.entity)
                        };
                    }
                } else {
                    // Use defaults for first time users
                    activeFilters = {
                        status: new Set(defaultFilters.status),
                        source: new Set(defaultFilters.source),
                        entity: new Set(defaultFilters.entity)
                    };
                }
            } catch (error) {
                console.warn('Failed to load filters from localStorage:', error);
                // Use defaults on error
                activeFilters = {
                    status: new Set(defaultFilters.status),
                    source: new Set(defaultFilters.source),
                    entity: new Set(defaultFilters.entity)
                };
            }
        }

        // Save filters to localStorage
        function saveFiltersToStorage() {
            try {
                const toSave = {
                    status: Array.from(activeFilters.status),
                    source: Array.from(activeFilters.source),
                    entity: Array.from(activeFilters.entity)
                };
                localStorage.setItem('quaero-job-filters', JSON.stringify(toSave));
            } catch (error) {
                console.warn('Failed to save filters to localStorage:', error);
            }
        }

        // Load job statistics - now handled by Alpine component (kept for compatibility)
        function loadStats() {
            // Trigger stats recalculation from current job list
            window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
        }

        // Load all jobs - dispatches event to Alpine component
        function loadJobs() {
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Wrapper function for loadJobs() - maintains compatibility
        function loadJobQueue() {
            loadJobs();
        }


        // Update job in list from WebSocket update - dispatches event to Alpine component
        async function updateJobInList(update) {
            window.dispatchEvent(new CustomEvent('jobList:updateJob', { detail: update }));
        }

        // Get user-friendly display name for source type
        function getSourceTypeDisplay(sourceType) {
            const displayName = {
                'jira': 'Jira',
                'confluence': 'Confluence',
                'github': 'GitHub'
            };

            // Return the display name if available, otherwise show the raw source type
            if (sourceType && displayName[sourceType]) {
                return 'Source: ' + displayName[sourceType];
            }

            // For any other source type, just display it as-is
            return 'Source: ' + (sourceType || 'N/A');
        }

        // Check if job matches active filters
        function matchesActiveFilters(job) {
            // Check status filter
            if (activeFilters.status.size > 0 && !activeFilters.status.has(job.status)) {
                return false;
            }

            // Check source filter
            if (activeFilters.source.size > 0 && !activeFilters.source.has(job.source_type)) {
                return false;
            }

            // Check entity filter
            if (activeFilters.entity.size > 0 && !activeFilters.entity.has(job.entity_type)) {
                return false;
            }

            return true;
        }

        // Show filter modal
        function showFilterModal() {
            const modal = document.getElementById('filter-modal');

            // Sync modal checkboxes with activeFilters state
            document.querySelectorAll('.filter-status').forEach(checkbox => {
                checkbox.checked = activeFilters.status.has(checkbox.value);
            });
            document.querySelectorAll('.filter-source').forEach(checkbox => {
                checkbox.checked = activeFilters.source.has(checkbox.value);
            });
            document.querySelectorAll('.filter-entity').forEach(checkbox => {
                checkbox.checked = activeFilters.entity.has(checkbox.value);
            });

            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }

        // Close filter modal
        function closeFilterModal() {
            const modal = document.getElementById('filter-modal');
            modal.classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Apply filters from modal
        function applyFilters() {
            // Update activeFilters from modal checkboxes
            activeFilters.status.clear();
            document.querySelectorAll('.filter-status:checked').forEach(cb => {
                activeFilters.status.add(cb.value);
            });

            activeFilters.source.clear();
            document.querySelectorAll('.filter-source:checked').forEach(cb => {
                activeFilters.source.add(cb.value);
            });

            activeFilters.entity.clear();
            document.querySelectorAll('.filter-entity:checked').forEach(cb => {
                activeFilters.entity.add(cb.value);
            });

            // Save filters to localStorage
            saveFiltersToStorage();

            // Close modal and refresh
            closeFilterModal();
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Clear all filters
        function clearAllFilters() {
            // Uncheck all checkboxes in modal
            document.querySelectorAll('.filter-status, .filter-source, .filter-entity').forEach(cb => {
                cb.checked = false;
            });
        }

        // Render filter chips
        function renderFilterChips() {
            const container = document.getElementById('filter-chips-container');
            let html = '';

            // Status chips
            activeFilters.status.forEach(status => {
                const colorClass = {
                    'pending': 'label-warning',
                    'running': 'label-primary',
                    'completed': 'label-success',
                    'failed': 'label-error',
                    'cancelled': 'label-warning'
                }[status] || 'label-default';

                html += `
                    <span class="label ${colorClass}">
                        ${status.charAt(0).toUpperCase() + status.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('status', '${status}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Source chips
            activeFilters.source.forEach(source => {
                html += `
                    <span class="label label-primary">
                        ${source.charAt(0).toUpperCase() + source.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('source', '${source}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Entity chips
            activeFilters.entity.forEach(entity => {
                html += `
                    <span class="label label-primary">
                        ${entity.charAt(0).toUpperCase() + entity.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('entity', '${entity}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            container.innerHTML = html;
        }

        // Remove individual filter
        function removeFilter(category, value) {
            activeFilters[category].delete(value);
            saveFiltersToStorage(); // Save after removing filter
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Connect to WebSocket for real-time job updates using global WebSocketManager
        // This eliminates duplicate WebSocket connections - WebSocketManager handles reconnection
        function connectJobsWebSocket() {
            if (typeof WebSocketManager === 'undefined') {
                console.error('[Queue] WebSocketManager not loaded - real-time updates disabled');
                return;
            }

            console.log('[Queue] Subscribing to WebSocketManager for job updates');

            // Subscribe to connection state changes
            wsUnsubscribers.push(WebSocketManager.onConnectionChange((connected) => {
                wsConnected = connected;
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected, reconnecting: !connected }
                }));
                if (connected) {
                    console.log('[Queue] WebSocket connected via WebSocketManager');
                }
            }));


            // Subscribe to server restart events - clear all job state to avoid stale data
            wsUnsubscribers.push(WebSocketManager.onServerRestart(({ oldInstanceId, newInstanceId }) => {
                console.log('[Queue] Server restart detected - clearing all job state');
                window.dispatchEvent(new CustomEvent('jobList:serverRestart', {
                    detail: { oldInstanceId, newInstanceId }
                }));
            }));
            // Subscribe to queue stats updates
            wsUnsubscribers.push(WebSocketManager.subscribe('queue_stats', (payload) => {
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: {
                        pending: payload.pending_messages || 0,
                        inFlight: payload.in_flight_messages || 0,
                        workers: payload.concurrency || 0,
                        connected: true
                    }
                }));
            }));

            // Subscribe to job_stats events for real-time Queue Metrics updates
            // This provides immediate stats without API roundtrip when jobs change status
            wsUnsubscribers.push(WebSocketManager.subscribe('job_stats', (payload) => {
                window.dispatchEvent(new CustomEvent('jobStats:update', { detail: payload }));
            }));

            // Subscribe to job status change events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_status_change', (payload) => {
                updateJobInList(payload);
                window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
            }));

            // Subscribe to job created events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_created', (payload) => {
                updateJobInList(payload);
                window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
            }));

            // Subscribe to job progress events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_progress', (payload) => {
                updateJobInList(payload);
            }));

            // Subscribe to job completed events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_completed', (payload) => {
                updateJobInList(payload);
                window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
            }));

            // Subscribe to crawler job progress events
            wsUnsubscribers.push(WebSocketManager.subscribe('crawler_job_progress', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:updateJobProgress', { detail: payload }));
            }));

            // Subscribe to parent job progress events
            wsUnsubscribers.push(WebSocketManager.subscribe('parent_job_progress', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:updateJobProgress', {
                    detail: {
                        job_id: payload.job_id,
                        progress_text: payload.progress_text,
                        status: payload.status,
                        total_children: payload.total_children,
                        pending_children: payload.pending_children,
                        running_children: payload.running_children,
                        completed_children: payload.completed_children,
                        failed_children: payload.failed_children,
                        cancelled_children: payload.cancelled_children,
                        document_count: payload.document_count,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // Subscribe to job step progress events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_step_progress', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:updateJobProgress', {
                    detail: {
                        job_id: payload.job_id,
                        progress_text: `Step ${payload.current_step}/${payload.total_steps}: ${payload.step_name} (${payload.step_status})`,
                        step_name: payload.step_name,
                        step_type: payload.step_type,
                        current_step: payload.current_step,
                        total_steps: payload.total_steps,
                        step_status: payload.step_status,
                        step_child_count: payload.step_child_count,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // Subscribe to step progress events (from StepMonitor)
            wsUnsubscribers.push(WebSocketManager.subscribe('step_progress', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:updateStepProgress', {
                    detail: {
                        step_id: payload.step_id,
                        manager_id: payload.manager_id,
                        step_name: payload.step_name,
                        status: payload.status,
                        total_jobs: payload.total_jobs || 0,
                        pending_jobs: payload.pending_jobs || 0,
                        running_jobs: payload.running_jobs || 0,
                        completed_jobs: payload.completed_jobs || 0,
                        failed_jobs: payload.failed_jobs || 0,
                        cancelled_jobs: payload.cancelled_jobs || 0,
                        progress_text: payload.progress_text,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // NOTE: refresh_logs and refresh_step_events subscriptions REMOVED
            // SSE streaming replaces WebSocket signal-then-fetch pattern
            // Logs are now streamed directly via /api/logs/stream endpoint

            // Subscribe to manager progress events (from ManagerMonitor)
            wsUnsubscribers.push(WebSocketManager.subscribe('manager_progress', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:updateManagerProgress', {
                    detail: {
                        manager_id: payload.manager_id,
                        job_name: payload.job_name,
                        status: payload.status,
                        total_steps: payload.total_steps || 0,
                        completed_steps: payload.completed_steps || 0,
                        running_steps: payload.running_steps || 0,
                        pending_steps: payload.pending_steps || 0,
                        total_jobs: payload.total_jobs || 0,
                        completed_jobs: payload.completed_jobs || 0,
                        failed_jobs: payload.failed_jobs || 0,
                        document_count: payload.document_count || 0,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // Subscribe to job spawn events
            wsUnsubscribers.push(WebSocketManager.subscribe('job_spawn', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:childSpawned', {
                    detail: {
                        parent_job_id: payload.parent_job_id,
                        child_job_id: payload.child_job_id,
                        job_type: payload.job_type,
                        url: payload.url,
                        depth: payload.depth,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // Subscribe to job_update events (unified job/step status updates)
            // This is the primary mechanism for real-time step status updates
            // Logs are streamed via SSE, not fetched on job_update
            wsUnsubscribers.push(WebSocketManager.subscribe('job_update', (payload) => {
                window.dispatchEvent(new CustomEvent('jobList:jobUpdate', {
                    detail: {
                        context: payload.context,
                        job_id: payload.job_id,
                        step_name: payload.step_name,
                        status: payload.status,
                        timestamp: payload.timestamp
                    }
                }));
            }));

            // NOTE: Logs are streamed via SSE endpoint /api/logs/stream
            // Each expanded job connects to SSE and receives real-time log updates
            // No more signal-then-fetch pattern via WebSocket

            console.log('[Queue] Subscribed to', wsUnsubscribers.length, 'WebSocket message types');
        }

        // Render jobs - dispatches event to Alpine component
        function renderJobs() {
            window.dispatchEvent(new CustomEvent('jobList:render'));
        }

        // Custom pagination rendering - reads state from Alpine component
        function renderPagination(totalPages, currentPage) {
            const container = document.getElementById('job-pagination-container');
            if (!container) return;

            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let html = '<ul class="pagination">';

            // Previous button
            if (currentPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage - 1})">Previous</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Previous</a></li>';
            }

            // Page numbers (show max 7 pages)
            const maxVisible = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
            let endPage = Math.min(totalPages, startPage + maxVisible - 1);

            if (endPage - startPage < maxVisible - 1) {
                startPage = Math.max(1, endPage - maxVisible + 1);
            }

            if (startPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(1)">1</a></li>`;
                if (startPage > 2) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
            }

            for (let i = startPage; i <= endPage; i++) {
                if (i === currentPage) {
                    html += `<li class="page-item active"><a href="#">${i}</a></li>`;
                } else {
                    html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${i})">${i}</a></li>`;
                }
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${totalPages})">${totalPages}</a></li>`;
            }

            // Next button
            if (currentPage < totalPages) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage + 1})">Next</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Next</a></li>';
            }

            html += '</ul>';
            container.innerHTML = html;
        }

        // Pagination page change handler - dispatches event to Alpine component
        function changePage(pageNumber) {
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: pageNumber }
            }));
        }

        // Rerun a job
        async function rerunJob(jobId, evt) {
            if (!confirm(`Copy and queue job ${jobId.substring(0, 8)}?\n\nThis will create a NEW job (copy) with the same configuration and add it to the queue.\nThe job will NOT execute immediately - it will be queued as "pending".\nThe original job will remain unchanged.`)) {
                return;
            }

            // Get button reference from event
            const button = evt.target.closest('button');

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/rerun`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to rerun job');
                }

                const result = await response.json();
                const newJobIdShort = result.new_job_id.substring(0, 8);

                // Show clear notification about the NEW job queued
                window.showNotification(
                    `Job copied and added to queue!\n` +
                    `Original: ${jobId.substring(0, 8)}... (unchanged)\n` +
                    `New Job: ${newJobIdShort}... (pending in queue)`,
                    'success'
                );

                // Refresh stats immediately
                loadStats();

                // Wait a moment for the new job to be inserted, then refresh and highlight
                setTimeout(async () => {
                    await loadJobs();

                    // Try to find and highlight the new job row
                    const newJobRow = document.querySelector(`td[title="${result.new_job_id}"]`)?.closest('tr');
                    if (newJobRow) {
                        // Briefly highlight the new job with animation
                        newJobRow.style.backgroundColor = '#48c774';
                        newJobRow.style.transition = 'background-color 2s ease-out';
                        setTimeout(() => {
                            newJobRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }, 500);

            } catch (error) {
                console.error('Error rerunning job:', error);
                window.showNotification('Failed to rerun job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Cancel a running job
        async function cancelJob(jobId, evt) {
            // Use modal confirmation instead of native confirm()
            const confirmed = await window.confirmAction({
                title: 'Cancel Job',
                message: `Are you sure you want to cancel job ${jobId.substring(0, 8)}? The job will be stopped immediately.`,
                confirmText: 'Cancel Job',
                type: 'warning'
            });

            if (!confirmed) {
                return;
            }

            // Get button reference from event
            const button = evt.target.closest('button');

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/cancel`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to cancel job');
                }

                window.showNotification('Job cancelled successfully', 'success');
                loadStats();
                loadJobs(); // Refresh job list to reflect cancelled status
            } catch (error) {
                console.error('Error cancelling job:', error);
                window.showNotification('Failed to cancel job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Delete a job
        async function deleteJob(jobId, evt) {
            // Get button reference from event
            const button = evt.target.closest('button');

            // Idempotency check - prevent double-clicks
            if (button && button.disabled) {
                return;
            }

            // Disable button immediately before confirmation
            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            // Show confirmation dialog
            if (!confirm(`Delete job ${jobId.substring(0, 8)}?\n\nThis will permanently remove the job from the database.`)) {
                // User cancelled - re-enable button
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
                return;
            }

            let deleteSuccess = false;
            try {
                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete job');
                }

                deleteSuccess = true;
                window.showNotification('Job deleted successfully', 'success');

                // Capture job information before removal for cleanup
                const jobIndex = allJobs.findIndex(job => job.id === jobId);
                const deletedJob = jobIndex >= 0 ? allJobs[jobIndex] : null;

                // Remove job from allJobs array
                const allJobsIndex = allJobs.findIndex(job => job.id === jobId);
                if (allJobsIndex >= 0) {
                    allJobs.splice(allJobsIndex, 1);
                }

                // Remove job from filteredJobs array
                const filteredJobsIndex = filteredJobs.findIndex(job => job.id === jobId);
                if (filteredJobsIndex >= 0) {
                    filteredJobs.splice(filteredJobsIndex, 1);
                }

                // Dispatch cleanup event for Alpine component to handle childJobsList/expandedParents
                if (deletedJob) {
                    window.dispatchEvent(new CustomEvent('jobList:deleteCleanup', {
                        detail: { jobId: jobId, parentId: deletedJob.parent_id }
                    }));
                }

                // Re-render without API call
                renderJobs();
                loadStats();
            } catch (error) {
                console.error('Error deleting job:', error);
                window.showNotification('Failed to delete job: ' + error.message, 'error');
            } finally {
                // Only re-enable button if delete failed (on success, button will be removed from DOM)
                if (button && !deleteSuccess) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[Queue] ==================== PAGE LOAD ====================');
            console.log('[Queue] DOMContentLoaded event fired');
            console.log('[Queue] Current URL:', window.location.href);
            console.log('[Queue] Initializing page components...');

            // Load filters from localStorage first
            loadFiltersFromStorage();
            console.log('[Queue] Loaded filters from storage:', activeFilters);

            // Initialize WebSocket connection for real-time job updates
            console.log('[Queue] Initializing WebSocket connection for job updates');
            connectJobsWebSocket();

            // Real-time updates via WebSocket (no polling fallback)
            // - Server pushes job status changes via job_status_change events
            // - Exponential backoff reconnection handles temporary disconnections
            // - Manual page refresh available as ultimate fallback

            renderFilterChips(); // Render initial filter chips
            loadJobs(); // Load initial jobs (page load only - stats loaded by Alpine component)

            // Real-time updates handled by WebSocket (no polling)
            // - Job statistics recalculated from allJobs when job_status_change events arrive
            // - Progress updated via crawler_job_progress events

            // Add ESC key handler for filter modal
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('filter-modal');
                    if (modal && modal.classList.contains('active')) {
                        closeFilterModal();
                    }
                }
            });

            console.log('[Queue] Page initialization complete');
            console.log('[Queue] ====================================================');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            // Unsubscribe from WebSocketManager (connection stays open for other pages)
            if (wsUnsubscribers.length > 0) {
                console.log('[Queue] Unsubscribing from', wsUnsubscribers.length, 'WebSocket subscriptions');
                wsUnsubscribers.forEach(unsub => unsub());
                wsUnsubscribers = [];
            }
        });

        // Ensure Alpine.js is fully initialized
        document.addEventListener('alpine:init', function () {
            console.log('[Queue] Alpine.js initialized');

            // Create global queue state store for shared loading state
            Alpine.store('queueState', {
                isLoading: false,

                // Helper method to set loading state
                setLoading(value) {
                    console.log('[Queue] Store setLoading called:', value);
                    this.isLoading = Boolean(value);
                }
            });
            console.log('[Queue] Alpine store initialized:', Alpine.store('queueState'));

            // Register queueStatsHeader component
            // Note: WebSocket connection is now handled by the main job WebSocket (connectJobsWebSocket)
            // to avoid duplicate connections. Queue stats are forwarded from the main WebSocket.
            Alpine.data('queueStatsHeader', () => ({
                pending: 0,
                inFlight: 0,
                workers: 0,
                connected: false,
                reconnecting: false,

                init() {
                    // Store reference to handler to prevent accumulation on re-initialization
                    this.queueStatsUpdateHandler = (e) => {
                        console.log('[Queue] queueStatsHeader received queueStats:update', e.detail);
                        if (e.detail) {
                            this.pending = Number(e.detail.pending) || 0;
                            this.inFlight = Number(e.detail.inFlight) || 0;
                            this.workers = Number(e.detail.workers) || 0;
                            this.connected = e.detail.connected !== undefined ? Boolean(e.detail.connected) : true;
                            this.reconnecting = e.detail.reconnecting !== undefined ? Boolean(e.detail.reconnecting) : false;
                        } else {
                            console.warn('[Queue] Received malformed queueStats:update event:', e);
                        }
                    };

                    // Guard against double-registration
                    if (this.queueStatsUpdateHandler) {
                        window.removeEventListener('queueStats:update', this.queueStatsUpdateHandler);
                    }

                    // Add event listeners for external updates
                    window.addEventListener('queueStats:update', this.queueStatsUpdateHandler);

                    // Cleanup on component destroy to prevent listener accumulation
                    this.$watch('$el', (el) => {
                        if (!el && this.queueStatsUpdateHandler) {
                            window.removeEventListener('queueStats:update', this.queueStatsUpdateHandler);
                            this.queueStatsUpdateHandler = null;
                        }
                    });

                    // Load initial stats from API
                    this.loadStats();
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/jobs/queue');
                        if (response.ok) {
                            const data = await response.json();
                            this.pending = data.pending_messages || 0;
                            this.inFlight = data.in_flight_messages || 0;
                            this.workers = data.concurrency || 0;
                            this.connected = true;
                        } else {
                            this.connected = false;
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading queue stats:', error);
                        this.connected = false;
                    }
                }
            }));

            // Register jobStatsHeader component (job counts, not queue stats)
            Alpine.data('jobStatsHeader', () => ({
                totalJobs: 0,
                pendingJobs: 0,
                runningJobs: 0,
                completedJobs: 0,
                failedJobs: 0,
                cancelledJobs: 0,

                init() {
                    // Listen for stats updates from WebSocket events
                    this.jobStatsUpdateHandler = (e) => {
                        if (e.detail) {
                            this.totalJobs = e.detail.total_jobs || 0;
                            this.pendingJobs = e.detail.pending_jobs || 0;
                            this.runningJobs = e.detail.running_jobs || 0;
                            this.completedJobs = e.detail.completed_jobs || 0;
                            this.failedJobs = e.detail.failed_jobs || 0;
                            this.cancelledJobs = e.detail.cancelled_jobs || 0;
                        }
                    };

                    // Listen for server restart events - reload stats from fresh server
                    this.serverRestartHandler = () => {
                        console.log('[JobStatsHeader] Server restart detected - reloading stats');
                        this.loadStats();
                    };

                    // Guard against double-registration
                    if (this.jobStatsUpdateHandler) {
                        window.removeEventListener('jobStats:update', this.jobStatsUpdateHandler);
                    }
                    if (this.serverRestartHandler) {
                        window.removeEventListener('jobList:serverRestart', this.serverRestartHandler);
                    }

                    window.addEventListener('jobStats:update', this.jobStatsUpdateHandler);
                    window.addEventListener('jobList:serverRestart', this.serverRestartHandler);

                    // Cleanup on component destroy
                    this.$watch('$el', (el) => {
                        if (!el && this.jobStatsUpdateHandler) {
                            window.removeEventListener('jobStats:update', this.jobStatsUpdateHandler);
                            this.jobStatsUpdateHandler = null;
                        }
                        if (!el && this.serverRestartHandler) {
                            window.removeEventListener('jobList:serverRestart', this.serverRestartHandler);
                            this.serverRestartHandler = null;
                        }
                    });

                    // Load initial stats from API (page load only)
                    this.loadStats();
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/jobs/stats');
                        if (response.ok) {
                            const stats = await response.json();
                            this.totalJobs = stats.total_jobs || 0;
                            this.pendingJobs = stats.pending_jobs || 0;
                            this.runningJobs = stats.running_jobs || 0;
                            this.completedJobs = stats.completed_jobs || 0;
                            this.failedJobs = stats.failed_jobs || 0;
                            this.cancelledJobs = stats.cancelled_jobs || 0;
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading job stats:', error);
                    }
                }
            }));

            // Register jobList component
            Alpine.data('jobList', () => ({
                // State management
                allJobs: [],
                filteredJobs: [],
                _loadSeq: 0,
                selectedJob: null,
                selectedJobIds: new Set(),
                isDeletingJobs: false,
                deletionProgress: { current: 0, total: 0 },
                currentPage: 1,
                totalJobs: 0,
                pageSize: 50,

                // Tree view state (New)
                jobTreeData: {},
                jobTreeLoading: {},
                jobTreeExpandedSteps: {},
                jobTreeSearchFilter: {},
                treeLogLevelFilter: {},  // Per-job log level filter for tree view (all/warn/error)
                stepLevelFilters: {},    // Per-step checkbox-based level filters: { "jobId:stepName": { debug: true, info: true, warn: true, error: true } }
                stepFilterDropdownOpen: {},  // Track dropdown open state for testing: { "jobId:stepName": true/false }
                collapsedJobs: {}, // Track collapsed state of parent jobs (default expanded)
                _pendingStepExpansions: {}, // Queue step expansions that arrive before tree data loads

                // Logs
                itemsToRender: [],
                expandedStepLogs: {},
                jobLogs: {}, // Stores logs for all jobs (legacy + tree support)

                // SSE streaming state
                jobSSEConnected: {}, // Track SSE connection status per job

                // Loading state
                isLoading: false,
                loadError: null,
                lastSuccessfulJobs: [],
                currentFetchController: null,
                retryCount: 0,
                maxRetries: 3,
                isInitialLoad: true,
                pendingUpdates: [],
                pendingUpdatesMaxSize: 1000,

                // Throttled rendering
                _renderPending: false,
                _renderTimeout: null,
                _renderThrottleMs: 100,

                // Stats debouncing
                _statsTimeout: null,
                _statsDebounceMs: 2000,

                // Step log fetch debouncing - prevents API flooding
                _stepFetchDebounceTimers: {},  // key: jobId:stepName, value: timer ID
                _stepFetchInFlight: new Set(), // tracks currently fetching steps
                _stepFetchPromises: {},        // key: jobId:stepName, value: in-flight Promise
                _stepFetchDebounceMs: 1000,    // 1 second debounce per user request


                init() {
                    // Initialize timeouts map for debounced parent refreshes
                    this.parentRefreshTimeouts = new Map();

                    // Store reference to 'this' for use in global handlers
                    const self = this;

                    // Expose global function for loading earlier logs
                    // This enables programmatic clicks from tests to work correctly
                    window.loadEarlierLogs = async (jobId, stepName, stepIndex) => {
                        if (jobId && stepName !== undefined && !isNaN(stepIndex)) {
                            console.log('[Queue] loadEarlierLogs called:', jobId.substring(0, 8), stepName, stepIndex);
                            await self.loadMoreStepLogs(jobId, stepName, stepIndex);
                        }
                    };

                    // Add event listeners for external commands
                    window.addEventListener('jobList:load', () => this.loadJobs());
                    window.addEventListener('jobList:render', () => this.renderJobs());
                    window.addEventListener('jobList:updateJob', (e) => this.updateJobInList(e.detail));
                    // NOTE: jobLog and handleRefreshStepEvents listeners REMOVED - architecture uses trigger-based approach via refreshStepEvents() (line ~2022)
                    // See QUEUE_LOGGING.md: "WebSocket events trigger incremental fetch"
                    // Handle child job spawn events - fetch children when new children are created
                    window.addEventListener('jobList:childSpawned', (e) => {
                        const { parent_job_id, child_job_id } = e.detail;
                        console.log('[Queue] Child job spawned:', child_job_id?.substring(0, 8), 'for parent:', parent_job_id?.substring(0, 8));
                        if (parent_job_id) {
                            this.debouncedFetchChildren(parent_job_id);
                        }
                    });
                    window.addEventListener('jobList:changePage', (e) => {
                        this.currentPage = e.detail.page;
                        this.loadJobs();
                    });
                    window.addEventListener('jobList:deleteSelected', () => this.deleteSelectedJobs());
                    window.addEventListener('jobList:deleteCleanup', (e) => this.handleDeleteCleanup(e.detail));

                    // WebSocket real-time updates
                    window.addEventListener('jobList:recalculateStats', () => this.recalculateStats());
                    window.addEventListener('jobList:updateJobProgress', (e) => this.updateJobProgress(e.detail));
                    // NOTE: Logs now streamed via SSE - no more WebSocket log events
                    // Step hierarchy progress updates
                    window.addEventListener('jobList:updateStepProgress', (e) => this.updateStepProgress(e.detail));
                    window.addEventListener('jobList:updateManagerProgress', (e) => this.updateManagerProgress(e.detail));
                    // NOTE: refreshStepEvents listener REMOVED - SSE streaming replaces trigger-based fetching
                    // Unified job/step status updates (primary mechanism for step status)
                    window.addEventListener('jobList:jobUpdate', (e) => this.handleJobUpdate(e.detail));

                    // Server restart handler - clear all job state to avoid stale requests
                    window.addEventListener('jobList:serverRestart', () => this.handleServerRestart());

                    // Set initial load flag
                    this.isInitialLoad = true;

                    // Track in-flight child fetch requests to prevent duplicates
                    this._childFetchInFlight = new Set();

                    // Periodically refresh children for RUNNING parents with missing children
                    // This ensures child rows are displayed even if job_spawn events aren't received
                    // Only fetches if: parent is running/pending, children missing, no fetch in progress
                    this._childRefreshInterval = setInterval(() => {
                        // Only check parents that are still active (not completed/failed/cancelled)
                        const activeStatuses = ['pending', 'running'];
                        const activeParentsWithChildren = this.filteredJobs.filter(job =>
                            !job.parent_id &&
                            job.child_count > 0 &&
                            activeStatuses.includes(job.status)
                        );
                        activeParentsWithChildren.forEach(parent => {
                            // Skip if already fetching this parent
                            if (this._childFetchInFlight.has(parent.id)) {
                                return;
                            }
                            // Check if we have all children in allJobs
                            const childrenInAllJobs = this.allJobs.filter(j => j.parent_id === parent.id).length;
                            if (childrenInAllJobs < parent.child_count) {
                                console.log('[Queue] Refreshing children for parent', parent.id.substring(0, 8), '- have', childrenInAllJobs, 'of', parent.child_count);
                                this._childFetchInFlight.add(parent.id);
                                this.fetchChildrenForParent(parent.id).finally(() => {
                                    this._childFetchInFlight.delete(parent.id);
                                });
                            }
                        });
                    }, 2000); // Check every 2 seconds

                    // Cleanup on component destroy
                    this.$watch('$el', (el) => {
                        if (!el) {
                            if (this.currentFetchController) {
                                this.currentFetchController.abort();
                            }
                            if (this._childRefreshInterval) {
                                clearInterval(this._childRefreshInterval);
                            }
                        }
                    });

                    // Wait for DOM to be ready then initialize
                    this.loadJobs();
                },

                // NOTE: handleChildSpawned() method removed - expand/collapse functionality was removed in queue-ui-improvements
                // Child job tracking is now done server-side via WebSocket updates to parent job child_count

                // NOTE: handleChildJobStatus() method removed - expand/collapse functionality was removed in queue-ui-improvements
                // Child job status tracking is now done server-side via WebSocket updates to parent job statistics

                handleDeleteCleanup(deleteData) {
                    // NOTE: Simplified - expand/collapse state cleanup removed (functionality was removed in queue-ui-improvements)
                    // Server-side job deletion now handles all cleanup including child job relationships
                    // This method is kept for compatibility with delete event handling

                    // Trigger render to reflect deletion
                    this.renderJobs();
                },

                retryLoadJobs() {
                    // Reset retry count and trigger load
                    this.retryCount = 0;
                    this.loadJobs();
                },

                // Toggle visibility of step logs
                toggleStepLogsExpand(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    const newState = !this.expandedStepLogs[key];
                    this.expandedStepLogs = { ...this.expandedStepLogs, [key]: newState };
                },



                isStepLogsExpanded(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return !!this.expandedStepLogs[key];
                },

                // Get logs for a specific step (used in Flat view and legacy compatibility)
                getStepLogs(jobId, stepName) {
                    // Try to get from Tree data first (preferred)
                    if (this.jobTreeData[jobId] && this.jobTreeData[jobId].steps) {
                        const step = this.jobTreeData[jobId].steps.find(s => s.name === stepName);
                        if (step && step.logs) {
                            return this.filterLogsByLevels(step.logs, jobId, stepName);
                        }
                    }

                    // Fallback to jobLogs (legacy/flat view support)
                    if (this.jobLogs[jobId]) {
                        const logs = this.jobLogs[jobId].filter(l => l.step_name === stepName);
                        return this.filterLogsByLevels(logs, jobId, stepName);
                    }

                    return [];
                },

                getStepLogsTotal(jobId, stepName) {
                    // Try Tree data first - use totalLogCount if available (from API)
                    if (this.jobTreeData[jobId] && this.jobTreeData[jobId].steps) {
                        const step = this.jobTreeData[jobId].steps.find(s => s.name === stepName);
                        if (step) {
                            // Prefer totalLogCount from API, fallback to logs array length
                            return step.totalLogCount || (step.logs ? step.logs.length : 0);
                        }
                    }
                    // Fallback
                    if (this.jobLogs[jobId]) {
                        return this.jobLogs[jobId].filter(l => l.step_name === stepName).length;
                    }
                    return 0;
                },

                // Filter logs helper
                filterLogs(logs, filter) {
                    if (!logs) return [];
                    if (!filter || filter === 'all') return logs;
                    if (filter === 'error') return logs.filter(l => l.level === 'error' || l.level === 'fatal');
                    if (filter === 'warn') return logs.filter(l => ['warn', 'error', 'fatal'].includes(l.level));
                    return logs;
                },

                getStepEventFilter(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this.jobTreeSearchFilter[key] || 'all';
                },

                setStepEventFilter(jobId, stepName, filter) {
                    console.log('Set filter', filter, 'for', stepName);
                },

                // Default step level filter: Info, Warn, Error enabled; Debug disabled
                getDefaultStepLevelFilter() {
                    return { debug: false, info: true, warn: true, error: true };
                },

                // Checkbox-based level filter functions
                getStepLevelFilters(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this.stepLevelFilters[key] || this.getDefaultStepLevelFilter();
                },

                isLevelSelected(jobId, stepName, level) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    return filters[level] !== false;
                },

                isAllLevelsSelected(jobId, stepName) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    return filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false;
                },

                toggleLevelFilter(jobId, stepName, level) {
                    const key = `${jobId}:${stepName}`;
                    const currentFilters = this.getStepLevelFilters(jobId, stepName);
                    this.stepLevelFilters[key] = {
                        ...currentFilters,
                        [level]: !currentFilters[level]
                    };
                    console.log('Toggle level filter', level, 'for', stepName, '-> new state:', this.stepLevelFilters[key]);

                    // Fetch logs with updated level filter from API
                    this.fetchStepLogsWithLevelFilter(jobId, stepName);
                },

                // Convert stepLevelFilters to API level parameter
                getStepLevelFilterApiParam(jobId, stepName) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    // If all are checked, return 'all'
                    if (filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return 'all';
                    }
                    // If only error is checked
                    if (filters.debug === false && filters.info === false && filters.warn === false && filters.error !== false) {
                        return 'error';
                    }
                    // If warn and error are checked (warn+)
                    if (filters.debug === false && filters.info === false && filters.warn !== false && filters.error !== false) {
                        return 'warn';
                    }
                    // If info, warn, error are checked (info+)
                    if (filters.debug === false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return 'info';
                    }
                    // Mixed selection - return 'all' and filter client-side
                    return 'all';
                },

                // Fetch step logs with current level filter applied
                async fetchStepLogsWithLevelFilter(jobId, stepName) {
                    // Find the step job ID from metadata
                    const job = this.allJobs.find(j => j.id === jobId);
                    const stepJobId = job?.metadata?.step_job_ids?.[stepName];

                    if (!stepJobId) {
                        console.warn('[Queue] No step job ID found for', stepName);
                        return;
                    }

                    const level = this.getStepLevelFilterApiParam(jobId, stepName);
                    console.log('[Queue] Fetching logs for step', stepName, 'with level filter:', level);

                    try {
                        const response = await fetch(`/api/logs?scope=job&job_id=${stepJobId}&include_children=true&limit=200&order=desc&level=${encodeURIComponent(level)}`);
                        if (!response.ok) {
                            console.warn('[Queue] Failed to fetch logs with level filter:', response.status);
                            return;
                        }

                        const data = await response.json();
                        let newLogs = data.logs || [];
                        const totalCount = data.total_count || newLogs.length;

                        // Reverse to get chronological order (we fetched desc, display asc)
                        newLogs = newLogs.reverse();

                        // Update jobLogs for step panel
                        if (!this.jobLogs[jobId]) {
                            this.jobLogs[jobId] = [];
                        }
                        this.jobLogs[jobId] = this.jobLogs[jobId].filter(l => l.step_name !== stepName);
                        const logsWithStepName = newLogs.map(log => ({ ...log, step_name: stepName }));
                        this.jobLogs[jobId].push(...logsWithStepName);

                        // Also update jobTreeData if available
                        if (this.jobTreeData[jobId]?.steps) {
                            const stepIdx = this.jobTreeData[jobId].steps.findIndex(s => s.name === stepName);
                            if (stepIdx >= 0) {
                                const newSteps = [...this.jobTreeData[jobId].steps];
                                newSteps[stepIdx] = {
                                    ...newSteps[stepIdx],
                                    logs: newLogs,
                                    totalLogCount: totalCount
                                };
                                this.jobTreeData = {
                                    ...this.jobTreeData,
                                    [jobId]: { ...this.jobTreeData[jobId], steps: newSteps }
                                };
                            }
                        }

                        console.log('[Queue] Loaded', newLogs.length, 'logs for step', stepName, 'with level filter:', level);
                    } catch (err) {
                        console.error('[Queue] Error fetching logs with level filter:', err);
                    }
                },

                // Filter logs using checkbox-based level selection
                filterLogsByLevels(logs, jobId, stepName) {
                    if (!logs) return [];
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    // If all are selected, return all logs
                    if (filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return logs;
                    }
                    // Filter by selected levels
                    return logs.filter(log => {
                        const level = this.normalizeLogLevel(log.level);
                        return filters[level] !== false;
                    });
                },

                // Get logs for a specific step (used in Flat view and legacy compatibility)
                getStepLogs(jobId, stepName) {
                    // Try to get from Tree data first (preferred)
                    if (this.jobTreeData[jobId] && this.jobTreeData[jobId].steps) {
                        const step = this.jobTreeData[jobId].steps.find(s => s.name === stepName);
                        if (step && step.logs) {
                            return this.filterLogsByLevels(step.logs, jobId, stepName);
                        }
                    }

                    // Fallback to jobLogs (legacy/flat view support)
                    if (this.jobLogs[jobId]) {
                        const logs = this.jobLogs[jobId].filter(l => l.step_name === stepName);
                        return this.filterLogsByLevels(logs, jobId, stepName);
                    }

                    return [];
                },

                getStepLogsTotal(jobId, stepName) {
                    // Try Tree data first - use totalLogCount if available (from API)
                    if (this.jobTreeData[jobId] && this.jobTreeData[jobId].steps) {
                        const step = this.jobTreeData[jobId].steps.find(s => s.name === stepName);
                        if (step) {
                            // Prefer totalLogCount from API, fallback to logs array length
                            return step.totalLogCount || (step.logs ? step.logs.length : 0);
                        }
                    }
                    // Fallback
                    if (this.jobLogs[jobId]) {
                        return this.jobLogs[jobId].filter(l => l.step_name === stepName).length;
                    }
                    return 0;
                },

                // Filter logs helper
                filterLogs(logs, filter) {
                    if (!logs) return [];
                    if (!filter || filter === 'all') return logs;
                    if (filter === 'error') return logs.filter(l => l.level === 'error' || l.level === 'fatal');
                    if (filter === 'warn') return logs.filter(l => ['warn', 'error', 'fatal'].includes(l.level));
                    return logs;
                },

                getStepEventFilter(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this.jobTreeSearchFilter[key] || 'all'; // Reusing search filter object for drop-down filter if separate state not desired, or use dedicated map
                    // Actually, let's use a dedicated map or just default to 'all' if we don't have one
                    // For now, defaulting to 'all' is safe.
                    // If we want per-step filtering persistence, we need `stepLogFilters` state.
                    return 'all';
                },

                setStepEventFilter(jobId, stepName, filter) {
                    // Placeholder: Implement state if needed.
                    // For now, this satisfies the template call.
                    console.log('Set filter', filter, 'for', stepName);
                },

                // Default step level filter: Info, Warn, Error enabled; Debug disabled (duplicate for second Alpine scope)
                getDefaultStepLevelFilter() {
                    return { debug: false, info: true, warn: true, error: true };
                },

                // Checkbox-based level filter functions (duplicate for second Alpine scope)
                getStepLevelFilters(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this.stepLevelFilters[key] || this.getDefaultStepLevelFilter();
                },

                isLevelSelected(jobId, stepName, level) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    return filters[level] !== false;
                },

                isAllLevelsSelected(jobId, stepName) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    return filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false;
                },

                toggleLevelFilter(jobId, stepName, level) {
                    const key = `${jobId}:${stepName}`;
                    const currentFilters = this.getStepLevelFilters(jobId, stepName);
                    this.stepLevelFilters[key] = {
                        ...currentFilters,
                        [level]: !currentFilters[level]
                    };
                    console.log('Toggle level filter', level, 'for', stepName, '-> new state:', this.stepLevelFilters[key]);

                    // Fetch logs with updated level filter from API
                    this.fetchStepLogsWithLevelFilter(jobId, stepName);
                },

                // Convert stepLevelFilters to API level parameter (duplicate for second Alpine scope)
                getStepLevelFilterApiParam(jobId, stepName) {
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    // If all are checked, return 'all'
                    if (filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return 'all';
                    }
                    // If only error is checked
                    if (filters.debug === false && filters.info === false && filters.warn === false && filters.error !== false) {
                        return 'error';
                    }
                    // If warn and error are checked (warn+)
                    if (filters.debug === false && filters.info === false && filters.warn !== false && filters.error !== false) {
                        return 'warn';
                    }
                    // If info, warn, error are checked (info+)
                    if (filters.debug === false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return 'info';
                    }
                    // Mixed selection - return 'all' and filter client-side
                    return 'all';
                },

                // Fetch step logs with current level filter applied (duplicate for second Alpine scope)
                async fetchStepLogsWithLevelFilter(jobId, stepName) {
                    // Find the step job ID from metadata
                    const job = this.allJobs.find(j => j.id === jobId);
                    const stepJobId = job?.metadata?.step_job_ids?.[stepName];

                    if (!stepJobId) {
                        console.warn('[Queue] No step job ID found for', stepName);
                        return;
                    }

                    const level = this.getStepLevelFilterApiParam(jobId, stepName);
                    console.log('[Queue] Fetching logs for step', stepName, 'with level filter:', level);

                    try {
                        const response = await fetch(`/api/logs?scope=job&job_id=${stepJobId}&include_children=true&limit=200&order=desc&level=${encodeURIComponent(level)}`);
                        if (!response.ok) {
                            console.warn('[Queue] Failed to fetch logs with level filter:', response.status);
                            return;
                        }

                        const data = await response.json();
                        let newLogs = data.logs || [];
                        const totalCount = data.total_count || newLogs.length;

                        // Reverse to get chronological order (we fetched desc, display asc)
                        newLogs = newLogs.reverse();

                        // Update jobLogs for step panel
                        if (!this.jobLogs[jobId]) {
                            this.jobLogs[jobId] = [];
                        }
                        this.jobLogs[jobId] = this.jobLogs[jobId].filter(l => l.step_name !== stepName);
                        const logsWithStepName = newLogs.map(log => ({ ...log, step_name: stepName }));
                        this.jobLogs[jobId].push(...logsWithStepName);

                        // Also update jobTreeData if available
                        if (this.jobTreeData[jobId]?.steps) {
                            const stepIdx = this.jobTreeData[jobId].steps.findIndex(s => s.name === stepName);
                            if (stepIdx >= 0) {
                                const newSteps = [...this.jobTreeData[jobId].steps];
                                newSteps[stepIdx] = {
                                    ...newSteps[stepIdx],
                                    logs: newLogs,
                                    totalLogCount: totalCount
                                };
                                this.jobTreeData = {
                                    ...this.jobTreeData,
                                    [jobId]: { ...this.jobTreeData[jobId], steps: newSteps }
                                };
                            }
                        }

                        console.log('[Queue] Loaded', newLogs.length, 'logs for step', stepName, 'with level filter:', level);
                    } catch (err) {
                        console.error('[Queue] Error fetching logs with level filter:', err);
                    }
                },

                // Filter logs using checkbox-based level selection (duplicate for second Alpine scope)
                filterLogsByLevels(logs, jobId, stepName) {
                    if (!logs) return [];
                    const filters = this.getStepLevelFilters(jobId, stepName);
                    // If all are selected, return all logs
                    if (filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false) {
                        return logs;
                    }
                    // Filter by selected levels
                    return logs.filter(log => {
                        const level = this.normalizeLogLevel(log.level);
                        return filters[level] !== false;
                    });
                },

                getLogLevelClass(level) {
                    // Color classes matching Service Logs panel styling
                    switch (this.normalizeLogLevel(level)) {
                        case 'error': return 'log-level-error';
                        case 'warn': return 'log-level-warn';
                        case 'debug': return 'log-level-debug';
                        default: return 'log-level-info';
                    }
                },

                normalizeLogLevel(level) {
                    const v = (level || '').toString().trim().toLowerCase();
                    // Accept both word and 3-letter formats from the API/storage.
                    if (v === 'err') return 'error';
                    if (v === 'wrn') return 'warn';
                    if (v === 'inf') return 'info';
                    if (v === 'dbg') return 'debug';
                    if (v === 'fatal' || v === 'panic') return 'error';
                    return v || 'info';
                },

                getLogLevelTag(level) {
                    // Text-based level tags matching standard log format
                    switch (this.normalizeLogLevel(level)) {
                        case 'error': return '[ERR]';
                        case 'warn': return '[WRN]';
                        case 'debug': return '[DBG]';
                        default: return '[INF]';
                    }
                },

                getTerminalLevelClass(level) {
                    // Terminal color classes matching Service Logs panel styling
                    switch (this.normalizeLogLevel(level)) {
                        case 'error': return 'terminal-error';
                        case 'warn': return 'terminal-warning';
                        case 'debug': return 'terminal-debug';
                        default: return 'terminal-info';
                    }
                },

                getLogLevelIcon(level) {
                    // Deprecated: kept for backwards compatibility
                    switch (level) {
                        case 'error': return 'fa-times-circle';
                        case 'warn': return 'fa-exclamation-triangle';
                        case 'debug': return 'fa-bug';
                        default: return 'fa-info-circle';
                    }
                },

                formatLogTime(timestamp) {
                    if (!timestamp) return '';
                    try {
                        const date = new Date(timestamp);
                        // Include milliseconds for ordering visibility in fast jobs
                        const hours = String(date.getHours()).padStart(2, '0');
                        const mins = String(date.getMinutes()).padStart(2, '0');
                        const secs = String(date.getSeconds()).padStart(2, '0');
                        const ms = String(date.getMilliseconds()).padStart(3, '0');
                        return `${hours}:${mins}:${secs}.${ms}`;
                    } catch {
                        return '';
                    }
                },

                // Load events for completed steps on page load
                // This ensures steps that completed before WebSocket triggers fired still show their events
                async loadCompletedStepEvents() {
                    // Find all manager jobs (parents with step_job_ids) that are completed/failed/cancelled
                    const completedStatuses = ['completed', 'failed', 'cancelled'];
                    const managerJobs = this.allJobs.filter(job =>
                        !job.parent_id &&
                        job.metadata?.step_job_ids &&
                        completedStatuses.includes(job.status)
                    );

                    console.log('[Queue] loadCompletedStepEvents: Found', managerJobs.length, 'completed manager jobs with steps');

                    const promises = [];

                    for (const manager of managerJobs) {
                        const stepJobIds = manager.metadata.step_job_ids || {};

                        for (const [stepName, stepJobId] of Object.entries(stepJobIds)) {
                            // Check if we already have events for this step
                            const existingLogs = this.jobLogs[manager.id] || [];
                            const stepLogs = existingLogs.filter(l => l.step_name === stepName);

                            if (stepLogs.length === 0) {
                                // No events cached - fetch from API
                                console.log('[Queue] Will fetch events for step', stepName, 'in manager', manager.id.substring(0, 8));
                                promises.push(this.fetchStepEventsById(manager.id, stepName, stepJobId));
                            }
                        }
                    }

                    if (promises.length > 0) {
                        console.log('[Queue] Loading events for', promises.length, 'completed steps');
                        await Promise.all(promises);
                    }
                },

                // Fetch step events by step job ID (for completed steps on page load)
                async fetchStepEventsById(managerId, stepName, stepJobId) {
                    // Initialize in-flight tracking
                    if (!this._stepEventFetchInFlight) {
                        this._stepEventFetchInFlight = new Set();
                    }

                    // Skip if already fetching this step's events
                    if (this._stepEventFetchInFlight.has(stepJobId)) {
                        console.log('[Queue] Skipping fetch for step', stepJobId.substring(0, 8), '- already in flight');
                        return;
                    }
                    this._stepEventFetchInFlight.add(stepJobId);

                    try {
                        // Use unified /api/logs endpoint with include_children=true to include worker logs
                        console.log('[Queue] Fetching events for completed step', stepName, 'job:', stepJobId.substring(0, 8));
                        const level = this.getTreeLogLevelFilter(managerId);
                        const response = await fetch(`/api/logs?scope=job&job_id=${stepJobId}&include_children=true&limit=100&order=asc&level=${encodeURIComponent(level)}`);
                        if (!response.ok) {
                            console.warn('[Queue] Failed to fetch events for step', stepJobId.substring(0, 8), response.status);
                            return;
                        }

                        const data = await response.json();
                        const logs = data.logs || [];

                        // Store in jobLogs for getStepLogs to find
                        if (!this.jobLogs[managerId]) {
                            this.jobLogs[managerId] = [];
                        }
                        // Remove old logs for this step and add new ones
                        this.jobLogs[managerId] = this.jobLogs[managerId].filter(l => l.step_name !== stepName);
                        const logsWithStepName = logs.map(log => ({ ...log, step_name: stepName }));
                        this.jobLogs[managerId].push(...logsWithStepName);

                        console.log('[Queue] Loaded', logs.length, 'events for completed step', stepName);
                    } catch (err) {
                        console.warn('[Queue] Error fetching events for step', stepName, ':', err);
                    } finally {
                        // Remove from in-flight set when done
                        this._stepEventFetchInFlight.delete(stepJobId);
                    }
                },

                // Fetch historical logs for a parent job from the API
                // Uses unified /api/logs endpoint to get logs from all child jobs (steps and workers)
                async fetchHistoricalLogs(jobId) {
                    try {
                        // Use unified /api/logs endpoint with include_children=true to get logs from manager and all children
                        // This ensures step logs are available after page refresh
                        const response = await fetch(`/api/logs?scope=job&job_id=${jobId}&include_children=true&order=asc`);
                        if (!response.ok) {
                            console.warn('[Queue] Failed to fetch logs for job', jobId.substring(0, 8));
                            return;
                        }
                        const data = await response.json();
                        const logs = data.logs || [];

                        if (logs.length === 0) return;

                        // Convert API logs to internal format and merge with existing logs
                        const existingLogs = this.jobLogs[jobId] || [];
                        const existingTimestamps = new Set(existingLogs.map(l => l.timestamp));

                        const newLogs = logs
                            .filter(log => !existingTimestamps.has(log.full_timestamp))
                            .map(log => ({
                                level: log.level || 'info',
                                message: log.message || '',
                                timestamp: log.full_timestamp || log.timestamp,
                                step_name: log.step_name || '',
                                source_type: log.source_type || '',
                                originator: log.originator || '',
                                phase: log.phase || ''
                            }));

                        if (newLogs.length > 0) {
                            this.jobLogs[jobId] = [...existingLogs, ...newLogs];
                            // Trigger reactive update
                            this.jobLogs = { ...this.jobLogs };
                            console.log('[Queue] Loaded', newLogs.length, 'historical logs for job', jobId.substring(0, 8));
                        }
                    } catch (err) {
                        console.warn('[Queue] Error fetching historical logs for job', jobId.substring(0, 8), err);
                    }
                },

                // Fetch historical logs for all parent jobs
                async fetchAllHistoricalLogs(parentJobs) {
                    const promises = parentJobs.map(job => this.fetchHistoricalLogs(job.id));
                    await Promise.all(promises);
                },


                // Clear all job state when server restarts - prevents stale job ID requests
                handleServerRestart() {
                    console.log('[Queue] Handling server restart - clearing all job state');
                    // Disconnect all SSE streams
                    if (typeof QueueSSEManager !== 'undefined') {
                        QueueSSEManager.disconnectAll();
                    }
                    this.jobSSEConnected = {};
                    if (this._pendingStepIds) { this._pendingStepIds.clear(); }
                    if (this._refreshDebounceTimer) { clearTimeout(this._refreshDebounceTimer); this._refreshDebounceTimer = null; }
                    if (this._stepEventFetchInFlight) { this._stepEventFetchInFlight.clear(); }
                    if (this._childFetchInFlight) { this._childFetchInFlight.clear(); }
                    this.allJobs = [];
                    this.filteredJobs = [];
                    this.jobTreeData = {};
                    this.jobTreeExpandedSteps = {};
                    this.jobLogs = {};
                    this.jobLogsLoading = {};
                    this.jobTreeLoading = {};
                    this._pendingStepExpansions = {};
                    this.loadJobs();
                },
                async loadJobs() {
                    console.log('[Queue] loadJobs called at', new Date().toISOString());
                    console.log('[Queue] Setting isLoading to true and updating store, current value:', this.isLoading);
                    console.log('[Queue] Aborting previous request:', this.currentFetchController !== null);
                    console.log('[Queue] Loading page', this.currentPage, 'with filters:', window.activeFilters);

                    // Generate request sequence ID to prevent race conditions from aborted requests
                    const requestId = ++this._loadSeq;
                    console.log('[Queue] Generated request ID:', requestId);

                    try {
                        // Request deduplication - abort previous request if in-flight
                        if (this.currentFetchController) {
                            this.currentFetchController.abort();
                        }

                        // Create new AbortController for this request
                        this.currentFetchController = new AbortController();

                        // Set loading state - don't clear existing data
                        this.isLoading = true;
                        Alpine.store('queueState').setLoading(true);
                        this.loadError = null;

                        // Build query parameters from filters
                        const params = new URLSearchParams();
                        params.append('limit', this.pageSize);
                        params.append('offset', (this.currentPage - 1) * this.pageSize);
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'DESC');

                        // Always fetch parent jobs only
                        params.append('parent_id', 'root');

                        // Build filter parameters from activeFilters state (with safe checks)
                        if (window.activeFilters && window.activeFilters.status && window.activeFilters.status.size > 0) {
                            params.append('status', Array.from(window.activeFilters.status).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.source && window.activeFilters.source.size > 0) {
                            params.append('source', Array.from(window.activeFilters.source).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.entity && window.activeFilters.entity.size > 0) {
                            params.append('entity', Array.from(window.activeFilters.entity).join(','));
                        }

                        const response = await fetch(`/api/jobs?${params.toString()}`, {
                            signal: this.currentFetchController.signal
                        });
                        if (!response.ok) {
                            throw new Error('Failed to fetch jobs');
                        }

                        const data = await response.json();
                        const parentJobs = data.jobs || [];

                        console.log('[Queue] Successfully loaded', parentJobs.length, 'parent jobs, total count:', data.total_count);

                        // Fetch children for all parents that have children
                        const parentsWithChildren = parentJobs.filter(job => job.child_count > 0);
                        console.log('[Queue] Parents with children:', parentsWithChildren.map(p => ({ id: p.id.substring(0, 8), name: p.name, child_count: p.child_count })));
                        let allChildren = [];

                        if (parentsWithChildren.length > 0) {
                            console.log('[Queue] Fetching children for', parentsWithChildren.length, 'parent jobs');

                            // Fetch children for each parent in parallel
                            const childPromises = parentsWithChildren.map(async parent => {
                                try {
                                    const childParams = new URLSearchParams();
                                    childParams.append('parent_id', parent.id);
                                    childParams.append('limit', '500'); // Reasonable limit per parent
                                    childParams.append('order_by', 'created_at');
                                    childParams.append('order_dir', 'ASC'); // Oldest first for execution order

                                    console.log('[Queue] Fetching children for parent:', parent.id.substring(0, 8), 'URL:', `/api/jobs?${childParams.toString()}`);
                                    const childResponse = await fetch(`/api/jobs?${childParams.toString()}`, {
                                        signal: this.currentFetchController.signal
                                    });

                                    if (childResponse.ok) {
                                        const childData = await childResponse.json();
                                        console.log('[Queue] Got', (childData.jobs || []).length, 'children for parent', parent.id.substring(0, 8));
                                        return childData.jobs || [];
                                    }
                                    console.warn('[Queue] Child fetch failed for parent', parent.id.substring(0, 8), 'status:', childResponse.status);
                                    return [];
                                } catch (err) {
                                    console.warn('[Queue] Failed to fetch children for parent', parent.id, err);
                                    return [];
                                }
                            });

                            const childResults = await Promise.all(childPromises);
                            allChildren = childResults.flat();
                            console.log('[Queue] Loaded', allChildren.length, 'total child jobs');
                        }

                        // Combine parents and children
                        const newJobs = [...parentJobs, ...allChildren];
                        console.log('[Queue] Combined jobs: parents=', parentJobs.length, 'children=', allChildren.length, 'total=', newJobs.length);

                        // Update jobs arrays only after successful parse
                        this.allJobs = newJobs;
                        this.totalJobs = data.total_count || 0;
                        this.filteredJobs = [...parentJobs]; // filteredJobs only contains parents for pagination

                        // Store snapshot of successful data
                        this.lastSuccessfulJobs = [...newJobs];

                        // Reset retry count on success
                        this.retryCount = 0;

                        // Auto-expand running parent jobs (one-time on initial load)
                        if (this.isInitialLoad) {
                            parentJobs.forEach(job => {
                                // Default policy: Collapse completed/failed/cancelled, Expand running
                                if (['completed', 'failed', 'cancelled'].includes(job.status)) {
                                    this.collapsedJobs[job.id] = true;
                                } else if (job.status === 'running') {
                                    this.collapsedJobs[job.id] = false;
                                    // Trigger data fetch for running job
                                    this.loadJobTreeData(job.id);
                                }
                            });
                        }

                        this.isInitialLoad = false;
                        console.log('[Queue] Cleared isInitialLoad flag, isLoading will be set to false in finally block');

                        // Apply any pending updates that arrived during fetch
                        if (this.pendingUpdates.length > 0) {
                            console.log('[Queue] Applying', this.pendingUpdates.length, 'pending updates');
                            this.pendingUpdates.forEach(update => this.updateJobInList(update));
                            this.pendingUpdates = [];
                        }

                        this.renderJobs();

                        // Fetch historical logs for parent jobs (async, don't block)
                        this.fetchAllHistoricalLogs(parentJobs).then(() => {
                            // Re-render after logs are fetched to update event counts
                            this.renderJobs();

                            // Auto-expand running parent jobs (one-time on initial load or if user hasn't interacted)
                            if (this.isInitialLoad) {
                                parentJobs.forEach(job => {
                                    if (job.status === 'running' && !this.collapsedJobs[job.id]) {
                                        // Auto-expand if running and not explicitly collapsed
                                        // Note: collapsedJobs tracks *collapsed* state, so undefined/false = expanded? 
                                        // Actually collapsedJobs logic is: !collapsedJobs[id] -> expanded? 
                                        // Wait, isJobStepsCollapsed returns !!collapsedJobs[id]. So true = collapsed.
                                        // Default is NOT collapsed? No, default state is usually collapsed.
                                        // Let's check checks: isJobStepsCollapsed returns true if in collapsedJobs.
                                        // If we want to expand, we need to ensure it's NOT in collapsedJobs?
                                        // But typically "collapsed by default" means we need to set state to "expanded" (or just NOT collapsed if default is collapsed).
                                        // Actually, if default is collapsed, we need to Change the default.
                                        // However, Alpine usually inits empty objects. !!undefined is false.
                                        // So isJobStepsCollapsed(id) is false by default -> EXPANDED by default?
                                        // That doesn't match standard UI (usually collapsed).
                                        // Let's check `isJobStepsCollapsed`: return !!this.collapsedJobs[jobId].
                                        // If `collapsedJobs` is empty, it returns `false` (Expanded).
                                        // But on the UI jobs start collapsed.
                                        // Ah, maybe the HTML uses `!isJobStepsCollapsed` to show?
                                        // Let's double check HTML.
                                        // <template x-if="item.type === 'parent' ... && !isJobStepsCollapsed(item.job.id)">
                                        // If default is false (expanded), then all jobs should be open.
                                        // But they are usually closed.
                                        // Maybe I should explicitly SET them to false (expanded) to be sure, or true (collapsed) otherwise?
                                        // Actually, the user wants them OPEN.
                                        // If `isJobStepsCollapsed` returns false, they are OPEN.
                                        // So default (empty map) = OPEN? That seems wrong for a list of 50 jobs.
                                        // I suspect I logic-swapped or the variable name is confusing.
                                        // Let's ASSUME default should be collapsed.
                                        // If I want to auto-expand running jobs, I should make sure `isJobStepsCollapsed` returns `false`.
                                        // Usage: x-if="... && !isJobStepsCollapsed(item.job.id)".
                                        // If I want to SHOW, `!isJobStepsCollapsed` must be true => `isJobStepsCollapsed` must be false.
                                        // So default (undefined) = false => SHOW?
                                        // That means ALL jobs would be open by default.
                                        // I should probably set `collapsedJobs` to match all non-running jobs as `true` (collapsed) initially?
                                        // Or maybe the user WANTS them open?
                                        // User said: "On inital load the page should open all running steps".
                                        // Implicitly others should be closed? "completed steps should be closed".

                                        // I will enforce policy:
                                        // Running -> Expanded (entry in collapsedJobs = false, or just not present if default is expanded? NO, I need to know the default).
                                        // Let's assume I need to explicitly set them.

                                        // Strategy:
                                        // Initialize all 'completed/failed/cancelled' as COLLAPSED (true).
                                        // Initialize 'running' as EXPANDED (false).

                                        if (['completed', 'failed', 'cancelled'].includes(job.status)) {
                                            this.collapsedJobs[job.id] = true;
                                        } else if (job.status === 'running') {
                                            this.collapsedJobs[job.id] = false;
                                            // Trigger data fetch for running job
                                            this.loadJobTreeData(job.id);
                                        }
                                    }
                                });
                            }

                            // Load events for completed steps that may not have step_name in aggregated logs
                            // This ensures fast-completing steps show their events on page reload
                            this.loadCompletedStepEvents().then(() => {
                                this.renderJobs();
                            });
                        });

                    } catch (error) {
                        // Handle AbortError separately - don't treat as error
                        if (error.name === 'AbortError') {
                            console.log('[Queue] Request aborted (isLoading:', this.isLoading, '), new request in progress');
                            return;
                        }

                        console.error('[Queue] Error loading jobs (attempt ' + (this.retryCount + 1) + '):', error);
                        this.loadError = error.message;

                        // Fall back to last successful data if available
                        if (this.lastSuccessfulJobs.length > 0) {
                            this.allJobs = [...this.lastSuccessfulJobs];
                            this.filteredJobs = [...this.lastSuccessfulJobs];
                            this.renderJobs();
                            console.log('[Queue] Rendered fallback data from last successful load');
                        }

                        // Increment retry count
                        this.retryCount++;
                        console.log('[Queue] Retry count incremented to', this.retryCount, 'of', this.maxRetries);

                        // Schedule automatic retry with exponential backoff if under max retries
                        if (this.retryCount < this.maxRetries) {
                            const delay = Math.min(1000 * Math.pow(2, this.retryCount), 30000);
                            console.log('[Queue] Scheduling retry in', delay, 'ms');
                            setTimeout(() => {
                                this.loadJobs();
                            }, delay);
                        }

                    } finally {
                        console.log('[Queue] loadJobs finally block executing for request ID:', requestId);
                        console.log('[Queue] Current sequence:', this._loadSeq, 'Latest request ID:', requestId);

                        // Only clear loading state if this is the latest request
                        // This prevents flicker from aborted requests that complete after a newer request
                        if (requestId === this._loadSeq) {
                            console.log('[Queue] Clearing loading state for latest request');
                            this.isLoading = false;
                            Alpine.store('queueState').setLoading(false);
                            Alpine.store('queueState').setLastUpdate(new Date());
                        } else {
                            console.log('[Queue] Skipping loading state clear for outdated request', requestId);
                        }

                        this.currentFetchController = null;
                        console.log('[Queue] isLoading after check:', this.isLoading);
                        console.log('[Queue] Store isLoading:', Alpine.store('queueState').isLoading);
                        console.log('[Queue] Clearing fetch controller:', this.currentFetchController !== null);
                    }
                },

                // NOTE: Child job tree management methods removed (loadChildJobs, getVisibleChildJobs, loadMoreChildJobs,
                // isChildCollapsed, toggleNodeCollapse, isNodeCollapsed, mightHaveChildren, hasVisibleChildren)
                // Expand/collapse functionality was removed in queue-ui-improvements feature
                // Child job information is now displayed via parent job statistics (child_count, completed_children, etc.)

                // Status Icon Mapping Functions
                getStatusIcon(status) {
                    const iconMap = {
                        'pending': 'fa-clock',
                        'running': 'fa-spinner fa-pulse',
                        'completed': 'fa-check-circle',
                        'failed': 'fa-times-circle',
                        'cancelled': 'fa-ban'
                    };
                    return iconMap[status] || 'fa-question-circle';
                },

                getStatusDisplayText(status) {
                    const textMap = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return textMap[status] || 'Unknown';
                },

                // NOTE: Tree keyboard navigation methods removed (handleTreeKeydown, focusTreeItem, getVisibleTreeItems,
                // getTreeItemIndex, visibleTreeItemCount) - expand/collapse functionality was removed in queue-ui-improvements

                announceToScreenReader(message) {
                    // Create an ARIA live region to announce changes to screen readers
                    let liveRegion = document.getElementById('aria-live-region');
                    if (!liveRegion) {
                        // Create the live region if it doesn't exist
                        const region = document.createElement('div');
                        region.setAttribute('id', 'aria-live-region');
                        region.setAttribute('aria-live', 'polite');
                        region.setAttribute('aria-atomic', 'true');
                        region.style.position = 'absolute';
                        region.style.left = '-10000px';
                        region.style.width = '1px';
                        region.style.height = '1px';
                        region.style.overflow = 'hidden';
                        document.body.appendChild(region);
                        liveRegion = region;
                    }

                    // Update live region content
                    liveRegion.textContent = message;

                    // Clear after a delay to avoid repeated announcements
                    setTimeout(() => {
                        liveRegion.textContent = '';
                    }, 1000);
                },

                renderJobs() {
                    // Render parent jobs only. Steps are handled by the Inline Tree View.
                    const itemsToRender = [];

                    if (this.filteredJobs && Array.isArray(this.filteredJobs)) {
                        this.filteredJobs.forEach(parentJob => {
                            // Only include parents
                            if (!parentJob.parent_id) {
                                itemsToRender.push({ type: 'parent', job: parentJob });
                            }
                        });
                    }

                    this.itemsToRender = itemsToRender;
                },




                // Throttled version of renderJobs to prevent UI thrashing during rapid updates
                throttledRenderJobs() {
                    if (this._renderPending) return;

                    this._renderPending = true;
                    if (this._renderTimeout) {
                        clearTimeout(this._renderTimeout);
                    }

                    this._renderTimeout = setTimeout(() => {
                        this._renderPending = false;
                        this._renderTimeout = null;
                        this.renderJobs();
                    }, this._renderThrottleMs);
                },


                getDocumentsCount(job) {
                    // PRIORITY 1: Use document_count from metadata (real-time count via WebSocket)
                    // This field is extracted from job.metadata.document_count by the backend
                    // and is the authoritative source for document counts
                    if (job.document_count !== undefined && job.document_count !== null) {
                        return job.document_count;
                    }

                    // PRIORITY 2: For jobs without metadata.document_count, check metadata directly
                    if (job.metadata && job.metadata.document_count !== undefined && job.metadata.document_count !== null) {
                        return job.metadata.document_count;
                    }

                    // PRIORITY 3: For active jobs, use progress.completed_urls (real-time counter)
                    if (job.progress) {
                        try {
                            const progress = typeof job.progress === 'string' ? JSON.parse(job.progress) : job.progress;
                            if (progress && progress.completed_urls !== undefined) {
                                return progress.completed_urls;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to parse job progress:', error);
                        }
                    }

                    // PRIORITY 4: Fallback to result_count (snapshot at completion)
                    // Note: result_count should equal document_count for properly tracked jobs
                    if (job.result_count !== undefined && job.result_count !== null) {
                        return job.result_count;
                    }

                    return 'N/A';
                },

                getCreatedDate(job) {
                    return job.created_at ? new Date(job.created_at).toLocaleString() : 'N/A';
                },

                getStartedDate(job) {
                    if (!job.started_at) return null;
                    try {
                        return new Date(job.started_at).toLocaleString();
                    } catch (error) {
                        console.warn('[Queue] Failed to parse started_at:', error);
                        return 'Invalid Date';
                    }
                },

                getFinishedDate(job) {
                    if (!job.finished_at) return null;
                    try {
                        return new Date(job.finished_at).toLocaleString();
                    } catch (error) {
                        console.warn('[Queue] Failed to parse finished_at:', error);
                        return 'Invalid Date';
                    }
                },

                // New helper methods for UI improvements

                getChildJobsSummary(parentId) {
                    // Get parent job to access child statistics from backend
                    const parentJob = this.allJobs.find(j => j.id === parentId);
                    if (!parentJob || !parentJob.child_count || parentJob.child_count === 0) {
                        return 'No child jobs';
                    }

                    // Use child statistics from backend (sent with parent job)
                    const counts = {
                        pending: parentJob.pending_children || 0,
                        running: parentJob.running_children || 0,
                        completed: parentJob.completed_children || 0,
                        failed: parentJob.failed_children || 0,
                        cancelled: parentJob.cancelled_children || 0
                    };

                    const parts = [];
                    if (counts.pending > 0) parts.push(`${counts.pending} pending`);
                    if (counts.running > 0) parts.push(`${counts.running} running`);
                    if (counts.completed > 0) parts.push(`${counts.completed} completed`);
                    if (counts.failed > 0) parts.push(`${counts.failed} failed`);
                    if (counts.cancelled > 0) parts.push(`${counts.cancelled} cancelled`);

                    return parts.length > 0 ? parts.join(', ') : 'No jobs';
                },

                formatLogTime(timestamp) {
                    if (!timestamp) return '';
                    try {
                        const date = new Date(timestamp);
                        // Include milliseconds for ordering visibility in fast jobs
                        const hours = String(date.getHours()).padStart(2, '0');
                        const mins = String(date.getMinutes()).padStart(2, '0');
                        const secs = String(date.getSeconds()).padStart(2, '0');
                        const ms = String(date.getMilliseconds()).padStart(3, '0');
                        return `${hours}:${mins}:${secs}.${ms}`;
                    } catch (error) {
                        return '';
                    }
                },



                async refreshParentJob(parentId) {
                    try {
                        const response = await fetch(`/api/jobs/${parentId}`);
                        if (response.ok) {
                            const job = await response.json();
                            // Update the job in allJobs
                            const index = this.allJobs.findIndex(j => j.id === parentId);
                            if (index !== -1) {
                                this.allJobs[index] = job;
                                this.renderJobs();
                                window.showNotification('Job stats refreshed', 'success');
                            }
                            // NOTE: Child job reload removed - expand/collapse functionality was removed in queue-ui-improvements
                        } else {
                            window.showNotification('Failed to refresh job stats', 'error');
                        }
                    } catch (error) {
                        console.error('[Queue] Error refreshing parent job:', error);
                        window.showNotification('Failed to refresh job stats', 'error');
                    }
                },

                getJobURL(job) {
                    if (!job) return null;
                    // Priority: seed_urls > current_url
                    if (job.seed_urls && job.seed_urls.length > 0) {
                        return job.seed_urls[0];
                    }
                    if (job.progress?.current_url) {
                        return job.progress.current_url;
                    }
                    return null;
                },

                deriveParentStatus(job) {
                    // If not a parent job or no child stats, return original status
                    if (!job.child_count || job.child_count === 0) {
                        return { status: job.status, suffix: '' };
                    }

                    const total = job.child_count;
                    const completed = job.completed_children || 0;
                    const failed = job.failed_children || 0;
                    const cancelled = job.cancelled_children || 0;
                    const running = job.running_children || 0;
                    const pending = job.pending_children || 0;

                    // If any children are running, parent is "Running"
                    if (running > 0) {
                        return { status: 'running', suffix: '' };
                    }

                    // If any children are pending, parent is "Running" (still orchestrating)
                    if (pending > 0) {
                        return { status: 'running', suffix: '' };
                    }

                    // All children in terminal state
                    const terminalCount = completed + failed + cancelled;
                    if (terminalCount >= total) {
                        // All children complete - determine success/failure
                        if (failed > 0) {
                            return { status: 'failed', suffix: ` (${failed} failed)` };
                        }
                        if (cancelled === total) {
                            return { status: 'cancelled', suffix: '' };
                        }
                        return { status: 'completed', suffix: '' };
                    }

                    // Default to running
                    return { status: 'running', suffix: '' };
                },

                getStatusBadgeClass(type, status, job) {
                    // For parent jobs, derive status from children
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                    }

                    if (type === 'child') {
                        const childBadges = {
                            'pending': 'label-secondary',
                            'running': 'label-primary label-processing',
                            'completed': 'label-success label-done',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return childBadges[status] || 'label';
                    } else if (type === 'parent') {
                        const parentBadges = {
                            'pending': 'label-warning label-queued',
                            'running': 'label-primary label-orchestrating',
                            'completed': 'label-success',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return parentBadges[status] || 'label';
                    } else {
                        // In flat mode, determine if job is parent or child based on parent_id field
                        const isChild = !!job.parent_id;
                        if (isChild) {
                            const childBadges = {
                                'pending': 'label-secondary',
                                'running': 'label-primary label-processing',
                                'completed': 'label-success label-done',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return childBadges[status] || 'label';
                        } else {
                            const parentBadges = {
                                'pending': 'label-warning label-queued',
                                'running': 'label-primary label-orchestrating',
                                'completed': 'label-success',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return parentBadges[status] || 'label';
                        }
                    }
                },

                getStatusBadgeText(type, status, job) {
                    // For parent jobs, derive status from children
                    let suffix = '';
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                        suffix = derived.suffix;
                    }

                    // Return appropriate text based on the badge type
                    const statusTexts = {
                        'pending': type === 'child' ? 'Pending' : type === 'parent' ? 'Pending' : (!job || !job.parent_id ? 'Pending' : 'Pending'),
                        'running': type === 'child' ? 'Running' : type === 'parent' ? 'Running' : (!job || !job.parent_id ? 'Running' : 'Running'),
                        'completed': type === 'child' ? 'Completed' : 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return (statusTexts[status] || 'Unknown') + suffix;
                },

                toggleJobSelection(jobId) {
                    if (this.selectedJobIds.has(jobId)) {
                        this.selectedJobIds.delete(jobId);
                    } else {
                        this.selectedJobIds.add(jobId);
                    }
                    this.updateDeleteSelectedButtonVisibility();
                    this.updateSelectAllCheckbox();
                },

                toggleSelectAll() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');

                    if (selectAllCheckbox.checked) {
                        // Select all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.add(jobId);
                            checkbox.checked = true;
                        });
                    } else {
                        // Deselect all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.delete(jobId);
                            checkbox.checked = false;
                        });
                    }

                    this.updateDeleteSelectedButtonVisibility();
                },

                updateSelectAllCheckbox() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');
                    const checkedCount = Array.from(jobCheckboxes).filter(cb => cb.checked).length;

                    if (checkedCount === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else if (checkedCount === jobCheckboxes.length) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true;
                    }
                },

                updateDeleteSelectedButtonVisibility() {
                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    if (this.selectedJobIds.size > 0) {
                        deleteButton.style.display = 'inline-block';
                        if (buttonSpan) {
                            buttonSpan.textContent = `Delete Selected (${this.selectedJobIds.size})`;
                        }
                    } else {
                        deleteButton.style.display = 'none';
                        if (buttonSpan) {
                            buttonSpan.textContent = 'Delete Selected';
                        }
                    }
                },

                async deleteSelectedJobs() {
                    // Idempotency check - prevent concurrent deletions
                    if (this.isDeletingJobs) {
                        console.log('Deletion already in progress, skipping');
                        return;
                    }

                    if (this.selectedJobIds.size === 0) {
                        window.showNotification('No jobs selected', 'warning');
                        return;
                    }

                    // Get job details for confirmation (BEFORE setting deletion flag)
                    const jobDetails = [];
                    const jobIdsArray = Array.from(this.selectedJobIds);
                    let totalChildren = 0;

                    for (const jobId of jobIdsArray) {
                        const job = this.allJobs.find(j => j.id === jobId);
                        if (job) {
                            const childCount = job.child_count || 0;
                            totalChildren += childCount;
                            jobDetails.push({
                                id: jobId,
                                name: job.name || `Job ${jobId.substring(0, 8)}`,
                                status: job.status,
                                childCount: childCount
                            });
                        }
                    }

                    // Show custom confirmation modal using event-based API (pass pre-built job details)
                    const confirmed = await openDeleteConfirmModal(jobDetails, totalChildren);

                    if (!confirmed) {
                        // User cancelled - no need to clear flag since it wasn't set yet
                        return;
                    }

                    // NOW set the deletion in progress flag (after user confirmed)
                    this.isDeletingJobs = true;
                    this.deletionProgress = { current: 0, total: this.selectedJobIds.size };

                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    const originalText = buttonSpan ? buttonSpan.textContent : 'Delete Selected';
                    deleteButton.disabled = true;
                    deleteButton.innerHTML = '<i class="fas fa-spinner fa-pulse"></i> <span>Deleting...</span>';

                    // Create snapshot for rollback on error
                    const jobsToDelete = jobIdsArray.map(jobId => {
                        const allJobsIndex = this.allJobs.findIndex(job => job.id === jobId);
                        const filteredJobsIndex = this.filteredJobs.findIndex(job => job.id === jobId);
                        return {
                            id: jobId,
                            job: this.allJobs[allJobsIndex],
                            allJobsIndex: allJobsIndex,
                            filteredJobsIndex: filteredJobsIndex
                        };
                    });

                    // Optimistic update: Remove jobs from UI immediately
                    this.allJobs = this.allJobs.filter(job => !this.selectedJobIds.has(job.id));
                    this.filteredJobs = this.filteredJobs.filter(job => !this.selectedJobIds.has(job.id));
                    this.renderJobs();

                    const results = {
                        successful: [],
                        failed: []
                    };

                    try {
                        // Delete each job
                        for (let i = 0; i < jobIdsArray.length; i++) {
                            const jobId = jobIdsArray[i];
                            this.deletionProgress.current = i + 1;

                            try {
                                const response = await fetch(`/api/jobs/${jobId}`, {
                                    method: 'DELETE'
                                });

                                if (response.ok) {
                                    const data = await response.json();
                                    results.successful.push({
                                        jobId: jobId,
                                        cascadeDeleted: data.cascade_deleted || 0
                                    });

                                    // Dispatch cleanup event for successful deletion to sync child-state maps
                                    window.dispatchEvent(new CustomEvent('jobList:deleteCleanup', {
                                        detail: { jobId: jobId, parentId: null }
                                    }));
                                } else {
                                    // Try to parse JSON error response
                                    let errorText = 'Unknown error';
                                    let errorData = null;
                                    try {
                                        errorData = await response.json();
                                        errorText = errorData.details || errorData.error || `HTTP ${response.status}`;
                                    } catch (e) {
                                        errorText = await response.text();
                                    }
                                    results.failed.push({
                                        jobId: jobId,
                                        error: errorText,
                                        status: errorData?.status,
                                        childCount: errorData?.child_count
                                    });
                                }
                            } catch (error) {
                                results.failed.push({ jobId, error: error.message });
                            }

                            // Re-render after each deletion for better UX
                            this.renderJobs();
                        }
                    } finally {
                        // Clear selections
                        this.selectedJobIds.clear();
                        const selectAllCheckbox = document.getElementById('select-all-checkbox');
                        if (selectAllCheckbox) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                        }

                        // Reset button
                        deleteButton.disabled = false;
                        deleteButton.innerHTML = `<i class="fa-solid fa-trash"></i> <span>${originalText}</span>`;
                        this.updateDeleteSelectedButtonVisibility();

                        // Clear deletion flags
                        this.isDeletingJobs = false;
                        this.deletionProgress = { current: 0, total: 0 };

                        // Show results - single notification with summary
                        if (results.successful.length > 0 && results.failed.length === 0) {
                            // All successful
                            const totalCascade = results.successful.reduce((sum, r) => sum + r.cascadeDeleted, 0);
                            window.showNotification(
                                `Successfully deleted ${results.successful.length} job${results.successful.length > 1 ? 's' : ''}${totalCascade > 0 ? ` (${totalCascade} children)` : ''}`,
                                'success'
                            );
                        } else if (results.successful.length === 0 && results.failed.length > 0) {
                            // All failed
                            const mostCommonError = this.getMostCommonError(results.failed);
                            window.showNotification(
                                `Failed to delete ${results.failed.length} job${results.failed.length > 1 ? 's' : ''}: ${mostCommonError}`,
                                'error'
                            );
                            console.error('Failed deletions:', results.failed);
                        } else {
                            // Partial success
                            const mostCommonError = this.getMostCommonError(results.failed);
                            window.showNotification(
                                `Deleted ${results.successful.length} of ${jobIdsArray.length} jobs. ${results.failed.length} failed: ${mostCommonError}`,
                                'warning'
                            );
                            console.error('Partial deletion failures:', results.failed);
                        }

                        // Refresh data
                        window.loadStats();
                        this.renderJobs();
                    }
                },

                // Helper function to get most common error message
                getMostCommonError(failures) {
                    const errorCounts = {};
                    failures.forEach(f => {
                        errorCounts[f.error] = (errorCounts[f.error] || 0) + 1;
                    });
                    let maxCount = 0;
                    let mostCommon = '';
                    for (const [error, count] of Object.entries(errorCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            mostCommon = error;
                        }
                    }
                    return mostCommon || failures[0].error;
                },

                async updateJobInList(update) {
                    console.log('[Queue] Job updated via WebSocket:', update.job_id.substring(0, 8), update.status, 'parent_id:', update.parent_id || 'none');

                    // If loading, queue the update to apply after fetch completes
                    if (this.isLoading) {
                        // Coalesce updates by job_id - if update for same job exists, replace it
                        const existingIndex = this.pendingUpdates.findIndex(u => u.job_id === update.job_id);
                        if (existingIndex >= 0) {
                            // Replace existing update for this job (keep newest state)
                            this.pendingUpdates[existingIndex] = update;
                        } else {
                            // Add new update
                            this.pendingUpdates.push(update);
                        }

                        // Cap the queue size to prevent unbounded growth
                        if (this.pendingUpdates.length > this.pendingUpdatesMaxSize) {
                            // Remove oldest entries, keeping the most recent ones
                            this.pendingUpdates.splice(0, this.pendingUpdates.length - this.pendingUpdatesMaxSize);
                        }
                        return;
                    }

                    // Find job in allJobs array
                    let jobIndex = this.allJobs.findIndex(job => job.id === update.job_id);
                    let job = jobIndex >= 0 ? this.allJobs[jobIndex] : null;

                    // If job not found, check if we should fetch it
                    // IMPORTANT: Child jobs (worker jobs under steps) are NOT individually fetched
                    // because with 1000+ child jobs, this causes browser resource exhaustion.
                    // Child job stats are tracked via aggregated step_progress/parent_job_progress events.
                    if (!job) {
                        // Check if this is a child job (has parent_id in the update)
                        // Child jobs are tracked via aggregated events, not individual fetches
                        if (update.parent_id) {
                            console.debug('[Queue] Skipping individual fetch for child job:', update.job_id?.substring(0, 8), 'parent:', update.parent_id?.substring(0, 8));
                            return;
                        }

                        // Only fetch for root-level jobs (managers/parents without parent_id)
                        try {
                            const response = await fetch(`/api/jobs/${update.job_id}`);

                            // Handle 404 silently - job was deleted, ignore update
                            if (response.status === 404) {
                                console.debug('[Queue] Job deleted or not found:', update.job_id.substring(0, 8));
                                return;
                            }

                            if (response.ok) {
                                job = await response.json();
                                this.allJobs.unshift(job); // Insert at beginning (newest first)
                                jobIndex = 0;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to fetch new job:', error);
                            return;
                        }
                    }

                    // If job still not found, ignore update
                    if (!job) {
                        return;
                    }

                    const completedStatuses = ['completed', 'failed', 'cancelled'];

                    // Update job fields - preserve existing values when fields are omitted
                    job.status = update.status;

                    // Auto-expand parent job if it starts running (real-time)
                    if (update.status === 'running' && !job.parent_id) {
                        // Ensure tree data is loaded so it's visible (even if already "expanded" state)
                        if (this.isJobStepsCollapsed(update.job_id)) {
                            console.log('[Queue] Auto-expanding running job (update):', update.job_id.substring(0, 8));
                            this.collapsedJobs[update.job_id] = false;
                            this.loadJobTreeData(update.job_id);
                        } else if (!this.jobTreeData[update.job_id]) {
                            this.loadJobTreeData(update.job_id);
                        }
                    }

                    if (update.result_count !== undefined && update.result_count !== null) {
                        job.result_count = update.result_count;
                    }
                    if (update.failed_count !== undefined && update.failed_count !== null) {
                        job.failed_count = update.failed_count;
                    }
                    if (update.document_count !== undefined && update.document_count !== null) {
                        job.document_count = update.document_count;
                    }

                    // Update progress object
                    if (!job.progress) {
                        job.progress = {};
                    }
                    if (typeof job.progress === 'string') {
                        try {
                            job.progress = JSON.parse(job.progress);
                        } catch (e) {
                            job.progress = {};
                        }
                    }

                    if (update.completed_urls !== undefined && update.completed_urls !== null) {
                        job.progress.completed_urls = update.completed_urls;
                    }
                    if (update.pending_urls !== undefined && update.pending_urls !== null) {
                        job.progress.pending_urls = update.pending_urls;
                    }
                    if (update.total_urls !== undefined && update.total_urls !== null) {
                        job.progress.total_urls = update.total_urls;
                    }

                    // Set error if present
                    if (update.error !== undefined && update.error !== null) {
                        job.error = update.error;
                    }

                    // If this is a parent job (no parent_id), populate status_report from update fields immediately
                    // This ensures UI shows current progress without waiting for debounced refresh
                    if (!job.parent_id && (update.progress_text || update.errors || update.warnings || update.running_children !== undefined)) {
                        if (!job.status_report) {
                            job.status_report = {};
                        }
                        if (update.progress_text) {
                            job.status_report.progress_text = update.progress_text;
                        }
                        if (update.errors) {
                            job.status_report.errors = update.errors;
                        }
                        if (update.warnings) {
                            job.status_report.warnings = update.warnings;
                        }
                        if (update.running_children !== undefined) {
                            job.status_report.running_children = update.running_children;
                        }
                    }

                    // Find job in filteredJobs BEFORE checking filters
                    const filteredIndex = this.filteredJobs.findIndex(j => j.id === update.job_id);

                    // If job is already in filteredJobs, keep it visible and update in-place (sticky visibility)
                    if (filteredIndex >= 0) {
                        this.filteredJobs[filteredIndex] = job;
                    } else {
                        // For NEW jobs that are not yet in filteredJobs, apply filters as normal
                        // IMPORTANT: Only add PARENT jobs to filteredJobs (child jobs are in allJobs only)
                        // filteredJobs is used for pagination of parent jobs; child jobs display under parents
                        if (job.parent_id) {
                            // Child job - don't add to filteredJobs, just update allJobs (already done above)
                            console.debug('[Queue] Skipping child job from filteredJobs:', job.id?.substring(0, 8));
                        } else {
                            const matchesFilters = window.matchesActiveFilters(job);

                            if (matchesFilters) {
                                // Insert at correct position (sorted by created_at DESC)
                                const insertIndex = this.filteredJobs.findIndex(j => {
                                    return new Date(j.created_at) < new Date(job.created_at);
                                });
                                if (insertIndex >= 0) {
                                    this.filteredJobs.splice(insertIndex, 0, job);
                                } else {
                                    this.filteredJobs.push(job);
                                }
                            }
                            // If doesn't match filters, don't add to filteredJobs (as before)
                        }
                    }

                    // If child job updated, refresh parent stats (debounced per parent_id)
                    if (job.parent_id) {
                        this.debouncedRefreshParent(job.parent_id);
                    }

                    if (!job.parent_id && completedStatuses.includes(update.status)) {
                        // If a manager job has step_job_ids, load step events (covers steps that completed before WS triggers)
                        if (job.metadata?.step_job_ids) {
                            console.log('[Queue] Manager job completed, loading step events for:', job.id.substring(0, 8));
                            const stepJobIds = job.metadata.step_job_ids;
                            for (const [stepName, stepJobId] of Object.entries(stepJobIds)) {
                                const existingLogs = this.jobLogs[job.id] || [];
                                const stepLogs = existingLogs.filter(l => l.step_name === stepName);
                                if (stepLogs.length === 0) {
                                    this.fetchStepEventsById(job.id, stepName, stepJobId);
                                }
                            }
                        }

                        // Ensure the tree view reflects final step expansions even if early WS step status events were missed.
                        // This avoids clearing the DOM and ensures every step becomes visible/expanded at end of job.
                        if (this.isJobStepsCollapsed(job.id)) {
                            this.collapsedJobs[job.id] = false;
                        }
                        if (!this.jobTreeData[job.id]) {
                            await this.loadJobTreeData(job.id);
                        }

                        await this.fetchJobStructure(job.id);

                        const treeData = this.jobTreeData[job.id];
                        if (treeData?.steps) {
                            // Ensure expanded before rendering completion state (UI tests assert immediately on completion)
                            treeData.steps.forEach((_, idx) => {
                                const key = `${job.id}:${idx}`;
                                if (this.jobTreeExpandedSteps[key] !== false) {
                                    this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [key]: true };
                                }
                            });

                            // Fetch final step logs so the DOM reflects completion state.
                            // Bypass debouncing/in-flight caching so completion always upgrades to a full log fetch.
                            for (let idx = 0; idx < treeData.steps.length; idx++) {
                                const step = treeData.steps[idx];
                                const fetchKey = `${job.id}:${step.name}`;
                                if (this._stepFetchDebounceTimers[fetchKey]) {
                                    clearTimeout(this._stepFetchDebounceTimers[fetchKey]);
                                    delete this._stepFetchDebounceTimers[fetchKey];
                                }
                                this._stepFetchInFlight.delete(fetchKey);
                                delete this._stepFetchPromises[fetchKey];
                                await this._doFetchStepLogs(job.id, step.name, idx);
                            }
                        }

                    }

                    // Trim to pageSize if on first page to maintain pagination consistency
                    if (this.currentPage === 1 && this.filteredJobs.length > this.pageSize) {
                        this.filteredJobs.length = this.pageSize;
                    }

                    // Re-render jobs (throttled to prevent UI thrashing during rapid updates)
                    this.throttledRenderJobs();
                },

                // Debounced stats recalculation - prevents API flooding during rapid job updates
                // Only fetches stats at most once per _statsDebounceMs (default 2 seconds)
                recalculateStats() {
                    // Clear any existing timeout
                    if (this._statsTimeout) {
                        clearTimeout(this._statsTimeout);
                    }

                    // Set new timeout to fetch stats after debounce period
                    this._statsTimeout = setTimeout(() => {
                        this._statsTimeout = null;
                        this._doFetchStats();
                    }, this._statsDebounceMs);
                },

                // DEPRECATED: handleJobLog - no longer used
                // Architecture: WebSocket sends only 'refresh_logs' triggers, not actual logs
                // Logs are fetched from REST API /api/logs when trigger is received
                // This prevents heavy WebSocket load when jobs produce 5000+ log entries
                handleJobLog(detail) {
                    // No-op: This function is deprecated
                    // Logs are now fetched via handleRefreshStepEvents -> fetchStepLogs -> /api/logs
                },

                // Handle refresh step events trigger (notify-pull model)
                // This is the primary mechanism for updating logs - fetches from REST API
                handleRefreshStepEvents(detail) {
                    const { step_ids, timestamp, finished } = detail;
                    if (!step_ids || step_ids.length === 0) return;

                    step_ids.forEach(stepId => {
                        let jobId = stepId;
                        let stepName = null;

                        // Handle object format {job_id, step_name} if present
                        if (typeof stepId === 'object') {
                            jobId = stepId.job_id;
                            stepName = stepId.step_name;
                        }

                        // If we only have Job ID, we refresh all visible/expanded steps for this job
                        if (this.jobTreeData[jobId]) {
                            const treeSteps = this.jobTreeData[jobId].steps || [];
                            treeSteps.forEach((s, idx) => {
                                // If stepName is specified, only refresh that step.
                                if (stepName && s.name !== stepName) return;

                                // Auto-expand step when it receives log updates (replaces handleJobLog auto-expand)
                                const treeStepKey = `${jobId}:${idx}`;
                                if (!this.jobTreeExpandedSteps[treeStepKey]) {
                                    this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [treeStepKey]: true };
                                }

                                this.fetchStepLogs(jobId, s.name, idx);
                            });
                        }
                    });
                },

                // Debounced refresh of parent job (called when children update)
                _parentRefreshTimeouts: {},
                debouncedRefreshParent(parentId) {
                    if (!this._parentRefreshTimeouts) this._parentRefreshTimeouts = {};

                    if (this._parentRefreshTimeouts[parentId]) {
                        clearTimeout(this._parentRefreshTimeouts[parentId]);
                    }

                    this._parentRefreshTimeouts[parentId] = setTimeout(async () => {
                        try {
                            // Fetch updated parent job data to get latest stats/counts
                            const response = await fetch(`/api/jobs/${parentId}`);
                            if (response.ok) {
                                const updatedJob = await response.json();
                                const idx = this.allJobs.findIndex(j => j.id === parentId);
                                if (idx >= 0) {
                                    this.allJobs[idx] = updatedJob;
                                    console.log('[Queue] Refreshed parent job:', parentId.substring(0, 8));
                                    this.throttledRenderJobs();
                                }
                            }
                            delete this._parentRefreshTimeouts[parentId];
                        } catch (err) {
                            console.warn('[Queue] Failed to refresh parent:', parentId, err);
                        }
                    }, 1000); // 1s debounce
                },

                // Internal: Actually fetch stats from API (called by debounced recalculateStats)
                async _doFetchStats() {
                    try {
                        console.log('[Queue] Fetching job stats (debounced)');
                        const response = await fetch('/api/jobs/stats');
                        if (response.ok) {
                            const stats = await response.json();
                            // Dispatch event to update jobStatsHeader component
                            window.dispatchEvent(new CustomEvent('jobStats:update', { detail: stats }));
                        }
                    } catch (error) {
                        console.error('[Queue] Error reloading job stats:', error);
                    }
                },

                // Fetch children for a parent job and add them to allJobs
                async fetchChildrenForParent(parentId) {
                    try {
                        const params = new URLSearchParams();
                        params.append('parent_id', parentId);
                        params.append('limit', '500');
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'ASC');

                        const response = await fetch(`/api/jobs?${params.toString()}`);
                        if (!response.ok) return;

                        const data = await response.json();
                        const children = data.jobs || [];
                        console.log('[Queue] Fetched', children.length, 'children for parent', parentId.substring(0, 8));

                        // Add new children to allJobs (avoid duplicates)
                        let addedCount = 0;
                        children.forEach(child => {
                            const existingIndex = this.allJobs.findIndex(j => j.id === child.id);
                            if (existingIndex < 0) {
                                this.allJobs.push(child);
                                addedCount++;
                            } else {
                                // Update existing child with fresh data
                                this.allJobs[existingIndex] = child;
                            }
                        });

                        if (addedCount > 0) {
                            console.log('[Queue] Added', addedCount, 'new children to allJobs');
                            this.throttledRenderJobs();
                        }
                    } catch (error) {
                        console.warn('[Queue] Failed to fetch children for parent', parentId, error);
                    }
                },

                // Debounced fetch children to prevent multiple fetches for same parent
                _childFetchTimeouts: {},
                debouncedFetchChildren(parentId) {
                    if (this._childFetchTimeouts[parentId]) {
                        clearTimeout(this._childFetchTimeouts[parentId]);
                    }
                    this._childFetchTimeouts[parentId] = setTimeout(() => {
                        this.fetchChildrenForParent(parentId);
                        delete this._childFetchTimeouts[parentId];
                    }, 500);
                },

                // Update job progress from crawler_job_progress WebSocket event
                updateJobProgress(progress) {
                    const jobIndex = this.allJobs.findIndex(j => j.id === progress.job_id);
                    if (jobIndex < 0) {
                        return; // Job not in current view
                    }

                    const job = this.allJobs[jobIndex];

                    // Update job status if provided (calculated from child job states)
                    if (progress.status) {
                        job.status = progress.status;
                    }

                    // Update document count for parent jobs (real-time count from metadata)
                    if (progress.document_count !== undefined) {
                        job.document_count = progress.document_count;
                    }

                    // Update child job statistics
                    if (progress.total_children !== undefined) {
                        const previousChildCount = job.child_count || 0;
                        job.child_count = progress.total_children;
                        job.completed_children = progress.completed_children || 0;
                        job.failed_children = progress.failed_children || 0;
                        job.cancelled_children = progress.cancelled_children || 0;
                        job.pending_children = progress.pending_children || 0;
                        job.running_children = progress.running_children || 0;

                        // Fetch children if new children were added
                        if (progress.total_children > previousChildCount) {
                            console.log('[Queue] Child count increased from', previousChildCount, 'to', progress.total_children, '- fetching children');
                            this.debouncedFetchChildren(job.id);
                        }
                    }

                    // Update status_report with progress text
                    if (!job.status_report) {
                        job.status_report = {};
                    }
                    if (progress.progress_text) {
                        job.status_report.progress_text = progress.progress_text;
                    }
                    if (progress.running_children !== undefined) {
                        job.status_report.running_children = progress.running_children;
                    }
                    if (progress.errors) {
                        job.status_report.errors = progress.errors;
                    }
                    if (progress.warnings) {
                        job.status_report.warnings = progress.warnings;
                    }

                    // Update step progress fields (for multi-step job definitions)
                    if (progress.current_step !== undefined) {
                        job.status_report.current_step = progress.current_step;
                        job.status_report.total_steps = progress.total_steps;
                        job.status_report.step_name = progress.step_name;
                        job.status_report.step_type = progress.step_type;
                        job.status_report.step_status = progress.step_status;

                        // Update metadata with step progress for UI (persisted for step rows)
                        if (!job.metadata) {
                            job.metadata = {};
                        }
                        job.metadata.current_step = progress.current_step;
                        job.metadata.current_step_name = progress.step_name;
                        job.metadata.current_step_type = progress.step_type;
                        job.metadata.current_step_status = progress.step_status;

                        // Track completed steps
                        if (progress.step_status === 'completed') {
                            job.metadata.completed_steps = progress.current_step;

                            // Update step_stats with child count for this step
                            if (progress.step_child_count !== undefined) {
                                if (!job.metadata.step_stats) {
                                    job.metadata.step_stats = [];
                                }
                                const stepIndex = progress.current_step - 1;
                                job.metadata.step_stats[stepIndex] = {
                                    step_index: stepIndex,
                                    step_name: progress.step_name,
                                    step_type: progress.step_type,
                                    child_count: progress.step_child_count
                                };
                            }
                        }
                    }

                    // Update progress object
                    if (!job.progress) {
                        job.progress = {};
                    }
                    if (progress.overall_progress !== undefined) {
                        job.progress.percentage = progress.overall_progress * 100;
                    }

                    // Re-render to show updated progress (throttled)
                    this.throttledRenderJobs();
                },

                // Update step progress from step_progress WebSocket event (from StepMonitor)
                // Steps are job type="step" that monitor their child jobs
                updateStepProgress(progress) {
                    // Also store step progress on the manager job for renderJobs() to use
                    // This ensures step progress is available even if step jobs aren't in allJobs
                    if (progress.manager_id && progress.step_name) {
                        const managerIndex = this.allJobs.findIndex(j => j.id === progress.manager_id);
                        if (managerIndex >= 0) {
                            const manager = this.allJobs[managerIndex];
                            // Initialize step_progress map if not exists
                            if (!manager._stepProgress) {
                                manager._stepProgress = {};
                            }
                            // Store progress keyed by step_name
                            manager._stepProgress[progress.step_name] = {
                                pending: progress.pending_jobs || 0,
                                running: progress.running_jobs || 0,
                                completed: progress.completed_jobs || 0,
                                failed: progress.failed_jobs || 0,
                                cancelled: progress.cancelled_jobs || 0,
                                total: progress.total_jobs || 0,
                                status: progress.status,
                                progress_text: progress.progress_text
                            };
                            console.log('[Queue] Stored step progress for', progress.step_name, 'on manager', progress.manager_id.substring(0, 8), ':', manager._stepProgress[progress.step_name]);

                            // Auto-expand step when it receives progress update (handles synchronous step completion)
                            // Per QUEUE_UI.md: "ALL steps should auto-expand when they start running"
                            const status = progress.status;
                            if (status === 'running' || status === 'completed' || status === 'failed') {
                                // Queue expansion for when tree data loads
                                if (!this._pendingStepExpansions[progress.manager_id]) {
                                    this._pendingStepExpansions[progress.manager_id] = new Set();
                                }
                                this._pendingStepExpansions[progress.manager_id].add(progress.step_name);

                                // If tree data already exists, expand immediately
                                if (this.jobTreeData[progress.manager_id]?.steps) {
                                    const treeData = this.jobTreeData[progress.manager_id];
                                    const stepIdx = treeData.steps.findIndex(s => s.name === progress.step_name);
                                    if (stepIdx >= 0) {
                                        const treeStepKey = `${progress.manager_id}:${stepIdx}`;
                                        if (!this.jobTreeExpandedSteps[treeStepKey]) {
                                            console.log('[Queue] Auto-expanding step from progress:', progress.step_name, 'status:', status);
                                            this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [treeStepKey]: true };
                                        }
                                    }
                                }
                            }
                        }
                    }

                    const stepIndex = this.allJobs.findIndex(j => j.id === progress.step_id);
                    if (stepIndex >= 0) {
                        const step = this.allJobs[stepIndex];

                        // Update step status
                        if (progress.status) {
                            step.status = progress.status;
                        }

                        // Update child job statistics for this step
                        step.child_count = progress.total_jobs || 0;
                        step.completed_children = progress.completed_jobs || 0;
                        step.failed_children = progress.failed_jobs || 0;
                        step.cancelled_children = progress.cancelled_jobs || 0;
                        step.pending_children = progress.pending_jobs || 0;
                        step.running_children = progress.running_jobs || 0;

                        // Update status_report with progress text
                        if (!step.status_report) {
                            step.status_report = {};
                        }
                        if (progress.progress_text) {
                            step.status_report.progress_text = progress.progress_text;
                        }
                    }

                    // Re-render to show updated progress (throttled)
                    this.throttledRenderJobs();
                },

                // DEPRECATED: Step event refresh - replaced by SSE streaming
                // These fields are kept for backwards compatibility but are no longer actively used
                // Logs are now streamed in real-time via /api/logs/stream SSE endpoint
                _pendingStepIds: new Set(),
                _refreshDebounceTimer: null,
                _refreshDebounceMs: 500,

                // DEPRECATED: Refresh step events from API (was triggered by refresh_logs WebSocket message)
                // This function is no longer used - SSE streaming replaces the signal-then-fetch pattern
                async refreshStepEvents(detail) {
                    const { step_ids, timestamp, finished } = detail;
                    if (!step_ids || step_ids.length === 0) return;

                    // Collect step_ids into pending set
                    for (const stepId of step_ids) {
                        this._pendingStepIds.add(stepId);
                    }

                    // Track which step_ids were marked finished so we can hydrate more aggressively.
                    if (finished) {
                        if (!this._pendingStepIdsFinished) {
                            this._pendingStepIdsFinished = new Set();
                        }
                        for (const stepId of step_ids) {
                            this._pendingStepIdsFinished.add(stepId);
                        }
                    }

                    // Clear existing timer
                    if (this._refreshDebounceTimer) {
                        clearTimeout(this._refreshDebounceTimer);
                    }

                    // If finished=true (step completed), process immediately
                    if (finished) {
                        this._processRefreshStepEvents();
                        return;
                    }

                    // Otherwise debounce - wait for more triggers
                    this._refreshDebounceTimer = setTimeout(() => {
                        this._processRefreshStepEvents();
                    }, this._refreshDebounceMs);
                },

                // Process pending step events (debounced)
                async _processRefreshStepEvents() {
                    this._refreshDebounceTimer = null;

                    // Get and clear pending step_ids
                    const stepIds = Array.from(this._pendingStepIds);
                    this._pendingStepIds.clear();

                    if (stepIds.length === 0) return;

                    console.log('[Queue] Processing', stepIds.length, 'step refresh triggers (debounced)');

                    // Initialize tracking structures
                    if (!this._stepEventFetchInFlight) {
                        this._stepEventFetchInFlight = new Set();
                    }

                    for (const stepJobId of stepIds) {
                        // Skip if already fetching this step's events
                        if (this._stepEventFetchInFlight.has(stepJobId)) {
                            continue;
                        }
                        this._stepEventFetchInFlight.add(stepJobId);

                        try {
                            // Find manager, step name, and step status from local data first
                            let managerId = null;
                            let stepName = null;
                            let stepStatus = null;
                            let stepIdx = -1;

                            // Check local job data first (avoid API call if possible)
                            for (const job of this.allJobs) {
                                const stepJobIds = job.metadata?.step_job_ids;
                                if (stepJobIds) {
                                    for (const [name, id] of Object.entries(stepJobIds)) {
                                        if (id === stepJobId) {
                                            managerId = job.id;
                                            stepName = name;
                                            // Get status from tree data if available
                                            if (this.jobTreeData[managerId]?.steps) {
                                                stepIdx = this.jobTreeData[managerId].steps.findIndex(s => s.name === name);
                                                if (stepIdx >= 0) {
                                                    stepStatus = this.jobTreeData[managerId].steps[stepIdx].status;
                                                }
                                            }
                                            break;
                                        }
                                    }
                                    if (managerId) break;
                                }
                            }

                            // Only fetch step job from API if we couldn't find it locally
                            if (!managerId) {
                                try {
                                    const stepResponse = await fetch(`/api/jobs/${stepJobId}`);
                                    if (stepResponse.ok) {
                                        const stepJob = await stepResponse.json();
                                        stepStatus = stepJob.status;
                                        managerId = stepJob.parent_id;
                                        stepName = stepJob.metadata?.step_name || stepJob.name;
                                    }
                                } catch (fetchErr) {
                                    console.warn('[Queue] Failed to fetch step job:', fetchErr);
                                }
                            }

                            if (!managerId || !stepName) {
                                continue;
                            }

                            // Determine whether this refresh was triggered by a finished step.
                            const isFinished = !!this._pendingStepIdsFinished?.has(stepJobId);

                            // Queue expansion for when tree data loads (handles race condition)
                            // Per QUEUE_UI.md: "ALL steps should auto-expand when they start running"
                            if (stepStatus === 'running' || stepStatus === 'completed' || stepStatus === 'failed') {
                                if (!this._pendingStepExpansions[managerId]) {
                                    this._pendingStepExpansions[managerId] = new Set();
                                }
                                this._pendingStepExpansions[managerId].add(stepName);
                            }

                            // Progressive hydration: keep UI light during running, but ensure visible growth in the DOM.
                            const limitKey = `${managerId}:${stepName}`;
                            if (isFinished) {
                                // Step finished - always fetch with full limit to get accurate totalLogCount
                                this.stepLogLimits = { ...this.stepLogLimits, [limitKey]: this.defaultLogsPerStep };
                            } else if (!this.stepLogLimits[limitKey]) {
                                // Start small during running so DOM log counts visibly increase over time (UI regression guard).
                                this.stepLogLimits = { ...this.stepLogLimits, [limitKey]: 20 };
                            }

                            let currentLimit = this.getStepLogLimit(managerId, stepName);
                            if (!isFinished) {
                                const treeStep = this.jobTreeData[managerId]?.steps?.find(s => s.name === stepName);
                                const existingLogsLen = (treeStep?.logs || []).length;
                                const knownTotal = treeStep?.totalLogCount || 0;

                                // Only increase the limit when we've filled the current window, otherwise the
                                // "earlier logs" count becomes inconsistent with the visible line numbers.
                                if (knownTotal > existingLogsLen && existingLogsLen === currentLimit && currentLimit < this.defaultLogsPerStep) {
                                    currentLimit = Math.min(this.defaultLogsPerStep, currentLimit + 20);
                                    this.stepLogLimits = { ...this.stepLogLimits, [limitKey]: currentLimit };
                                }
                            }

                            const fetchLimit = Math.min(currentLimit, 5000); // Server enforces a hard cap too

                            // Fetch latest N logs (newest first, then reverse for display)
                            // No cursor - always get the latest logs for sliding window display
                            // Use step parameter to route to getStepGroupedLogs (fast path, no child aggregation)
                            const level = this.getTreeLogLevelFilter(managerId);
                            let url = `/api/logs?scope=job&job_id=${stepJobId}&step=${encodeURIComponent(stepName)}&limit=${fetchLimit}&order=desc&level=${encodeURIComponent(level)}`;

                            const response = await fetch(url);
                            if (!response.ok) {
                                continue;
                            }

                            const data = await response.json();
                            // Response format: { steps: [{ step_name, logs, total_count }] }
                            const stepData = data.steps?.find(s => s.step_name === stepName);
                            let newLogs = stepData?.logs || [];
                            const totalCount = stepData?.total_count || newLogs.length;

                            // Logs are returned in ASC order from getStepGroupedLogs (already reversed from DESC fetch)
                            // No additional reversal needed

                            // Update jobTreeData (tree view) - always update status, even if no new logs
                            // If tree data not loaded yet, fetch it first (handles race condition)
                            if (!this.jobTreeData[managerId]) {
                                console.log('[Queue] Tree data not loaded for', managerId.substring(0, 8), '- loading now');
                                await this.loadJobTreeData(managerId);
                            }
                            if (this.jobTreeData[managerId]) {
                                const treeData = this.jobTreeData[managerId];
                                const stepIdx = treeData.steps?.findIndex(s => s.name === stepName);
                                if (stepIdx >= 0 && treeData.steps) {
                                    const newSteps = [...treeData.steps];
                                    const currentStep = newSteps[stepIdx];
                                    const oldStatus = currentStep.status;

                                    // Update step status if we fetched it
                                    if (stepStatus && stepStatus !== oldStatus) {
                                        console.log('[Queue] Step status updated:', stepName, ':', oldStatus, '->', stepStatus);
                                    }

                                    // Calculate log offset for line numbering (total - displayed = earlier logs)
                                    const logOffset = Math.max(0, totalCount - newLogs.length);

                                    // Update step with new status, logs, and total count for line numbering
                                    newSteps[stepIdx] = {
                                        ...currentStep,
                                        status: stepStatus || currentStep.status,
                                        logs: newLogs.length > 0 ? newLogs : currentStep.logs,
                                        totalLogCount: totalCount,
                                        logOffset: logOffset
                                    };

                                    this.jobTreeData = {
                                        ...this.jobTreeData,
                                        [managerId]: { ...treeData, steps: newSteps }
                                    };

                                    // Auto-expand step when it has activity (running/completed/failed)
                                    // Per QUEUE_UI.md: "ALL steps should auto-expand when they start running"
                                    // Also expand on completed/failed even without logs
                                    const effectiveStatus = stepStatus || currentStep.status;
                                    if (effectiveStatus === 'running' || effectiveStatus === 'completed' || effectiveStatus === 'failed' || newLogs.length > 0) {
                                        const treeStepKey = `${managerId}:${stepIdx}`;
                                        if (!this.jobTreeExpandedSteps[treeStepKey]) {
                                            console.log('[Queue] Auto-expanding step from refresh event:', stepName, 'status:', effectiveStatus, 'logs:', newLogs.length);
                                            this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [treeStepKey]: true };
                                        }
                                    }
                                }
                            }

                            // Skip further processing if no new logs
                            if (newLogs.length === 0) {
                                continue;
                            }

                            // Update jobLogs (flat view)
                            if (!this.jobLogs[managerId]) {
                                this.jobLogs[managerId] = [];
                            }
                            this.jobLogs[managerId] = this.jobLogs[managerId].filter(l => l.step_name !== stepName);
                            // Map logs to include both 'text' and 'message' for compatibility
                            const logsWithStepName = newLogs.map(log => ({
                                ...log,
                                step_name: stepName,
                                message: log.text || log.message // Ensure message field is set for flat view
                            }));
                            this.jobLogs[managerId].push(...logsWithStepName);

                            console.log('[Queue] Loaded', newLogs.length, 'logs for step', stepName);
                        } catch (err) {
                            console.error('[Queue] Error fetching step events:', err);
                        } finally {
                            this._stepEventFetchInFlight.delete(stepJobId);
                        }
                    }

                    // Clear finished markers for processed step IDs
                    if (this._pendingStepIdsFinished) {
                        for (const stepJobId of stepIds) {
                            this._pendingStepIdsFinished.delete(stepJobId);
                        }
                    }

                    this.throttledRenderJobs();
                },

                // Update manager progress from manager_progress WebSocket event (from ManagerMonitor)
                // Managers are job type="manager" that orchestrate steps
                updateManagerProgress(progress) {
                    const managerIndex = this.allJobs.findIndex(j => j.id === progress.manager_id);
                    if (managerIndex < 0) {
                        return; // Manager not in current view
                    }

                    const manager = this.allJobs[managerIndex];

                    // Update manager status
                    if (progress.status) {
                        manager.status = progress.status;
                    }

                    // Update document count
                    if (progress.document_count !== undefined) {
                        manager.document_count = progress.document_count;
                    }

                    // Store step progress in metadata
                    if (!manager.metadata) {
                        manager.metadata = {};
                    }
                    manager.metadata.total_steps = progress.total_steps || 0;
                    manager.metadata.completed_steps = progress.completed_steps || 0;
                    manager.metadata.running_steps = progress.running_steps || 0;
                    manager.metadata.pending_steps = progress.pending_steps || 0;
                    manager.metadata.total_jobs = progress.total_jobs || 0;
                    manager.metadata.completed_jobs = progress.completed_jobs || 0;
                    manager.metadata.failed_jobs = progress.failed_jobs || 0;

                    // Update status_report with progress text
                    if (!manager.status_report) {
                        manager.status_report = {};
                    }
                    manager.status_report.progress_text = `${progress.completed_steps || 0}/${progress.total_steps || 0} steps, ${progress.completed_jobs || 0}/${progress.total_jobs || 0} jobs`;

                    // Re-render to show updated progress (throttled)
                    this.throttledRenderJobs();
                },

                // Handle unified job_update events for real-time UI status sync
                // This is the primary mechanism for step status updates
                // Logs are streamed via SSE, not triggered by status updates
                // context: "job" for overall job status, "job_step" for step-level status
                async handleJobUpdate(update) {
                    const { context, job_id, step_name, status } = update;

                    if (context === 'job') {
                        // Update overall job status
                        const jobIndex = this.allJobs.findIndex(j => j.id === job_id);
                        if (jobIndex >= 0) {
                            this.allJobs[jobIndex].status = status;
                            console.log('[Queue] Updated job status:', job_id.substring(0, 8), '->', status);

                            // Auto-expand parent job if it starts running (real-time)
                            if (status === 'running') {
                                // If not explicit expanded (meaning collapsed is true or undefined and default is true - wait, default is false(expanded)?)
                                // No, I treat collapsedJobs as: True=Collapsed, False=Expanded.
                                // If I want to Expand, I set it to False.
                                if (this.isJobStepsCollapsed(job_id)) {
                                    this.collapsedJobs[job_id] = false;
                                    this.loadJobTreeData(job_id);
                                } else if (!this.jobTreeData[job_id]) {
                                    // Even if expanded, ensure data is loaded
                                    this.loadJobTreeData(job_id);
                                }
                            }
                        }
                    } else if (context === 'job_step' && step_name) {
                        // Queue expansion for when tree data loads if not yet available
                        // Per QUEUE_UI.md: "ALL steps should auto-expand when they start running"
                        if (status === 'running' || status === 'completed' || status === 'failed') {
                            if (!this._pendingStepExpansions[job_id]) {
                                this._pendingStepExpansions[job_id] = new Set();
                            }
                            this._pendingStepExpansions[job_id].add(step_name);
                        }

                        // Update step status in tree view data (immutable for Alpine reactivity)
                        if (this.jobTreeData[job_id]) {
                            const treeData = this.jobTreeData[job_id];
                            if (treeData.steps) {
                                const stepIdx = treeData.steps.findIndex(s => s.name === step_name);
                                if (stepIdx >= 0) {
                                    const oldStatus = treeData.steps[stepIdx].status;

                                    // Auto-expand running/completed/failed steps ALWAYS (even if status same)
                                    // Handle race condition where step completes before tree loads
                                    if (status === 'running' || status === 'completed' || status === 'failed') {
                                        const treeStepKey = `${job_id}:${stepIdx}`;
                                        if (!this.jobTreeExpandedSteps[treeStepKey]) {
                                            console.log('[Queue] Auto-expanding step:', step_name, 'status:', status);
                                            this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [treeStepKey]: true };
                                        }
                                    }

                                    if (oldStatus !== status) {
                                        // Immutable update for step status
                                        const newSteps = [...treeData.steps];
                                        newSteps[stepIdx] = { ...newSteps[stepIdx], status: status };
                                        console.log('[Queue] Updated step status:', step_name, ':', oldStatus, '->', status);

                                        // Trigger reactive update with fully immutable data
                                        this.jobTreeData = {
                                            ...this.jobTreeData,
                                            [job_id]: { ...treeData, steps: newSteps }
                                        };
                                    }
                                }
                            }
                        }

                        // Also update step job in allJobs if it exists
                        const stepJobs = this.allJobs.filter(j =>
                            j.parent_id === job_id &&
                            j.metadata?.step_name === step_name
                        );
                        stepJobs.forEach(stepJob => {
                            stepJob.status = status;
                        });

                    }

                    // NOTE: refresh_logs check REMOVED - logs are now streamed via SSE
                    // Structure updates happen automatically through SSE status events

                    // Re-render to show updated status
                    this.throttledRenderJobs();
                },

                // Hydrate ALL step logs for a completed manager job so the UI reflects final totals.
                // This is intentionally used only on terminal manager completion to avoid flooding the UI during running jobs.
                // Fetch lightweight job structure for status updates
                async fetchJobStructure(jobId) {
                    try {
                        const response = await fetch(`/api/jobs/${jobId}/structure`);
                        if (!response.ok) return;

                        const structure = await response.json();

                        // Update job status
                        const jobIndex = this.allJobs.findIndex(j => j.id === jobId);
                        if (jobIndex >= 0) {
                            this.allJobs[jobIndex].status = structure.status;
                        }

                        // Update step statuses in tree view (immutable update for Alpine reactivity)
                        if (this.jobTreeData[jobId] && structure.steps) {
                            const treeData = this.jobTreeData[jobId];
                            if (treeData.steps) {
                                const newSteps = [...treeData.steps];
                                let hasChanges = false;
                                structure.steps.forEach(stepStatus => {
                                    const stepIdx = newSteps.findIndex(s => s.name === stepStatus.name);
                                    if (stepIdx >= 0) {
                                        const oldStatus = newSteps[stepIdx].status;
                                        if (oldStatus !== stepStatus.status) {
                                            // Immutable step update
                                            newSteps[stepIdx] = { ...newSteps[stepIdx], status: stepStatus.status };
                                            hasChanges = true;
                                            console.log('[Queue] fetchJobStructure updated step:', stepStatus.name, oldStatus, '->', stepStatus.status);
                                        }
                                        // Note: Log refreshes are handled by WebSocket refresh_logs handler
                                        // No need to trigger fetchStepLogs here - it would cause duplicate API calls
                                    }
                                });
                                // Trigger reactive update with immutable data
                                if (hasChanges) {
                                    this.jobTreeData = {
                                        ...this.jobTreeData,
                                        [jobId]: { ...treeData, steps: newSteps }
                                    };
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[Queue] Failed to fetch job structure:', error);
                    }
                },

                // Fetch logs for a specific step (with debouncing to prevent API flooding)
                // immediate=true bypasses debounce for status changes
                fetchStepLogs(jobId, stepName, stepIdx, immediate = false) {
                    const key = `${jobId}:${stepName}`;

                    // Skip if already fetching this step
                    if (this._stepFetchInFlight.has(key)) {
                        const inFlight = this._stepFetchPromises[key];
                        // For immediate requests (e.g., completion), chain a follow-up fetch so we can
                        // upgrade the request (larger limit) after the in-flight fetch finishes.
                        if (immediate && inFlight) {
                            const followUp = inFlight.then(() => this._doFetchStepLogs(jobId, stepName, stepIdx));
                            this._stepFetchPromises[key] = followUp;
                            return followUp;
                        }
                        return inFlight;
                    }

                    // Clear existing debounce timer for this step
                    if (this._stepFetchDebounceTimers[key]) {
                        clearTimeout(this._stepFetchDebounceTimers[key]);
                        delete this._stepFetchDebounceTimers[key];
                    }

                    // For immediate requests (status changes), fetch now
                    if (immediate) {
                        const promise = this._doFetchStepLogs(jobId, stepName, stepIdx);
                        this._stepFetchPromises[key] = promise;
                        return promise;
                    }

                    // Otherwise debounce - wait 1 second before fetching
                    this._stepFetchDebounceTimers[key] = setTimeout(() => {
                        delete this._stepFetchDebounceTimers[key];
                        const promise = this._doFetchStepLogs(jobId, stepName, stepIdx);
                        this._stepFetchPromises[key] = promise;
                    }, this._stepFetchDebounceMs);
                },

                // Internal: Actually perform the step logs fetch
                async _doFetchStepLogs(jobId, stepName, stepIdx) {
                    const key = `${jobId}:${stepName}`;

                    // Get step job ID from tree data - the API needs the step job ID, not parent job ID
                    // Check this BEFORE marking as in-flight to avoid orphaned entries
                    const treeData = this.jobTreeData[jobId];
                    const stepJobId = treeData?.steps?.[stepIdx]?.step_id;
                    if (!stepJobId) {
                        // Step hasn't started yet (no step job created) - nothing to fetch
                        // This is normal for pending steps, not an error
                        console.log('[Queue] No step_id yet for step', stepName, '- step pending');
                        return;
                    }

                    // Mark as in-flight AFTER validating we have a step_id
                    this._stepFetchInFlight.add(key);

                    try {
                        // Use step log limit for fetching - matches display limit to avoid wasteful fetches
                        const limit = this.getStepLogLimit(jobId, stepName);
                        const level = this.getTreeLogLevelFilter(jobId);
                        // Use unified /api/logs endpoint with step parameter for step-grouped results
                        const response = await fetch(`/api/logs?scope=job&job_id=${stepJobId}&step=${encodeURIComponent(stepName)}&limit=${limit}&level=${encodeURIComponent(level)}&order=desc`);
                        if (!response.ok) return;

                        const data = await response.json();
                        const stepLogs = data.steps?.find(s => s.step_name === stepName);

                        if (this.jobTreeData[jobId] && stepLogs?.logs) {
                            const treeData = this.jobTreeData[jobId];
                            if (treeData.steps && treeData.steps[stepIdx]) {
                                // Deep update to ensure Alpine detects array change
                                const newSteps = [...treeData.steps];
                                newSteps[stepIdx] = {
                                    ...newSteps[stepIdx],
                                    logs: stepLogs.logs,
                                    totalLogCount: stepLogs.total_count || stepLogs.logs.length, // Filtered count for pagination
                                    unfilteredLogCount: stepLogs.unfiltered_count || stepLogs.total_count || stepLogs.logs.length // ALL logs regardless of filter
                                };

                                this.jobTreeData = {
                                    ...this.jobTreeData,
                                    [jobId]: {
                                        ...treeData,
                                        steps: newSteps
                                    }
                                };
                            }
                        }
                    } catch (error) {
                        console.error('[Queue] Failed to fetch step logs:', error);
                    } finally {
                        // Clear in-flight flag
                        this._stepFetchInFlight.delete(key);
                        delete this._stepFetchPromises[key];
                    }
                },

                // Job steps collapse methods (hide/show step rows under parent job)
                toggleJobStepsCollapse(jobId) {
                    const newState = !this.collapsedJobs[jobId];
                    this.collapsedJobs = { ...this.collapsedJobs, [jobId]: newState };
                    console.log('[Queue] Toggled steps collapse for job', jobId.substring(0, 8), '- collapsed:', newState);
                    // Load tree data when expanding (not collapsed)
                    if (!newState && !this.jobTreeData[jobId]) {
                        this.loadJobTreeData(jobId);
                    } else if (!newState && this.jobTreeData[jobId]) {
                        // Re-connect SSE when expanding (if not already connected)
                        this.connectJobSSE(jobId);
                    } else if (newState) {
                        // Disconnect SSE when collapsing
                        this.disconnectJobSSE(jobId);
                    }
                    this.renderJobs();
                },

                isJobStepsCollapsed(jobId) {
                    return !!this.collapsedJobs[jobId];
                },

                // Inline tree view methods
                async loadJobTreeData(jobId) {
                    if (this.jobTreeLoading[jobId]) return;
                    console.log('[Queue] loadJobTreeData called for:', jobId.substring(0, 8));
                    this.jobTreeLoading = { ...this.jobTreeLoading, [jobId]: true };
                    try {
                        const response = await fetch(`/api/jobs/${jobId}/tree`);
                        if (!response.ok) throw new Error('Failed to load tree data');
                        const treeData = await response.json();
                        console.log('[Queue] loaded tree data for:', jobId.substring(0, 8), 'steps:', treeData.steps?.length);
                        this.jobTreeData = { ...this.jobTreeData, [jobId]: treeData };

                        // Auto-expand ALL steps with activity (running, completed, failed)
                        // Per QUEUE_UI.md: "ALL steps should auto-expand when they start running"
                        if (treeData.steps) {
                            // Get pending expansions that arrived before tree data loaded
                            const pendingExpansions = this._pendingStepExpansions[jobId] || new Set();

                            treeData.steps.forEach((step, idx) => {
                                const key = `${jobId}:${idx}`;
                                // Auto-expand ALL steps when tree loads (unless user explicitly collapsed).
                                // This prevents "fast step" races where a step completes before WS events arrive,
                                // and keeps the UI consistent: every step shows its logs by default.
                                if (this.jobTreeExpandedSteps[key] !== false) {
                                    this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [key]: true };
                                    console.log('[Queue] Auto-expanding step on tree load:', step.name, 'status:', step.status, 'wasPending:', pendingExpansions.has(step.name));
                                }

                                // Load initial logs - show at least 100 logs for better visibility
                                const limitKey = `${jobId}:${step.name}`;
                                if (!this.stepLogLimits[limitKey]) {
                                    this.stepLogLimits = { ...this.stepLogLimits, [limitKey]: 100 };
                                }
                                this.fetchStepLogs(jobId, step.name, idx, true);
                            });

                            // Clear pending expansions for this job
                            delete this._pendingStepExpansions[jobId];
                        }

                        // Connect SSE stream for real-time log updates
                        this.connectJobSSE(jobId);
                    } catch (error) {
                        console.error('[Queue] Failed to load job tree:', error);
                    } finally {
                        this.jobTreeLoading = { ...this.jobTreeLoading, [jobId]: false };
                    }
                },

                refreshJobTreeData(jobId) {
                    // Clear cache and reload
                    delete this.jobTreeData[jobId];
                    this.jobTreeData = { ...this.jobTreeData };
                    this.loadJobTreeData(jobId);
                },

                // SSE stream management for real-time log streaming
                connectJobSSE(jobId) {
                    // Skip if already connected
                    if (this.jobSSEConnected[jobId]) {
                        return;
                    }

                    // Check if QueueSSEManager is available
                    if (typeof QueueSSEManager === 'undefined') {
                        console.warn('[Queue] QueueSSEManager not loaded, skipping SSE connection');
                        return;
                    }

                    console.log('[Queue] Connecting SSE stream for job:', jobId.substring(0, 8));

                    const self = this;
                    QueueSSEManager.connectJob(jobId, {
                        limit: 100,
                        onLogs: (data) => {
                            self.handleSSELogs(jobId, data);
                        },
                        onStatus: (data) => {
                            self.handleSSEStatus(jobId, data);
                        },
                        onConnect: () => {
                            console.log('[Queue] SSE connected for job:', jobId.substring(0, 8));
                            self.jobSSEConnected = { ...self.jobSSEConnected, [jobId]: true };
                        },
                        onDisconnect: () => {
                            console.log('[Queue] SSE disconnected for job:', jobId.substring(0, 8));
                            self.jobSSEConnected = { ...self.jobSSEConnected, [jobId]: false };
                        },
                        onError: (err) => {
                            console.error('[Queue] SSE error for job:', jobId.substring(0, 8), err);
                        }
                    });
                },

                disconnectJobSSE(jobId) {
                    if (typeof QueueSSEManager !== 'undefined') {
                        console.log('[Queue] Disconnecting SSE stream for job:', jobId.substring(0, 8));
                        QueueSSEManager.disconnectJob(jobId);
                        this.jobSSEConnected = { ...this.jobSSEConnected, [jobId]: false };
                    }
                },

                // Handle incoming SSE log events
                handleSSELogs(jobId, data) {
                    console.log('[Queue] SSE handleSSELogs called for job:', jobId.substring(0, 8), 'raw data:', JSON.stringify(data).substring(0, 500));

                    if (!data.logs || !Array.isArray(data.logs) || data.logs.length === 0) {
                        console.log('[Queue] SSE no logs in data, returning early');
                        return;
                    }

                    console.log('[Queue] SSE processing', data.logs.length, 'logs');

                    // Group logs by step name
                    const logsByStep = {};
                    for (const log of data.logs) {
                        const stepName = log.step_name || 'unknown';
                        console.log('[Queue] SSE log entry:', { level: log.level, step_name: stepName, line_number: log.line_number, msg: log.message?.substring(0, 30) });
                        if (!logsByStep[stepName]) {
                            logsByStep[stepName] = [];
                        }
                        logsByStep[stepName].push(log);
                    }

                    console.log('[Queue] SSE logs grouped by step:', Object.keys(logsByStep), 'counts:', Object.fromEntries(Object.entries(logsByStep).map(([k,v]) => [k, v.length])));

                    // Update jobTreeData for each step
                    if (!this.jobTreeData[jobId]?.steps) {
                        console.log('[Queue] SSE no treeData for job:', jobId.substring(0, 8), 'available keys:', Object.keys(this.jobTreeData));
                        return;
                    }

                    const treeData = this.jobTreeData[jobId];
                    console.log('[Queue] SSE treeData has', treeData.steps.length, 'steps:', treeData.steps.map(s => s.name));
                    let hasChanges = false;

                    for (const [stepName, newLogs] of Object.entries(logsByStep)) {
                        const stepIdx = treeData.steps.findIndex(s => s.name === stepName);
                        console.log('[Queue] SSE matching step:', { stepName, stepIdx, treeSteps: treeData.steps.map(s => s.name) });

                        if (stepIdx < 0) {
                            console.warn('[Queue] SSE step NOT FOUND:', stepName, '- available steps:', treeData.steps.map(s => s.name));
                            continue;
                        }

                        const currentStep = treeData.steps[stepIdx];
                        const existingLogs = currentStep.logs || [];
                        console.log('[Queue] SSE current step has', existingLogs.length, 'existing logs');

                        // Merge new logs, avoiding duplicates using line_number as primary key
                        // line_number is server-assigned and unique per step
                        const existingLineNumbers = new Set(existingLogs.map(l => l.line_number).filter(n => n > 0));
                        const uniqueNewLogs = newLogs.filter(l => {
                            if (l.line_number > 0) {
                                return !existingLineNumbers.has(l.line_number);
                            }
                            // Fallback for logs without line_number (shouldn't happen with new backend)
                            return !existingLogs.some(e => e.timestamp === l.timestamp && e.message === l.message);
                        });
                        console.log('[Queue] SSE unique new logs:', uniqueNewLogs.length, 'of', newLogs.length, 'total');

                        if (uniqueNewLogs.length > 0) {
                            hasChanges = true;
                            const mergedLogs = [...existingLogs, ...uniqueNewLogs];
                            // Sort by line_number - server now provides sequential line numbers for all logs
                            mergedLogs.sort((a, b) => (a.line_number || 0) - (b.line_number || 0));

                            // Use highest line_number as total count (line numbers are sequential from 1)
                            // This gives real-time accurate count even when only a subset of logs is loaded
                            const maxLineNumber = Math.max(...mergedLogs.map(l => l.line_number || 0));
                            const realTimeTotal = Math.max(maxLineNumber, currentStep.totalLogCount || 0, mergedLogs.length);
                            console.log('[Queue] SSE merged logs:', { step: stepName, newCount: uniqueNewLogs.length, inMemory: mergedLogs.length, maxLineNum: maxLineNumber, realTimeTotal });

                            const newSteps = [...treeData.steps];
                            newSteps[stepIdx] = {
                                ...currentStep,
                                logs: mergedLogs,
                                // Use highest line_number as total (real-time accurate count)
                                totalLogCount: realTimeTotal
                            };
                            treeData.steps = newSteps;
                        } else {
                            console.log('[Queue] SSE all logs were duplicates for step:', stepName);
                        }
                    }

                    if (hasChanges) {
                        console.log('[Queue] SSE triggering Alpine reactivity update');
                        // Trigger Alpine reactivity
                        this.jobTreeData = { ...this.jobTreeData, [jobId]: { ...treeData } };
                    } else {
                        console.log('[Queue] SSE no changes to apply');
                    }
                },

                // Handle incoming SSE status events
                handleSSEStatus(jobId, data) {
                    if (data.steps && Array.isArray(data.steps) && this.jobTreeData[jobId]?.steps) {
                        const treeData = this.jobTreeData[jobId];
                        let hasChanges = false;

                        for (const stepStatus of data.steps) {
                            const stepIdx = treeData.steps.findIndex(s => s.name === stepStatus.name);
                            if (stepIdx >= 0 && treeData.steps[stepIdx].status !== stepStatus.status) {
                                hasChanges = true;
                                const newSteps = [...treeData.steps];
                                newSteps[stepIdx] = { ...newSteps[stepIdx], status: stepStatus.status };
                                treeData.steps = newSteps;
                            }
                        }

                        if (hasChanges) {
                            this.jobTreeData = { ...this.jobTreeData, [jobId]: { ...treeData } };
                        }
                    }
                },

                toggleTreeStep(jobId, stepIndex) {
                    const key = `${jobId}:${stepIndex}`;
                    const wasExpanded = this.jobTreeExpandedSteps[key];
                    this.jobTreeExpandedSteps = { ...this.jobTreeExpandedSteps, [key]: !wasExpanded };

                    // Per QUEUE_UI.md: fetch logs when expanding a step
                    if (!wasExpanded) {
                        const treeData = this.jobTreeData[jobId];
                        if (treeData?.steps?.[stepIndex]) {
                            const step = treeData.steps[stepIndex];
                            // Set initial log limit if not already set
                            const limitKey = `${jobId}:${step.name}`;
                            if (!this.stepLogLimits[limitKey]) {
                                this.stepLogLimits = { ...this.stepLogLimits, [limitKey]: 100 };
                            }
                            this.fetchStepLogs(jobId, step.name, stepIndex, true);
                        } else {
                            // Tree data not loaded yet - mark expansion as pending and load tree data
                            console.log('[Queue] toggleTreeStep: tree data not ready, loading for job:', jobId.substring(0, 8));
                            this._pendingStepExpansions = this._pendingStepExpansions || {};
                            this._pendingStepExpansions[jobId] = this._pendingStepExpansions[jobId] || new Set();
                            this._pendingStepExpansions[jobId].add(stepIndex);
                            this.loadJobTreeData(jobId);
                        }
                    }
                },

                isTreeStepExpanded(jobId, stepIndex) {
                    const key = `${jobId}:${stepIndex}`;
                    return !!this.jobTreeExpandedSteps[key];
                },

                // Check if logs are currently being fetched for a step
                // Used to show "Loading logs..." instead of "No logs for this step" during fetch
                isStepLogsLoading(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this._stepFetchInFlight.has(key) || !!this._stepFetchDebounceTimers[key];
                },

                getTreeSearchFilter(jobId) {
                    return this.jobTreeSearchFilter[jobId] || '';
                },

                setTreeSearchFilter(jobId, value) {
                    this.jobTreeSearchFilter = { ...this.jobTreeSearchFilter, [jobId]: value };
                },

                // Get the level filter for API calls (converts checkbox state to API level param)
                getTreeLogLevelFilter(jobId) {
                    const filters = this.treeLogLevelFilter[jobId] || this.getDefaultTreeLogLevelFilter();

                    const { debug, info, warn, error } = filters;
                    // If all are checked, return 'all'
                    if (debug && info && warn && error) return 'all';
                    // If only error is checked
                    if (!debug && !info && !warn && error) return 'error';
                    // If warn and error are checked (warn+)
                    if (!debug && !info && warn && error) return 'warn';
                    // If info, warn, error are checked (info+) - THIS IS THE DEFAULT
                    if (!debug && info && warn && error) return 'info';
                    // If debug and higher are checked
                    if (debug && info && warn && error) return 'all';
                    // Mixed selection - we need to pass specific levels
                    // For now, use 'all' and filter client-side
                    return 'all';
                },

                // Get checkbox state for a specific level
                getTreeLogLevelChecked(jobId, level) {
                    const filters = this.treeLogLevelFilter[jobId] || this.getDefaultTreeLogLevelFilter();
                    return filters[level] !== false;
                },

                // Default filter state: Info, Warn, Error enabled; Debug disabled
                getDefaultTreeLogLevelFilter() {
                    return { debug: false, info: true, warn: true, error: true };
                },

                // Toggle a specific log level checkbox
                toggleTreeLogLevel(jobId, level) {
                    const currentFilters = this.treeLogLevelFilter[jobId] || this.getDefaultTreeLogLevelFilter();
                    const newFilters = { ...currentFilters, [level]: !currentFilters[level] };
                    this.treeLogLevelFilter = { ...this.treeLogLevelFilter, [jobId]: newFilters };

                    console.log('[Queue] toggleTreeLogLevel:', level, '-> new filters:', newFilters);

                    // Refresh logs for all expanded steps from API with new filter
                    if (this.jobTreeData[jobId]?.steps) {
                        this.jobTreeData[jobId].steps.forEach((step, idx) => {
                            const key = `${jobId}:${idx}`;
                            if (this.jobTreeExpandedSteps[key]) {
                                console.log('[Queue] Refreshing step logs:', step.name, 'with level filter');
                                this.fetchStepLogs(jobId, step.name, idx, true);
                            }
                        });
                    }
                },

                // Check if all levels are selected (used for filter button highlight)
                isAllLevelsSelected(jobId) {
                    const filters = this.treeLogLevelFilter[jobId] || this.getDefaultTreeLogLevelFilter();
                    // All levels selected means debug, info, warn, error are all true
                    return filters.debug !== false && filters.info !== false && filters.warn !== false && filters.error !== false;
                },

                setTreeLogLevelFilter(jobId, level) {
                    this.treeLogLevelFilter = { ...this.treeLogLevelFilter, [jobId]: level };
                },

                // Default maximum logs to display per step in tree view (500 initially, +100 per "Show earlier logs" click)
                // Increased from 100 to 500 to reduce "Show earlier logs" clicks for high-volume steps
                defaultLogsPerStep: 500,
                // Per-step expanded log limits (key: jobId:stepName, value: current limit)
                stepLogLimits: {},
                // Loading state for step log fetching
                stepLogLoading: {},

                // Get current log limit for a step (defaults to defaultLogsPerStep)
                getStepLogLimit(jobId, stepName) {
                    const key = `${jobId}:${stepName}`;
                    return this.stepLogLimits[key] || this.defaultLogsPerStep;
                },

                getFilteredTreeLogs(logs, jobId, stepName) {
                    if (!logs) return [];
                    let filteredLogs = logs;

                    // Apply log level filter based on checkbox state (use default if not set)
                    const filters = this.treeLogLevelFilter[jobId] || this.getDefaultTreeLogLevelFilter();

                    // Get which levels are enabled
                    const enabledLevels = [];
                    if (filters.debug !== false) enabledLevels.push('debug');
                    if (filters.info !== false) enabledLevels.push('info');
                    if (filters.warn !== false) enabledLevels.push('warn');
                    if (filters.error !== false) enabledLevels.push('error');

                    // If not all levels are enabled, filter
                    if (enabledLevels.length < 4) {
                        filteredLogs = filteredLogs.filter(log => {
                            const normalizedLevel = this.normalizeLogLevel(log.level);
                            return enabledLevels.includes(normalizedLevel);
                        });
                    }

                    // Limit to step-specific limit (earliest-to-latest order, show most recent)
                    // Always apply limit regardless of job status to prevent DOM explosion
                    const limit = this.getStepLogLimit(jobId, stepName);
                    if (filteredLogs.length > limit) {
                        filteredLogs = filteredLogs.slice(-limit);
                    }

                    return filteredLogs;
                },

                // Get the starting log index for line numbers
                // Per QUEUE_LOGGING.md: "Log lines MUST start at line 1 (not 0, not 5)"
                // Always return 0 so line numbers are: 0 + logIdx + 1 = 1, 2, 3, ...
                getStepLogStartIndex(jobId, stepName, stepIndex) {
                    return 0;
                },

                // Download logs for a step as text file
                async downloadStepLogs(jobId, stepName, stepJobId) {
                    try {
                        // Get step job ID from tree data if not provided
                        if (!stepJobId && this.jobTreeData[jobId]) {
                            const step = this.jobTreeData[jobId].steps?.find(s => s.name === stepName);
                            stepJobId = step?.step_id;
                        }

                        if (!stepJobId) {
                            window.showNotification('Step job ID not found', 'error');
                            return;
                        }

                        // Fetch all logs including children (higher limit for download)
                        const level = this.getTreeLogLevelFilter(jobId);
                        const response = await fetch(`/api/logs?scope=job&job_id=${stepJobId}&include_children=true&limit=10000&order=asc&level=${encodeURIComponent(level)}`);
                        if (!response.ok) {
                            throw new Error(`Failed to fetch logs: ${response.status}`);
                        }

                        const data = await response.json();
                        const logs = data.logs || [];

                        if (logs.length === 0) {
                            window.showNotification('No logs to download', 'warning');
                            return;
                        }

                        // Format logs as text
                        const logText = logs.map((log, idx) => {
                            const timestamp = log.full_timestamp || log.timestamp || '';
                            const level = (log.level || 'info').toUpperCase().padEnd(5);
                            const message = log.message || log.text || '';
                            return `${idx + 1}. [${timestamp}] [${level}] ${message}`;
                        }).join('\n');

                        // Create and download file
                        const blob = new Blob([logText], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${stepName}-logs.txt`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        window.showNotification(`Downloaded ${logs.length} log entries`, 'success');
                    } catch (error) {
                        console.error('[Queue] Failed to download logs:', error);
                        window.showNotification('Failed to download logs: ' + error.message, 'error');
                    }
                },

                // Legacy compatibility - keep old functions
                hasEarlierLogs(logs, jobId) {
                    if (!logs) return false;
                    return logs.length > this.defaultLogsPerStep;
                },

                getEarlierLogsCount(logs, jobId) {
                    if (!logs) return 0;
                    return Math.max(0, logs.length - this.defaultLogsPerStep);
                },

                // Debounced parent refresh to reduce load under high child job churn
                debouncedRefreshParent(parentId) {
                    // Clear any existing timeout for this parent
                    if (this.parentRefreshTimeouts.has(parentId)) {
                        clearTimeout(this.parentRefreshTimeouts.get(parentId));
                    }

                    // Set new timeout to fetch parent after 400ms
                    const timeoutId = setTimeout(async () => {
                        try {
                            const parentResponse = await fetch(`/api/jobs/${parentId}`);
                            if (parentResponse.ok) {
                                const updatedParent = await parentResponse.json();

                                // Update parent in allJobs array
                                const parentIndex = this.allJobs.findIndex(j => j.id === parentId);
                                if (parentIndex >= 0) {
                                    this.allJobs[parentIndex] = updatedParent;
                                }

                                // Update parent in filteredJobs array if it exists there
                                const filteredParentIndex = this.filteredJobs.findIndex(j => j.id === parentId);
                                if (filteredParentIndex >= 0) {
                                    this.filteredJobs[filteredParentIndex] = updatedParent;
                                }

                                // Re-render to show updated parent stats
                                this.renderJobs();
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to update parent stats after child update:', error);
                        } finally {
                            // Remove timeout from map after execution
                            this.parentRefreshTimeouts.delete(parentId);
                        }
                    }, 400); // 400ms debounce window (within 300-500ms recommended range)

                    // Store timeout ID
                    this.parentRefreshTimeouts.set(parentId, timeoutId);
                },

                // Helper function to get the correct status badge HTML based on type
                getStatusBadgeHtml(type, status) {
                    // This method is now handled via separate functions for Alpine binding
                    return this.getStatusBadgeClass(type, status);
                },

                // Open error details modal
                openErrorDetailsModal(job) {
                    window.dispatchEvent(new CustomEvent('errorDetailsModal:open', {
                        detail: { job: job }
                    }));
                },

                // Navigate to job details page
                navigateToJobDetails(jobId) {
                    if (jobId) {
                        window.location.href = `/job?id=${jobId}`;
                    }
                },

                // Crawler-specific helper functions
                isCrawlerJob(job) {
                    return job && (job.job_type === 'crawler' || job.job_type === 'parent' ||
                        (job.config && (job.config.start_urls || job.config.seed_urls)) ||
                        job.seed_urls || job.source_type === 'crawler');
                },

                getCrawlerProgressText(job) {
                    if (!job) return 'No data';

                    const progress = job.progress || {};
                    const completed = progress.completed_urls || 0;
                    const total = progress.total_urls || 0;
                    const failed = progress.failed_urls || 0;

                    if (total === 0) {
                        return job.status === 'running' ? 'Starting...' : 'No URLs processed';
                    }

                    return `${completed} of ${total} URLs processed${failed > 0 ? ` (${failed} failed)` : ''}`;
                },

                getCrawlerProgressPercentage(job) {
                    if (!job || !job.progress) return 0;

                    const progress = job.progress;
                    const completed = progress.completed_urls || 0;
                    const total = progress.total_urls || 0;

                    if (total === 0) return 0;
                    return Math.round((completed / total) * 100);
                },

                getCrawlerProgressColor(job) {
                    if (!job) return '#e0e0e0';

                    const status = job.status;
                    const progress = job.progress || {};
                    const failed = progress.failed_urls || 0;
                    const total = progress.total_urls || 0;

                    if (status === 'failed') return '#ef4444';
                    if (status === 'completed') return '#10b981';
                    if (status === 'running') return '#3b82f6';
                    if (failed > 0 && total > 0 && (failed / total) > 0.1) return '#f59e0b'; // Warning if >10% failed

                    return '#3b82f6';
                },

                getCrawlerStat(job, statName) {
                    if (!job) return 0;

                    // Check progress object first
                    if (job.progress && job.progress[statName] !== undefined) {
                        return job.progress[statName];
                    }

                    // Check status_report object
                    if (job.status_report && job.status_report[statName] !== undefined) {
                        return job.status_report[statName];
                    }

                    // Handle specific stat mappings
                    switch (statName) {
                        case 'links_found':
                            return job.progress?.total_urls || job.status_report?.total_urls || 0;
                        case 'links_filtered':
                            return job.progress?.filtered_urls || job.status_report?.filtered_urls || 0;
                        case 'links_followed':
                            return job.progress?.completed_urls || job.status_report?.completed_urls || 0;
                        case 'max_depth':
                            return job.config?.max_depth || job.progress?.max_depth || job.status_report?.max_depth || 1;
                        default:
                            return 0;
                    }
                }
            }));

            // Register deleteConfirmModal component
            Alpine.data('deleteConfirmModal', () => ({
                jobs: [],
                totalChildren: 0,
                checkboxChecked: false,
                resolvePromise: null,
                currentResolverId: null,

                init() {
                    // Listen for deleteConfirmModal:open events
                    window.addEventListener('deleteConfirmModal:open', async (e) => {
                        const { jobDetails, totalChildren, resolverId } = e.detail;
                        await this.open(jobDetails, totalChildren, resolverId);
                    });
                },

                async open(jobDetails, totalChildren, resolverId = null) {
                    // Use the pre-built job details passed from caller
                    this.jobs = jobDetails || [];
                    this.totalChildren = totalChildren || 0;

                    // Show modal
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');

                    // Create promise and store resolver
                    this.currentResolverId = resolverId;
                    return new Promise((resolve) => {
                        this.resolvePromise = resolve;
                        // Store resolver in global map if resolverId provided
                        if (resolverId && window.deleteModalResolvers) {
                            window.deleteModalResolvers.set(resolverId, resolve);
                        }
                    });
                },

                closeModal() {
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');

                    if (this.resolvePromise) {
                        this.resolvePromise(false);
                        this.resolvePromise = null;
                    }
                    // Clean up resolver from global map
                    if (this.currentResolverId && window.deleteModalResolvers) {
                        window.deleteModalResolvers.delete(this.currentResolverId);
                        this.currentResolverId = null;
                    }

                    // Clear data after resolving to prevent race condition with modal message
                    this.checkboxChecked = false;
                    this.jobs = [];
                    this.totalChildren = 0;
                },

                confirm() {
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');

                    if (this.resolvePromise) {
                        this.resolvePromise(true);
                        this.resolvePromise = null;
                    }
                    // Clean up resolver from global map
                    if (this.currentResolverId && window.deleteModalResolvers) {
                        window.deleteModalResolvers.delete(this.currentResolverId);
                        this.currentResolverId = null;
                    }

                    // Clear data after resolving to prevent race condition with modal message
                    this.checkboxChecked = false;
                    this.jobs = [];
                    this.totalChildren = 0;
                },

                getStatusDisplayText(status) {
                    const statusTexts = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return statusTexts[status] || 'Unknown';
                },

                getStatusBadgeClass(status) {
                    const badgeClasses = {
                        'pending': 'label-warning',
                        'running': 'label-primary',
                        'completed': 'label-success',
                        'failed': 'label-error',
                        'cancelled': 'label'
                    };
                    return badgeClasses[status] || 'label';
                }
            }));

            // Register errorDetailsModal component
            Alpine.data('errorDetailsModal', () => ({
                job: null,

                init() {
                    // Listen for errorDetailsModal:open events
                    window.addEventListener('errorDetailsModal:open', async (e) => {
                        const { job } = e.detail;
                        await this.open(job);
                    });
                },

                async open(job) {
                    this.job = job;
                    const modal = document.getElementById('error-details-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');
                },

                closeModal() {
                    const modal = document.getElementById('error-details-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');
                    this.job = null;
                },

                getStatusDisplayText(status) {
                    const statusTexts = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return statusTexts[status] || 'Unknown';
                },

                getStatusBadgeClass(status) {
                    const badgeClasses = {
                        'pending': 'label-warning',
                        'running': 'label-primary',
                        'completed': 'label-success',
                        'failed': 'label-error',
                        'cancelled': 'label'
                    };
                    return badgeClasses[status] || 'label';
                },

                getJobURL(job) {
                    if (!job) return null;
                    // Priority: seed_urls > current_url
                    if (job.seed_urls && job.seed_urls.length > 0) {
                        return job.seed_urls[0];
                    }
                    if (job.progress?.current_url) {
                        return job.progress.current_url;
                    }
                    return null;
                }
            }));
        });

        // Window helper function - dispatches event to Alpine component
        function deleteSelectedJobs() {
            window.dispatchEvent(new CustomEvent('jobList:deleteSelected'));
        }

        // Global function to open delete confirmation modal using event-based API
        async function openDeleteConfirmModal(jobDetails, totalChildren) {
            const resolverId = 'delete-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            return new Promise((resolve) => {
                window.deleteModalResolvers.set(resolverId, resolve);
                window.dispatchEvent(new CustomEvent('deleteConfirmModal:open', {
                    detail: { jobDetails: jobDetails, totalChildren: totalChildren, resolverId: resolverId }
                }));
            });
        }

        // Initialize highlight.js - only for job detail
        if (typeof hljs !== 'undefined') {
            const codeBlock = document.querySelector('#job-detail-json code');
            if (codeBlock) {
                hljs.highlightElement(codeBlock);
            }
        }
    </script>
</body>

</html>