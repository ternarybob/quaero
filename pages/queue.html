<!DOCTYPE html>
<html lang="en">

<head>
    {{template "head.html" .}}
    <title>Queue Management - Quaero</title>
</head>

<body>

    {{template "navbar.html" .}}

    <main class="page-container">

        <!-- Page Title -->
        <div class="page-title">
            <h1>Queue Management</h1>
            <p>Monitor and manage running crawler jobs</p>
            <div class="text-small text-gray" style="margin-top: 0.5rem;">
                <i class="fa-solid fa-lightbulb"></i>
                To create or edit job definitions, visit the <a href="/jobs">Jobs</a> page
            </div>
        </div>

        <!-- Job Statistics -->
        <section x-data="jobStatsHeader" x-init="init()">
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Statistics</h3>
                        </section>
                        <section class="navbar-section">
                            <button class="btn btn-sm" @click="loadStats()">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body">
                    <div class="columns">
                        <div class="column text-center">
                            <p class="text-small text-gray">TOTAL JOBS</p>
                            <p class="h2" x-text="totalJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">PENDING</p>
                            <p class="h2 text-warning" x-text="pendingJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">RUNNING</p>
                            <p class="h2 text-primary" x-text="runningJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">COMPLETED</p>
                            <p class="h2 text-success" x-text="completedJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">FAILED</p>
                            <p class="h2 text-error" x-text="failedJobs"></p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">CANCELLED</p>
                            <p class="h2 text-warning" x-text="cancelledJobs"></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Job Queue -->
        <section>
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Queue</h3>
                        </section>
                        <section class="navbar-section">
                            <button class="btn btn-sm" onclick="event.preventDefault(); window.dispatchEvent(new CustomEvent('jobList:load'))" title="Refresh Jobs">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                            <button id="delete-selected-btn" class="btn btn-sm btn-error" onclick="deleteSelectedJobs()" title="Delete Selected" style="display: none; margin-left: 0.5rem;">
                                <i class="fa-solid fa-trash"></i>
                                <span id="delete-selected-text">Delete Selected</span>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body" x-data="jobList" x-init="init()">
                    <!-- Filter Button and Chips -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <button type="button" class="btn btn-sm" onclick="showFilterModal()">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                        <div id="filter-chips-container"></div>
                    </div>

                    <!-- Select All Checkbox -->
                    <div style="margin-bottom: 0.8rem;">
                        <label class="form-checkbox">
                            <input type="checkbox" id="select-all-checkbox" @change="toggleSelectAll()">
                            <i class="form-icon"></i> Select All
                        </label>
                    </div>

                    <!-- Error Display -->
                    <template x-if="loadError">
                        <div class="toast toast-error" style="margin-bottom: 1rem; padding: 1rem; border: 1px solid #ef4444; border-radius: 4px;">
                            <i class="fas fa-exclamation-circle"></i>
                            <span x-text="'Failed to load jobs: ' + loadError"></span>
                            <button class="btn btn-sm btn-primary" @click="retryLoadJobs()" style="margin-left: 1rem;">
                                <i class="fas fa-redo"></i> Retry
                            </button>
                            <span x-show="retryCount > 0" x-text="'(Attempt ' + retryCount + '/' + maxRetries + ')'" style="margin-left: 0.5rem; font-size: 0.85rem;"></span>
                        </div>
                    </template>

                    <!-- Stale Data Indicator -->
                    <template x-if="loadError && lastSuccessfulJobs.length > 0">
                        <div class="toast toast-warning" style="margin-bottom: 1rem; padding: 0.75rem; border: 1px solid #fbbf24; border-radius: 4px; background-color: #fef3c7;">
                            <i class="fas fa-exclamation-triangle" style="color: #92400e;"></i>
                            <span style="color: #92400e; margin-left: 0.5rem;">Showing cached data. Data may be
                                outdated.</span>
                            <button class="btn btn-sm" @click="retryLoadJobs()" style="margin-left: 1rem;">
                                <i class="fas fa-redo"></i> Refresh
                            </button>
                        </div>
                    </template>

                    <!-- Last Update Time -->
                    <div x-show="lastUpdateTime" style="margin-bottom: 0.5rem; font-size: 0.8rem; color: #666;">
                        <i class="fas fa-clock"></i>
                        <span x-text="'Last updated: ' + formatTimeSince(lastUpdateTime)"></span>
                    </div>

                    <!-- Jobs Cards Container -->
                    <div id="jobs-cards-container">
                        <template x-for="item in itemsToRender" :key="item.job.id + (item.type || 'flat')">
                            <div>
                                <!-- Loading indicator for expanding parents -->
                                <template x-if="item.type === 'loading'">
                                    <div class="loading-children" style="margin-left: 2rem; margin-bottom: 0.8rem; padding: 0.5rem; color: #888;">
                                        <i class="fas fa-spinner fa-pulse"></i>
                                        <span>Loading children...</span>
                                    </div>
                                </template>

                                <!-- Job card -->
                                <template x-if="item.type !== 'loading'">
                                    <div class="card job-card-clickable" :class="{
                                            'bg-gray': selectedJob && selectedJob.id === item.job.id,
                                            'job-card-parent': item.type === 'parent',
                                            'job-card-child': item.type === 'child',
                                            'job-card-flat': item.type === 'flat'
                                        }" style="margin-bottom: 0.8rem; cursor: pointer;" :data-job-id="item.job.id" @click="navigateToJobDetails(item.job.id)">
                                        <div class="card-body">
                                            <div class="columns" style="gap: 0.5rem;">
                                                <!-- Left side: Checkbox and Content -->
                                                <div class="column col-auto" @click.stop style="padding-right: 0;">
                                                    <label class="form-checkbox" style="margin: 0;">
                                                        <input type="checkbox" class="job-checkbox" :data-job-id="item.job.id" @change="toggleJobSelection(item.job.id)" :checked="selectedJobIds.has(item.job.id)">
                                                        <i class="form-icon"></i>
                                                    </label>
                                                </div>
                                                <div class="column col-9" style="padding-left: 0;">
                                                    <div class="card-title h5" :title="'Job ID: ' + (item.job.id || 'N/A')">
                                                        <!-- Expand/Collapse button for parent jobs with children -->
                                                        <template x-if="item.type === 'parent' && item.job.child_count > 0">
                                                            <button class="expand-collapse-btn" @click.stop="toggleParentExpansion(item.job.id)" :class="item.isExpanded ? 'expanded' : ''"
                                                                :title="item.isExpanded ? 'Collapse children' : 'Expand children'">
                                                                <i class="fas fa-chevron-right"></i>
                                                            </button>
                                                        </template>
                                                        <i class="fas" :class="{
                                                    'fa-file job-type-icon child-icon': item.type === 'child',
                                                    'fa-folder job-type-icon parent-icon': item.type === 'parent'
                                                }"></i>
                                                        <span x-text="item.job.name || ('Job ' + (item.job.id ? item.job.id.substring(0, 8) : 'N/A'))" :style="item.type === 'parent' ? 'font-size: 1.2rem; font-weight: 600;' : ''"></span>
                                                        <span class="text-gray" style="font-size: 0.8rem; font-weight: normal;">
                                                            (<span x-text="item.job.id ? item.job.id.substring(0, 8) : 'N/A'"></span>)
                                                        </span>
                                                        <template x-if="item.type === 'parent'">
                                                            <span class="parent-job-badge">PARENT</span>
                                                        </template>
                                                        <template x-if="item.type === 'parent' && item.job.entity_type === 'job_definition'">
                                                            <span class="label label-info" style="margin-left: 0.5rem; font-size: 0.7rem;">JOB
                                                                DEFINITION</span>
                                                        </template>
                                                    </div>
                                                    <!-- Source field removed - redundant for parent jobs -->

                                                    <!-- URL Display for Crawler Jobs -->
                                                    <template x-if="item.job.seed_urls && item.job.seed_urls.length > 0">
                                                        <div style="margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: #555;">
                                                            <i class="fas fa-link" style="color: #3b82f6;"></i>
                                                            <a :href="item.job.seed_urls[0]" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;" @click.stop>
                                                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 600px;" :title="item.job.seed_urls[0]" x-text="item.job.seed_urls[0]"></span>
                                                                <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                                            </a>
                                                            <template x-if="item.job.seed_urls.length > 1">
                                                                <span class="text-gray" style="font-size: 0.8rem; margin-left: 0.5rem;" x-text="'+' + (item.job.seed_urls.length - 1) + ' more'"></span>
                                                            </template>
                                                        </div>
                                                    </template>
                                                    <template x-if="(!item.job.seed_urls || item.job.seed_urls.length === 0) && item.job.progress && item.job.progress.current_url">
                                                        <div style="margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: #555;">
                                                            <i class="fas fa-link" style="color: #3b82f6;"></i>
                                                            <a :href="item.job.progress.current_url" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;" @click.stop>
                                                                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 600px;" :title="item.job.progress.current_url" x-text="item.job.progress.current_url"></span>
                                                                <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                                            </a>
                                                        </div>
                                                    </template>

                                                    <!-- Metadata -->
                                                    <div style="margin-top: 0.8rem; display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem;">
                                                        <!-- Status Badge -->
                                                        <div>
                                                            <span class="label" :class="getStatusBadgeClass(item.type, item.job.status, item.job)">
                                                                <i class="fas" :class="getStatusIcon(item.type === 'parent' && item.job.child_count > 0 ? deriveParentStatus(item.job).status : item.job.status)" style="margin-right: 0.25rem;"></i>
                                                                <span x-text="getStatusBadgeText(item.type, item.job.status, item.job)"></span>
                                                            </span>
                                                        </div>
                                                        <!-- Job Type Badge -->
                                                        <template x-if="item.job.job_type && item.job.job_type !== 'parent'">
                                                            <div>
                                                                <span class="label" :class="window.getJobTypeBadgeClass(item.job.job_type)" :title="window.getJobTypeDisplayName(item.job.job_type)">
                                                                    <i class="fas" :class="window.getJobTypeIcon(item.job.job_type)"></i>
                                                                    <span x-text="window.getJobTypeDisplayName(item.job.job_type)"></span>
                                                                </span>
                                                            </div>
                                                        </template>
                                                        <!-- Documents -->
                                                        <div>
                                                            <i class="fas fa-file-alt"></i>
                                                            <span x-text="(() => { const count = getDocumentsCount(item.job); return (typeof count === 'number' ? count : 'N/A') + ' Documents'; })()"></span>
                                                        </div>
                                                        <!-- Created Time -->
                                                        <div>
                                                            <i class="fas fa-calendar"></i>
                                                            <span x-text="'created: ' + getCreatedDate(item.job)"></span>
                                                        </div>
                                                        <!-- Started Time -->
                                                        <template x-if="item.job.started_at">
                                                            <div>
                                                                <i class="fas fa-clock"></i>
                                                                <span x-text="'started: ' + getStartedDate(item.job)"></span>
                                                            </div>
                                                        </template>
                                                        <!-- Finished Time -->
                                                        <template x-if="item.job.finished_at">
                                                            <div>
                                                                <i class="fas fa-check-circle"></i>
                                                                <span x-text="'finished: ' + getFinishedDate(item.job)"></span>
                                                            </div>
                                                        </template>
                                                        <!-- Toggle JSON -->
                                                        <div>
                                                            <a href="#" class="text-primary" @click.prevent.stop="toggleJobJson('job-json-' + $id(item.job.id))">
                                                                <i class="fas fa-code"></i> Show Configuration
                                                            </a>
                                                        </div>
                                                    </div>

                                                    <!-- Failure Reason Display -->
                                                    <template x-if="item.job.status === 'failed' && item.job.error">
                                                        <div class="job-error-alert" style="margin-top: 0.8rem; padding: 0.75rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-size: 0.875rem;">
                                                            <i class="fas fa-exclamation-circle" style="color: var(--color-danger); margin-right: 0.5rem;"></i>
                                                            <strong>Failure Reason:</strong>
                                                            <span x-show="item.job.error.length <= 100" x-text="item.job.error"></span>
                                                            <span x-show="item.job.error.length > 100">
                                                                <span x-text="item.job.error.substring(0, 100) + '...'"></span>
                                                                <a href="#" class="text-primary" @click.prevent="openErrorDetailsModal(item.job)" style="margin-left: 0.5rem;">[View Details]</a>
                                                            </span>
                                                        </div>
                                                    </template>

                                                    <!-- Parent progress display from backend status_report -->
                                                    <template x-if="item.type === 'parent'">
                                                        <div class="parent-progress-container">
                                                            <!-- Enhanced Crawler Progress Display (Inline) -->
                                                            <template x-if="isCrawlerJob(item.job)">
                                                                <div class="crawler-progress-inline" style="margin-top: 0.8rem;">
                                                                    <!-- Progress Text Inline -->
                                                                    <div style="display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem; align-items: center;">
                                                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                                            <i class="fas fa-tasks" style="color: #666;"></i>
                                                                            <span x-text="getCrawlerProgressText(item.job)" style="font-weight: 500;"></span>
                                                                        </div>
                                                                        <template x-if="item.job.progress || item.job.status_report">
                                                                            <div style="display: flex; align-items: center; gap: 1rem; font-size: 0.75rem; color: #666;">
                                                                                <span>
                                                                                    <i class="fas fa-link" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_found') || '0'"></span>
                                                                                    found
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-filter" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_filtered') || '0'"></span>
                                                                                    filtered
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-arrow-right" style="margin-right: 0.25rem;"></i>
                                                                                    <span x-text="getCrawlerStat(item.job, 'links_followed') || '0'"></span>
                                                                                    followed
                                                                                </span>
                                                                                <span>
                                                                                    <i class="fas fa-layer-group" style="margin-right: 0.25rem;"></i>
                                                                                    depth <span x-text="getCrawlerStat(item.job, 'max_depth') || '1'"></span>
                                                                                </span>
                                                                            </div>
                                                                        </template>
                                                                    </div>
                                                                </div>
                                                            </template>

                                                            <!-- Standard Progress Display for Non-Crawler Jobs -->
                                                            <template x-if="!isCrawlerJob(item.job)">
                                                                <div style="margin-top: 0.8rem; padding: 0.5rem; background-color: #f5f5f5; border-radius: 4px; font-size: 0.875rem;">
                                                                    <strong>Progress:</strong>
                                                                    <template x-if="item.job.status_report?.progress_text">
                                                                        <span x-text="item.job.status_report.progress_text"></span>
                                                                    </template>
                                                                    <template x-if="!item.job.status_report?.progress_text && item.job.child_count > 0">
                                                                        <span x-text="getChildJobsSummary(item.job.id)"></span>
                                                                    </template>
                                                                    <template x-if="!item.job.status_report?.progress_text && (!item.job.child_count || item.job.child_count === 0)">
                                                                        <span>No progress data</span>
                                                                    </template>
                                                                </div>
                                                            </template>

                                                            <!-- Errors from backend -->
                                                            <template x-if="item.job.status_report?.errors && item.job.status_report.errors.length > 0">
                                                                <div style="margin-top: 0.5rem; padding: 0.5rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-size: 0.875rem;">
                                                                    <strong style="color: var(--color-danger);"><i class="fas fa-exclamation-circle"></i>
                                                                        Errors:</strong>
                                                                    <ul style="margin: 0.25rem 0 0 1.5rem; padding: 0;">
                                                                        <template x-for="error in item.job.status_report.errors" :key="error">
                                                                            <li x-text="error"></li>
                                                                        </template>
                                                                    </ul>
                                                                </div>
                                                            </template>

                                                            <!-- Warnings from backend -->
                                                            <template x-if="item.job.status_report?.warnings && item.job.status_report.warnings.length > 0">
                                                                <div style="margin-top: 0.5rem; padding: 0.5rem; background-color: #fff3cd; border-left: 4px solid var(--color-warning); border-radius: 4px; font-size: 0.875rem;">
                                                                    <strong style="color: #856404;"><i class="fas fa-exclamation-triangle"></i>
                                                                        Warnings:</strong>
                                                                    <ul style="margin: 0.25rem 0 0 1.5rem; padding: 0;">
                                                                        <template x-for="warning in item.job.status_report.warnings" :key="warning">
                                                                            <li x-text="warning"></li>
                                                                        </template>
                                                                    </ul>
                                                                </div>
                                                            </template>

                                                            <!-- Spawned child jobs tree (if any) -->
                                                            <template x-if="item.isExpanded && childJobsList.has(item.job.id) && childJobsList.get(item.job.id).length > 0">
                                                                <div class="child-jobs-list-container" role="tree" aria-label="Spawned child jobs">
                                                                    <div class="child-jobs-list-header" style="display: flex; justify-content: space-between; align-items: center;">
                                                                        <span x-text="'Spawned Jobs (showing ' + getVisibleChildJobs(item.job.id).length + ' of ' + childJobsList.get(item.job.id).length + ')' "></span>
                                                                        <label class="form-checkbox" style="font-size: 0.8rem; margin: 0;">
                                                                            <input type="checkbox" :checked="hideCompletedChildren.has(item.job.id) ? hideCompletedChildren.get(item.job.id) : true" @change="toggleHideCompletedChildren(item.job.id)">
                                                                            <i class="form-icon"></i> Hide Completed
                                                                        </label>
                                                                    </div>
                                                                    <div class="child-jobs-tree">
                                                                        <template x-for="child in getVisibleChildJobs(item.job.id)" :key="child.id">
                                                                            <div class="tree-item" :class="'depth-' + child.depth" :style="'--depth: ' + child.depth" :class="{ 'tree-item-collapsed': isChildCollapsed(item.job.id, child) }"
                                                                                role="treeitem" :aria-level="child.depth + 1" :aria-expanded="mightHaveChildren(item.job.id, child) ? !isNodeCollapsed(item.job.id, child.id) : undefined"
                                                                                :aria-setsize="getVisibleTreeItems(item.job.id).length" :aria-posinset="getTreeItemIndex(item.job.id, child.id) + 1" tabindex="0"
                                                                                @keydown="handleTreeKeydown($event, item.job.id, child)" x-init="$nextTick(() => jobList.treeItemRefs.set(child.id, $el))"
                                                                                @destroy="jobList.treeItemRefs.delete(child.id)">

                                                                                <!-- Collapsible toggle (for items that might have children) -->
                                                                                <button x-show="mightHaveChildren(item.job.id, child)" class="tree-node-toggle" @click.stop="toggleNodeCollapse(item.job.id, child.id)"
                                                                                    :aria-label="isNodeCollapsed(item.job.id, child.id) ? 'Expand' : 'Collapse'" :class="{ 'rotated': !isNodeCollapsed(item.job.id, child.id) }">
                                                                                    <i class="fas fa-chevron-right" :class="{ 'rotated': !isNodeCollapsed(item.job.id, child.id) }"></i>
                                                                                </button>

                                                                                <!-- Status icon (replaces status badge) -->
                                                                                <i class="tree-status-icon" :class="[
                                                                             getStatusIcon(child.status),
                                                                             'status-' + child.status
                                                                           ]" :title="getStatusDisplayText(child.status)"></i>

                                                                                <!-- Job type icon (replaces job type badge) -->
                                                                                <template x-if="child.job_type">
                                                                                    <i class="fas tree-job-type-icon" :class="window.getJobTypeIcon(child.job_type)" :title="window.getJobTypeDisplayName(child.job_type)"></i>
                                                                                </template>

                                                                                <!-- URL (main content) - clickable link -->
                                                                                <a :href="child.url" target="_blank" rel="noopener noreferrer" class="tree-item-url" :title="child.url" @click.stop>
                                                                                    <span x-text="child.url"></span>
                                                                                    <i class="fas fa-external-link-alt" style="font-size: 0.6rem; margin-left: 0.25rem; opacity: 0.6;"></i>
                                                                                </a>

                                                                                <!-- Metadata (depth) -->
                                                                                <span class="tree-item-meta">
                                                                                    <span class="tree-item-depth" x-text="'D' + child.depth"></span>
                                                                                </span>

                                                                                <!-- Mini log viewer toggle -->
                                                                                <button class="btn btn-sm tree-log-toggle" @click.stop="toggleChildJobLog(item.job.id, child.id)"
                                                                                    :title="isChildLogExpanded(item.job.id, child.id) ? 'Hide logs' : 'Show logs'">
                                                                                    <i class="fas" :class="isChildLogExpanded(item.job.id, child.id) ? 'fa-chevron-up' : 'fa-file-lines'"></i>
                                                                                </button>
                                                                            </div>

                                                                            <!-- Mini log viewer (3 lines) -->
                                                                            <template x-if="isChildLogExpanded(item.job.id, child.id)">
                                                                                <div class="tree-item-logs" :style="'--depth: ' + child.depth">
                                                                                    <div class="mini-log-viewer">
                                                                                        <template x-if="childJobLogs.has(child.id) && childJobLogs.get(child.id).length > 0">
                                                                                            <div>
                                                                                                <template x-for="log in childJobLogs.get(child.id).slice(-3)" :key="log.id">
                                                                                                    <div class="log-line" :class="'log-' + log.level">
                                                                                                        <span class="log-time" x-text="formatLogTime(log.created_at)"></span>
                                                                                                        <span class="log-level" :class="'level-' + log.level" x-text="log.level.toUpperCase()"></span>
                                                                                                        <span class="log-message" x-text="log.message"></span>
                                                                                                    </div>
                                                                                                </template>
                                                                                            </div>
                                                                                        </template>
                                                                                        <template x-if="childJobLogsLoading.has(child.id) && childJobLogsLoading.get(child.id)">
                                                                                            <div class="loading-logs">
                                                                                                <i class="fas fa-spinner fa-pulse"></i> Loading logs...
                                                                                            </div>
                                                                                        </template>
                                                                                        <template
                                                                                            x-if="(!childJobLogsLoading.has(child.id) || !childJobLogsLoading.get(child.id)) && (!childJobLogs.has(child.id) || childJobLogs.get(child.id).length === 0)">
                                                                                            <div class="no-logs">
                                                                                                No logs available
                                                                                            </div>
                                                                                        </template>
                                                                                    </div>
                                                                                </div>
                                                                            </template>
                                                                        </template>
                                                                    </div>
                                                                    <!-- Load More Button -->
                                                                    <template x-if="(childJobsVisibleCount.get(item.job.id) || childJobsPageSize) < childJobsList.get(item.job.id).length">
                                                                        <div class="load-more-container" style="margin-top: 0.5rem;">
                                                                            <button class="btn btn-sm" @click.stop="loadMoreChildJobs(item.job.id)" style="font-size: 0.85rem;">
                                                                                Load More Jobs (showing <span x-text="visibleTreeItemCount(item.job.id)"></span>
                                                                                of <span x-text="childJobsList.get(item.job.id).length"></span>)
                                                                            </button>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                            </template>
                                                        </div>
                                                    </template>
                                                </div>

                                                <!-- Right side: Actions -->
                                                <div class="column col-2 text-right" style="flex-shrink: 0;" @click.stop>
                                                    <!-- Refresh button for parent jobs -->
                                                    <template x-if="item.type === 'parent'">
                                                        <button class="btn btn-sm" @click="refreshParentJob(item.job.id)" title="Refresh Job Stats">
                                                            <i class="fa-solid fa-sync"></i>
                                                        </button>
                                                    </template>
                                                    <button class="btn btn-sm" @click="openJobLogsModal(item.job.id)" title="View Logs">
                                                        <i class="fa-solid fa-file-lines"></i>
                                                    </button>
                                                    <template x-if="item.job.status !== 'running'">
                                                        <button class="btn btn-sm" @click="window.rerunJob(item.job.id, $event)" title="Copy Job and Add to Queue">
                                                            <i class="fa-solid fa-rotate-right"></i>
                                                        </button>
                                                    </template>
                                                    <template x-if="item.job.status === 'running'">
                                                        <button class="btn btn-sm btn-warning" @click="window.cancelJob(item.job.id, $event)" title="Cancel Job">
                                                            <i class="fas fa-stop"></i>
                                                        </button>
                                                    </template>
                                                    <template x-if="item.job.status !== 'running'">
                                                        <button class="btn btn-sm btn-error" @click="window.deleteJob(item.job.id, $event)" title="Delete Job">
                                                            <i class="fas fa-trash"></i>
                                                        </button>
                                                    </template>
                                                </div>
                                            </div>

                                            <!-- Job Configuration (Collapsible JSON) -->
                                            <div :id="'job-json-' + $id(item.job.id)" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                                                <pre
                                                    style="background-color: #ffffff; padding: 1rem; border: 1px solid #e0e0e0; border-radius: 4px; overflow-x: auto; max-height: 400px;"><code class="language-json" x-text="JSON.stringify(item.job, null, 2)"></code></pre>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </template>

                        <!-- No jobs message -->
                        <template x-if="itemsToRender.length === 0 && !isLoading && !loadError">
                            <div class="text-center text-gray" style="padding: 2rem;">
                                <span x-text="filteredJobs.length === 0 ? 'No jobs found matching the current filters.' : ''"></span>
                            </div>
                        </template>

                        <!-- Loading indicator when no jobs yet (initial load) -->
                        <template x-if="itemsToRender.length === 0 && isLoading && isInitialLoad">
                            <div class="text-center" style="padding: 2rem;">
                                <div class="loading loading-lg" style="margin-bottom: 1rem;"></div>
                                <span class="text-secondary">Loading jobs...</span>
                            </div>
                        </template>
                    </div>

                    <!-- Pagination Controls -->
                    <div id="job-pagination-container" class="pagination-container">
                        <!-- Pagination handled by separate function -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Service Logs -->
        <section>
            {{template "service-logs.html" .}}
        </section>

    </main>

    {{template "footer.html" .}}

    {{template "snackbar.html" .}}

    <!-- Filter Modal -->
    <div id="filter-modal" class="modal">
        <a href="#close" class="modal-overlay" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
                <div class="modal-title h5">Filter Crawler Jobs</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Status Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Status</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="pending" checked>
                            <i class="form-icon"></i> Pending
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="running" checked>
                            <i class="form-icon"></i> Running
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="completed" checked>
                            <i class="form-icon"></i> Completed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="failed" checked>
                            <i class="form-icon"></i> Failed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="cancelled" checked>
                            <i class="form-icon"></i> Cancelled
                        </label>
                    </div>

                    <!-- Source Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Source Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="jira">
                            <i class="form-icon"></i> Jira
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="confluence">
                            <i class="form-icon"></i> Confluence
                        </label>
                    </div>

                    <!-- Entity Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Entity Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="projects">
                            <i class="form-icon"></i> Projects
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="spaces">
                            <i class="form-icon"></i> Spaces
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="repos">
                            <i class="form-icon"></i> Repos
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" onclick="clearAllFilters()">Clear All</button>
                <button type="button" class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <!-- Job Logs Modal -->
    <div id="job-logs-modal" class="modal" x-data="jobLogsModal" x-init="init(); return () => destroy()">
        <a href="#close" class="modal-overlay" aria-label="Close" @click.prevent="closeModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true" style="max-width: 900px;">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" @click.prevent="closeModal()"></a>
                <div class="modal-title h5">Job Logs - <span x-text="currentJobId ? currentJobId.substring(0, 8) : 'N/A'"></span>
                    <span x-show="isStreaming" class="label label-success" style="margin-left: 0.5rem;">
                        <i class="fas fa-circle" style="animation: pulse 2s infinite;"></i> Live
                    </span>
                </div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Log Controls -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <select class="form-select select-sm log-level-filter" x-model="selectedLogLevel" @change="loadLogs()" title="Filter by log level">
                            <option value="all">All Levels</option>
                            <option value="error">Error</option>
                            <option value="warning">Warning</option>
                            <option value="info">Info</option>
                            <option value="debug">Debug</option>
                        </select>
                        <label class="form-checkbox">
                            <input type="checkbox" x-model="includeChildren" @change="loadLogs()">
                            <i class="form-icon"></i> Include Child Jobs
                        </label>
                        <button class="btn btn-sm" :class="selectedLogLevel === 'error' ? 'btn-error' : ''" @click="toggleErrorsOnly()" title="Toggle error logs only">
                            <i class="fas fa-exclamation-triangle"></i> Errors Only
                        </button>
                        <button class="btn btn-sm" @click="loadLogs()" title="Refresh Logs">
                            <i class="fa-solid fa-rotate-right"></i>
                        </button>
                        <button class="btn btn-sm" :class="autoScroll ? 'btn-primary' : ''" @click="toggleAutoScroll()" title="Toggle auto-scroll">
                            <i class="fas fa-arrow-down"></i> Auto-Scroll
                        </button>
                        <button class="btn btn-sm" @click="clearLogs()" title="Clear displayed logs">
                            <i class="fas fa-trash"></i> Clear
                        </button>
                        <button class="btn btn-sm" @click="downloadLogs()" title="Download logs as text file">
                            <i class="fas fa-download"></i> Download
                        </button>
                    </div>

                    <!-- Logs Terminal -->
                    <template x-if="loading">
                        <div class="text-center" style="padding: 2rem;">
                            <div class="loading loading-lg"></div>
                            <p class="text-secondary" style="margin-top: 1rem;">Loading logs...</p>
                        </div>
                    </template>

                    <template x-if="!loading">
                        <div class="terminal" x-ref="logContainer" @scroll="handleScroll()" style="max-height: 500px; overflow-y: auto;">
                            <template x-if="logs.length === 0">
                                <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                                    No logs available for this job
                                </div>
                            </template>
                            <template x-for="log in logs" :key="log.timestamp + log.message">
                                <div class="terminal-line">
                                    <span class="terminal-time" x-text="`[${log.timestamp}]`"></span>
                                    <span :class="log.levelClass" x-text="`[${log.level.toUpperCase()}]`"></span>
                                    <span x-show="log.job_name" class="terminal-job-context" x-text="`[${log.job_name}]`"></span>
                                    <span x-text="log.message"></span>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>
            <div class="modal-footer">
                <span class="text-secondary" style="margin-right: auto;" x-text="`${logs.length} logs displayed`"></span>
                <button type="button" class="btn" @click="closeModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="modal" x-data="deleteConfirmModal" x-init="init()">
        <a href="#close" class="modal-overlay" aria-label="Close" @click.prevent="closeModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true" style="max-width: 800px;">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" @click.prevent="closeModal()"></a>
                <div class="modal-title h5">Confirm Job Deletion</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Warning Message -->
                    <div class="toast toast-warning" style="margin-bottom: 1rem;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span x-text="`You are about to delete ${jobs.length} job${jobs.length > 1 ? 's' : ''}. This action cannot be undone.`"></span>
                    </div>

                    <!-- Cascade Warning -->
                    <template x-if="totalChildren > 0">
                        <div class="toast toast-error" style="margin-bottom: 1rem;">
                            <i class="fas fa-info-circle"></i>
                            <span x-text="`This will also delete ${totalChildren} child job${totalChildren > 1 ? 's' : ''}.`"></span>
                        </div>
                    </template>

                    <!-- Jobs Table -->
                    <div class="table-container" style="max-height: 300px; overflow-y: auto; margin-bottom: 1rem;">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Job ID</th>
                                    <th>Name</th>
                                    <th>Status</th>
                                    <th>Children</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="job in jobs" :key="job.id">
                                    <tr>
                                        <td>
                                            <code x-text="job.id.substring(0, 8)"></code>
                                        </td>
                                        <td x-text="job.name"></td>
                                        <td>
                                            <span class="label" :class="getStatusBadgeClass(job.status)">
                                                <span x-text="getStatusDisplayText(job.status)"></span>
                                            </span>
                                        </td>
                                        <td x-text="job.childCount"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>

                    <!-- Confirmation Checkbox -->
                    <div class="form-group">
                        <label class="form-checkbox">
                            <input type="checkbox" x-model="checkboxChecked">
                            <i class="form-icon"></i>
                            <span>I understand this action is permanent and cannot be undone</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" @click="closeModal()">Cancel</button>
                <button type="button" class="btn btn-error" :disabled="!checkboxChecked" @click="confirm()">
                    <i class="fas fa-trash"></i>
                    <span>Delete</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Error Details Modal -->
    <div id="error-details-modal" class="modal" x-data="errorDetailsModal" x-init="init()">
        <a href="#close" class="modal-overlay" aria-label="Close" @click.prevent="closeModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true" style="max-width: 800px;">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" @click.prevent="closeModal()"></a>
                <div class="modal-title h5">Error Details</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Job Context -->
                    <div class="form-group">
                        <label class="form-label"><strong>Job Information</strong></label>
                        <div style="padding: 0.75rem; background-color: #f5f5f5; border-radius: 4px; margin-bottom: 1rem;">
                            <div style="margin-bottom: 0.5rem;">
                                <strong>Job ID:</strong>
                                <code x-text="job ? job.id.substring(0, 8) : 'N/A'"></code>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job && job.name">
                                <strong>Name:</strong>
                                <span x-text="job ? job.name : ''"></span>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job">
                                <strong>Status:</strong>
                                <span>
                                    <span class="label" :class="job ? getStatusBadgeClass(job.status) : ''">
                                        <span x-text="job ? getStatusDisplayText(job.status) : ''"></span>
                                    </span>
                                </span>
                            </div>
                            <div style="margin-bottom: 0.5rem;" x-show="job && job.created_at">
                                <strong>Created:</strong>
                                <span x-text="job ? new Date(job.created_at).toLocaleString() : ''"></span>
                            </div>
                            <div x-show="job && getJobURL(job)">
                                <strong>URL:</strong>
                                <a :href="getJobURL(job)" target="_blank" rel="noopener noreferrer" class="text-primary" style="text-decoration: none;">
                                    <span x-text="getJobURL(job)"></span>
                                    <i class="fas fa-external-link-alt" style="font-size: 0.7rem; margin-left: 0.25rem;"></i>
                                </a>
                            </div>
                        </div>
                    </div>

                    <!-- Error Message -->
                    <div class="form-group">
                        <label class="form-label"><strong>Error Message</strong></label>
                        <div x-show="job && job.error" style="padding: 0.75rem; background-color: #f8d7da; border-left: 4px solid var(--color-danger); border-radius: 4px; font-family: monospace; white-space: pre-wrap; word-wrap: break-word;">
                            <span x-text="job ? job.error : ''"></span>
                        </div>
                        <div x-show="!job || !job.error" style="padding: 0.75rem; color: #666; font-style: italic;">
                            No error details available
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" @click="closeModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // State management (moved to Alpine component jobList)
        let allJobs = [];
        let filteredJobs = [];
        let selectedJob = null;

        // Hierarchy state management
        let expandedParents = new Set(); // Track expanded parent jobs

        // WebSocket connection state
        let jobsWS = null;
        let wsConnected = false;
        let wsReconnectAttempts = 0;
        let wsReconnecting = false; // Track reconnection state
        const WS_MAX_RECONNECT_DELAY = 30000; // 30 seconds
        const WS_INITIAL_RECONNECT_DELAY = 1000; // 1 second

        // Default filters - include all statuses
        const defaultFilters = {
            status: new Set(['pending', 'running', 'completed', 'failed', 'cancelled']),
            source: new Set(),
            entity: new Set()
        };

        // Filter state - initialize immediately with defaults to prevent undefined errors
        let activeFilters = {
            status: new Set(defaultFilters.status),
            source: new Set(defaultFilters.source),
            entity: new Set(defaultFilters.entity)
        };

        // Initialize filters immediately on script load
        window.activeFilters = activeFilters;

        // Modal resolver map for event-based API
        window.deleteModalResolvers = new Map();

        // Load filters from localStorage
        function loadFiltersFromStorage() {
            try {
                const stored = localStorage.getItem('quaero-job-filters');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    activeFilters.status = new Set(parsed.status || []);
                    activeFilters.source = new Set(parsed.source || []);
                    activeFilters.entity = new Set(parsed.entity || []);

                    // If no filters were saved, use defaults
                    if (activeFilters.status.size === 0 && activeFilters.source.size === 0 && activeFilters.entity.size === 0) {
                        activeFilters = {
                            status: new Set(defaultFilters.status),
                            source: new Set(defaultFilters.source),
                            entity: new Set(defaultFilters.entity)
                        };
                    }
                } else {
                    // Use defaults for first time users
                    activeFilters = {
                        status: new Set(defaultFilters.status),
                        source: new Set(defaultFilters.source),
                        entity: new Set(defaultFilters.entity)
                    };
                }
            } catch (error) {
                console.warn('Failed to load filters from localStorage:', error);
                // Use defaults on error
                activeFilters = {
                    status: new Set(defaultFilters.status),
                    source: new Set(defaultFilters.source),
                    entity: new Set(defaultFilters.entity)
                };
            }
        }

        // Save filters to localStorage
        function saveFiltersToStorage() {
            try {
                const toSave = {
                    status: Array.from(activeFilters.status),
                    source: Array.from(activeFilters.source),
                    entity: Array.from(activeFilters.entity)
                };
                localStorage.setItem('quaero-job-filters', JSON.stringify(toSave));
            } catch (error) {
                console.warn('Failed to save filters to localStorage:', error);
            }
        }

        // Load job statistics - now handled by Alpine component (kept for compatibility)
        function loadStats() {
            // Trigger stats recalculation from current job list
            window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
        }

        // Load all jobs - dispatches event to Alpine component
        function loadJobs() {
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Wrapper function for loadJobs() - maintains compatibility
        function loadJobQueue() {
            loadJobs();
        }


        // Update job in list from WebSocket update - dispatches event to Alpine component
        async function updateJobInList(update) {
            window.dispatchEvent(new CustomEvent('jobList:updateJob', { detail: update }));
        }

        // Get user-friendly display name for source type
        function getSourceTypeDisplay(sourceType) {
            const displayName = {
                'jira': 'Jira',
                'confluence': 'Confluence',
                'github': 'GitHub'
            };

            // Return the display name if available, otherwise show the raw source type
            if (sourceType && displayName[sourceType]) {
                return 'Source: ' + displayName[sourceType];
            }

            // For any other source type, just display it as-is
            return 'Source: ' + (sourceType || 'N/A');
        }

        // Check if job matches active filters
        function matchesActiveFilters(job) {
            // Check status filter
            if (activeFilters.status.size > 0 && !activeFilters.status.has(job.status)) {
                return false;
            }

            // Check source filter
            if (activeFilters.source.size > 0 && !activeFilters.source.has(job.source_type)) {
                return false;
            }

            // Check entity filter
            if (activeFilters.entity.size > 0 && !activeFilters.entity.has(job.entity_type)) {
                return false;
            }

            return true;
        }

        // Show filter modal
        function showFilterModal() {
            const modal = document.getElementById('filter-modal');

            // Sync modal checkboxes with activeFilters state
            document.querySelectorAll('.filter-status').forEach(checkbox => {
                checkbox.checked = activeFilters.status.has(checkbox.value);
            });
            document.querySelectorAll('.filter-source').forEach(checkbox => {
                checkbox.checked = activeFilters.source.has(checkbox.value);
            });
            document.querySelectorAll('.filter-entity').forEach(checkbox => {
                checkbox.checked = activeFilters.entity.has(checkbox.value);
            });

            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }

        // Close filter modal
        function closeFilterModal() {
            const modal = document.getElementById('filter-modal');
            modal.classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Apply filters from modal
        function applyFilters() {
            // Update activeFilters from modal checkboxes
            activeFilters.status.clear();
            document.querySelectorAll('.filter-status:checked').forEach(cb => {
                activeFilters.status.add(cb.value);
            });

            activeFilters.source.clear();
            document.querySelectorAll('.filter-source:checked').forEach(cb => {
                activeFilters.source.add(cb.value);
            });

            activeFilters.entity.clear();
            document.querySelectorAll('.filter-entity:checked').forEach(cb => {
                activeFilters.entity.add(cb.value);
            });

            // Save filters to localStorage
            saveFiltersToStorage();

            // Close modal and refresh
            closeFilterModal();
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Clear all filters
        function clearAllFilters() {
            // Uncheck all checkboxes in modal
            document.querySelectorAll('.filter-status, .filter-source, .filter-entity').forEach(cb => {
                cb.checked = false;
            });
        }

        // Render filter chips
        function renderFilterChips() {
            const container = document.getElementById('filter-chips-container');
            let html = '';

            // Status chips
            activeFilters.status.forEach(status => {
                const colorClass = {
                    'pending': 'label-warning',
                    'running': 'label-primary',
                    'completed': 'label-success',
                    'failed': 'label-error',
                    'cancelled': 'label-warning'
                }[status] || 'label-default';

                html += `
                    <span class="label ${colorClass}">
                        ${status.charAt(0).toUpperCase() + status.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('status', '${status}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Source chips
            activeFilters.source.forEach(source => {
                html += `
                    <span class="label label-primary">
                        ${source.charAt(0).toUpperCase() + source.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('source', '${source}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Entity chips
            activeFilters.entity.forEach(entity => {
                html += `
                    <span class="label label-primary">
                        ${entity.charAt(0).toUpperCase() + entity.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('entity', '${entity}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            container.innerHTML = html;
        }

        // Remove individual filter
        function removeFilter(category, value) {
            activeFilters[category].delete(value);
            saveFiltersToStorage(); // Save after removing filter
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Connect to WebSocket for real-time job updates
        function connectJobsWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            console.log('[Queue] Connecting to Jobs WebSocket:', wsUrl);
            jobsWS = new WebSocket(wsUrl);

            jobsWS.onopen = () => {
                console.log('[Queue] Jobs WebSocket connected');
                wsConnected = true;
                wsReconnecting = false;
                wsReconnectAttempts = 0;
                // Update queue stats header to show connected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: true, reconnecting: false }
                }));
                // Notify job logs modal that streaming is available
                window.dispatchEvent(new CustomEvent('jobLogs:streamingStateChange', {
                    detail: { isStreaming: true }
                }));
                console.log('[Queue] WebSocket reconnected successfully after', wsReconnectAttempts, 'attempts');
            };

            jobsWS.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // console.log(`[Queue] WebSocket message received, type: ${message.type}`);

                    // Handle queue stats updates and forward to queueStatsHeader component
                    if (message.type === 'queue_stats' && message.payload) {
                        window.dispatchEvent(new CustomEvent('queueStats:update', {
                            detail: {
                                pending: message.payload.pending_messages || 0,
                                inFlight: message.payload.in_flight_messages || 0,
                                workers: message.payload.concurrency || 0,
                                connected: true
                            }
                        }));
                    }

                    // Handle job status change events
                    if (message.type === 'job_status_change' && message.payload) {
                        const update = message.payload;
                        updateJobInList(update);
                        // Trigger stats recalculation from Alpine component
                        window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
                    }

                    // Handle job created events (future-proof)
                    if (message.type === 'job_created' && message.payload) {
                        updateJobInList(message.payload);
                        window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
                    }

                    // Handle job progress events
                    if (message.type === 'job_progress' && message.payload) {
                        updateJobInList(message.payload);
                    }

                    // Handle job completed events
                    if (message.type === 'job_completed' && message.payload) {
                        updateJobInList(message.payload);
                        window.dispatchEvent(new CustomEvent('jobList:recalculateStats'));
                    }

                    // Handle crawler job progress events (comprehensive parent-child stats)
                    if (message.type === 'crawler_job_progress' && message.payload) {
                        const progress = message.payload;
                        // Update job with comprehensive progress data
                        window.dispatchEvent(new CustomEvent('jobList:updateJobProgress', {
                            detail: progress
                        }));
                    }

                    // Handle job spawn events
                    if (message.type === 'job_spawn' && message.payload) {
                        const spawnData = message.payload;
                        // Dispatch event to Alpine component
                        window.dispatchEvent(new CustomEvent('jobList:childSpawned', {
                            detail: {
                                parent_job_id: spawnData.parent_job_id,
                                child_job_id: spawnData.child_job_id,
                                job_type: spawnData.job_type,
                                url: spawnData.url,
                                depth: spawnData.depth,
                                timestamp: spawnData.timestamp
                            }
                        }));
                    }

                    // Handle log events for job logs modal
                    if (message.type === 'log' && message.payload) {
                        const logData = message.payload;
                        // Dispatch to job logs modal if open
                        window.dispatchEvent(new CustomEvent('jobLogs:newLog', {
                            detail: logData
                        }));
                    }
                } catch (error) {
                    console.error('[Queue] Error parsing WebSocket message:', error);
                }
            };

            jobsWS.onerror = (error) => {
                console.error('[Queue] Jobs WebSocket error:', error.type, error.message);
                wsConnected = false;
                // Update queue stats header to show disconnected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: false }
                }));
            };

            jobsWS.onclose = () => {
                wsConnected = false;
                wsReconnecting = true;
                // Update queue stats header to show disconnected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: false, reconnecting: true }
                }));
                // Notify job logs modal that streaming is unavailable
                window.dispatchEvent(new CustomEvent('jobLogs:streamingStateChange', {
                    detail: { isStreaming: false }
                }));

                // Calculate exponential backoff delay
                const delay = Math.min(
                    WS_INITIAL_RECONNECT_DELAY * Math.pow(2, wsReconnectAttempts),
                    WS_MAX_RECONNECT_DELAY
                );
                wsReconnectAttempts++;

                console.log('[Queue] Jobs WebSocket disconnected, reconnecting in', delay, 'ms');
                console.log('[Queue] Reconnection attempt', wsReconnectAttempts, ', delay:', delay + 'ms');

                // Schedule reconnection
                setTimeout(() => {
                    connectJobsWebSocket();
                }, delay);
            };
        }

        // Render jobs - dispatches event to Alpine component
        function renderJobs() {
            window.dispatchEvent(new CustomEvent('jobList:render'));
        }

        // Custom pagination rendering - reads state from Alpine component
        function renderPagination(totalPages, currentPage) {
            const container = document.getElementById('job-pagination-container');
            if (!container) return;

            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let html = '<ul class="pagination">';

            // Previous button
            if (currentPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage - 1})">Previous</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Previous</a></li>';
            }

            // Page numbers (show max 7 pages)
            const maxVisible = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
            let endPage = Math.min(totalPages, startPage + maxVisible - 1);

            if (endPage - startPage < maxVisible - 1) {
                startPage = Math.max(1, endPage - maxVisible + 1);
            }

            if (startPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(1)">1</a></li>`;
                if (startPage > 2) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
            }

            for (let i = startPage; i <= endPage; i++) {
                if (i === currentPage) {
                    html += `<li class="page-item active"><a href="#">${i}</a></li>`;
                } else {
                    html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${i})">${i}</a></li>`;
                }
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${totalPages})">${totalPages}</a></li>`;
            }

            // Next button
            if (currentPage < totalPages) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage + 1})">Next</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Next</a></li>';
            }

            html += '</ul>';
            container.innerHTML = html;
        }

        // Pagination page change handler - dispatches event to Alpine component
        function changePage(pageNumber) {
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: pageNumber }
            }));
        }

        // Rerun a job
        async function rerunJob(jobId, evt) {
            if (!confirm(`Copy and queue job ${jobId.substring(0, 8)}?\n\nThis will create a NEW job (copy) with the same configuration and add it to the queue.\nThe job will NOT execute immediately - it will be queued as "pending".\nThe original job will remain unchanged.`)) {
                return;
            }

            // Get button reference from event
            const button = evt.target.closest('button');

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/rerun`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to rerun job');
                }

                const result = await response.json();
                const newJobIdShort = result.new_job_id.substring(0, 8);

                // Show clear notification about the NEW job queued
                window.showNotification(
                    `Job copied and added to queue!\n` +
                    `Original: ${jobId.substring(0, 8)}... (unchanged)\n` +
                    `New Job: ${newJobIdShort}... (pending in queue)`,
                    'success'
                );

                // Refresh stats immediately
                loadStats();

                // Wait a moment for the new job to be inserted, then refresh and highlight
                setTimeout(async () => {
                    await loadJobs();

                    // Try to find and highlight the new job row
                    const newJobRow = document.querySelector(`td[title="${result.new_job_id}"]`)?.closest('tr');
                    if (newJobRow) {
                        // Briefly highlight the new job with animation
                        newJobRow.style.backgroundColor = '#48c774';
                        newJobRow.style.transition = 'background-color 2s ease-out';
                        setTimeout(() => {
                            newJobRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }, 500);

            } catch (error) {
                console.error('Error rerunning job:', error);
                window.showNotification('Failed to rerun job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Cancel a running job
        async function cancelJob(jobId, evt) {
            if (!confirm(`Cancel job ${jobId.substring(0, 8)}?\n\nThe job will be stopped immediately.`)) {
                return;
            }

            // Get button reference from event
            const button = evt.target.closest('button');

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/cancel`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to cancel job');
                }

                window.showNotification('Job cancelled successfully', 'success');
                loadStats();
                // Note: loadJobs() removed - WebSocket will update job status automatically
            } catch (error) {
                console.error('Error cancelling job:', error);
                window.showNotification('Failed to cancel job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Delete a job
        async function deleteJob(jobId, evt) {
            // Get button reference from event
            const button = evt.target.closest('button');

            // Idempotency check - prevent double-clicks
            if (button && button.disabled) {
                return;
            }

            // Disable button immediately before confirmation
            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            // Show confirmation dialog
            if (!confirm(`Delete job ${jobId.substring(0, 8)}?\n\nThis will permanently remove the job from the database.`)) {
                // User cancelled - re-enable button
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
                return;
            }

            let deleteSuccess = false;
            try {
                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete job');
                }

                deleteSuccess = true;
                window.showNotification('Job deleted successfully', 'success');

                // Capture job information before removal for cleanup
                const jobIndex = allJobs.findIndex(job => job.id === jobId);
                const deletedJob = jobIndex >= 0 ? allJobs[jobIndex] : null;

                // Remove job from allJobs array
                const allJobsIndex = allJobs.findIndex(job => job.id === jobId);
                if (allJobsIndex >= 0) {
                    allJobs.splice(allJobsIndex, 1);
                }

                // Remove job from filteredJobs array
                const filteredJobsIndex = filteredJobs.findIndex(job => job.id === jobId);
                if (filteredJobsIndex >= 0) {
                    filteredJobs.splice(filteredJobsIndex, 1);
                }

                // Dispatch cleanup event for Alpine component to handle childJobsList/expandedParents
                if (deletedJob) {
                    window.dispatchEvent(new CustomEvent('jobList:deleteCleanup', {
                        detail: { jobId: jobId, parentId: deletedJob.parent_id }
                    }));
                }

                // Re-render without API call
                renderJobs();
                loadStats();
            } catch (error) {
                console.error('Error deleting job:', error);
                window.showNotification('Failed to delete job: ' + error.message, 'error');
            } finally {
                // Only re-enable button if delete failed (on success, button will be removed from DOM)
                if (button && !deleteSuccess) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[Queue] ==================== PAGE LOAD ====================');
            console.log('[Queue] DOMContentLoaded event fired');
            console.log('[Queue] Current URL:', window.location.href);
            console.log('[Queue] Initializing page components...');

            // Load filters from localStorage first
            loadFiltersFromStorage();
            console.log('[Queue] Loaded filters from storage:', activeFilters);

            // Initialize WebSocket connection for real-time job updates
            console.log('[Queue] Initializing WebSocket connection for job updates');
            connectJobsWebSocket();

            // Real-time updates via WebSocket (no polling fallback)
            // - Server pushes job status changes via job_status_change events
            // - Exponential backoff reconnection handles temporary disconnections
            // - Manual page refresh available as ultimate fallback

            renderFilterChips(); // Render initial filter chips
            loadJobs(); // Load initial jobs (page load only - stats loaded by Alpine component)

            // Real-time updates handled by WebSocket (no polling)
            // - Job statistics recalculated from allJobs when job_status_change events arrive
            // - Progress updated via crawler_job_progress events

            // Add ESC key handler for filter modal
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('filter-modal');
                    if (modal && modal.classList.contains('active')) {
                        closeFilterModal();
                    }
                }
            });

            console.log('[Queue] Page initialization complete');
            console.log('[Queue] ====================================================');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            // Close WebSocket connection
            if (jobsWS) {
                console.log('[Queue] Closing WebSocket connection');
                jobsWS.close();
                jobsWS = null;
            }
        });

        // Ensure Alpine.js is fully initialized
        document.addEventListener('alpine:init', function () {
            console.log('[Queue] Alpine.js initialized');

            // Create global queue state store for shared loading state
            Alpine.store('queueState', {
                isLoading: false,
                lastUpdateTime: null,

                // Helper method to set loading state
                setLoading(value) {
                    console.log('[Queue] Store setLoading called:', value);
                    this.isLoading = Boolean(value);
                },

                // Helper method to set last update timestamp
                setLastUpdate(date) {
                    console.log('[Queue] Store setLastUpdate called:', date);
                    this.lastUpdateTime = date instanceof Date ? date : new Date();
                }
            });
            console.log('[Queue] Alpine store initialized:', Alpine.store('queueState'));

            // Register queueStatsHeader component
            // Note: WebSocket connection is now handled by the main job WebSocket (connectJobsWebSocket)
            // to avoid duplicate connections. Queue stats are forwarded from the main WebSocket.
            Alpine.data('queueStatsHeader', () => ({
                pending: 0,
                inFlight: 0,
                workers: 0,
                connected: false,
                reconnecting: false,

                init() {
                    // Store reference to handler to prevent accumulation on re-initialization
                    this.queueStatsUpdateHandler = (e) => {
                        console.log('[Queue] queueStatsHeader received queueStats:update', e.detail);
                        if (e.detail) {
                            this.pending = Number(e.detail.pending) || 0;
                            this.inFlight = Number(e.detail.inFlight) || 0;
                            this.workers = Number(e.detail.workers) || 0;
                            this.connected = e.detail.connected !== undefined ? Boolean(e.detail.connected) : true;
                            this.reconnecting = e.detail.reconnecting !== undefined ? Boolean(e.detail.reconnecting) : false;
                        } else {
                            console.warn('[Queue] Received malformed queueStats:update event:', e);
                        }
                    };

                    // Guard against double-registration
                    if (this.queueStatsUpdateHandler) {
                        window.removeEventListener('queueStats:update', this.queueStatsUpdateHandler);
                    }

                    // Add event listeners for external updates
                    window.addEventListener('queueStats:update', this.queueStatsUpdateHandler);

                    // Cleanup on component destroy to prevent listener accumulation
                    this.$watch('$el', (el) => {
                        if (!el && this.queueStatsUpdateHandler) {
                            window.removeEventListener('queueStats:update', this.queueStatsUpdateHandler);
                            this.queueStatsUpdateHandler = null;
                        }
                    });

                    // Load initial stats from API
                    this.loadStats();
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/jobs/queue');
                        if (response.ok) {
                            const data = await response.json();
                            this.pending = data.pending_messages || 0;
                            this.inFlight = data.in_flight_messages || 0;
                            this.workers = data.concurrency || 0;
                            this.connected = true;
                        } else {
                            this.connected = false;
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading queue stats:', error);
                        this.connected = false;
                    }
                }
            }));

            // Register jobStatsHeader component (job counts, not queue stats)
            Alpine.data('jobStatsHeader', () => ({
                totalJobs: 0,
                pendingJobs: 0,
                runningJobs: 0,
                completedJobs: 0,
                failedJobs: 0,
                cancelledJobs: 0,

                init() {
                    // Listen for stats updates from WebSocket events
                    this.jobStatsUpdateHandler = (e) => {
                        if (e.detail) {
                            this.totalJobs = e.detail.total_jobs || 0;
                            this.pendingJobs = e.detail.pending_jobs || 0;
                            this.runningJobs = e.detail.running_jobs || 0;
                            this.completedJobs = e.detail.completed_jobs || 0;
                            this.failedJobs = e.detail.failed_jobs || 0;
                            this.cancelledJobs = e.detail.cancelled_jobs || 0;
                        }
                    };

                    // Guard against double-registration
                    if (this.jobStatsUpdateHandler) {
                        window.removeEventListener('jobStats:update', this.jobStatsUpdateHandler);
                    }

                    window.addEventListener('jobStats:update', this.jobStatsUpdateHandler);

                    // Cleanup on component destroy
                    this.$watch('$el', (el) => {
                        if (!el && this.jobStatsUpdateHandler) {
                            window.removeEventListener('jobStats:update', this.jobStatsUpdateHandler);
                            this.jobStatsUpdateHandler = null;
                        }
                    });

                    // Load initial stats from API (page load only)
                    this.loadStats();
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/jobs/stats');
                        if (response.ok) {
                            const stats = await response.json();
                            this.totalJobs = stats.total_jobs || 0;
                            this.pendingJobs = stats.pending_jobs || 0;
                            this.runningJobs = stats.running_jobs || 0;
                            this.completedJobs = stats.completed_jobs || 0;
                            this.failedJobs = stats.failed_jobs || 0;
                            this.cancelledJobs = stats.cancelled_jobs || 0;
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading job stats:', error);
                    }
                }
            }));

            // Register jobList component
            Alpine.data('jobList', () => ({
                // State management
                expandedParents: new Set(), // Track expanded parent jobs
                childJobsList: new Map(), // Map: parentID -> array of child job metadata
                childJobsPageSize: 25, // Number of children to show per page
                childJobsVisibleCount: new Map(), // Map of parentId -> number of visible children
                childJobsOffset: new Map(), // Map of parentId -> current fetch offset
                childJobsFetchInProgress: new Map(), // Map of parentId -> boolean to guard against duplicate requests
                collapsedDepths: new Map(), // Map<parentId, Set<depth>> to track which depth levels are collapsed per parent (deprecated, use collapsedNodes)
                collapsedNodes: new Map(), // Map<parentId, Set<childId>> to track which nodes are collapsed per parent
                focusedTreeItem: null, // Track currently focused tree item for keyboard navigation
                treeItemRefs: new Map(), // Map<childId, HTMLElement> for focus management
                childListCap: 500, // Reduced from 200 to 500 to prevent excessive data transfer
                allJobs: [],
                filteredJobs: [],
                _loadSeq: 0, // Sequence counter for tracking latest load request
                selectedJob: null,
                selectedJobIds: new Set(), // Track selected jobs for batch operations
                isDeletingJobs: false, // Idempotency flag for batch deletion
                deletionProgress: { current: 0, total: 0 }, // Track deletion progress
                currentPage: 1,
                totalJobs: 0,
                pageSize: 50,
                itemsToRender: [],
                parentRefreshTimeouts: new Map(), // Debounce parent refreshes per parent_id

                // New features
                hideCompletedChildren: new Map(), // Map<parentId, boolean> - hide completed child jobs (default true)
                expandedChildLogs: new Map(), // Map<parentId, Set<childId>> - track which child logs are expanded
                childJobLogs: new Map(), // Map<childId, Array<log>> - cache of child job logs
                childJobLogsLoading: new Map(), // Map<childId, boolean> - track loading state
                childJobStatusCounts: new Map(), // Map<parentId, {pending, running, completed, failed}> - cached status counts

                // Loading state management
                isLoading: false, // Tracks whether a fetch is in progress
                loadError: null, // Stores error message if fetch fails
                lastSuccessfulJobs: [], // Snapshot of last successful job list for fallback
                currentFetchController: null, // AbortController for request cancellation
                retryCount: 0, // Tracks number of retry attempts
                maxRetries: 3, // Maximum automatic retry attempts
                isInitialLoad: true, // Tracks if this is the first load (show loading, not stale data)
                pendingUpdates: [], // Queue for WebSocket updates during fetch
                pendingUpdatesMaxSize: 1000, // Maximum size of pending updates queue
                lastUpdateTime: null, // Timestamp of last successful update

                init() {
                    // Add event listeners for external commands
                    window.addEventListener('jobList:load', () => this.loadJobs());
                    window.addEventListener('jobList:render', () => this.renderJobs());
                    window.addEventListener('jobList:updateJob', (e) => this.updateJobInList(e.detail));
                    window.addEventListener('jobList:childSpawned', (e) => this.handleChildSpawned(e.detail));
                    window.addEventListener('jobList:changePage', (e) => {
                        this.currentPage = e.detail.page;
                        this.loadJobs();
                    });
                    window.addEventListener('jobList:deleteSelected', () => this.deleteSelectedJobs());
                    window.addEventListener('jobList:deleteCleanup', (e) => this.handleDeleteCleanup(e.detail));

                    // WebSocket real-time updates
                    window.addEventListener('jobList:recalculateStats', () => this.recalculateStats());
                    window.addEventListener('jobList:updateJobProgress', (e) => this.updateJobProgress(e.detail));

                    // Set initial load flag
                    this.isInitialLoad = true;

                    // Cleanup on component destroy
                    this.$watch('$el', (el) => {
                        if (!el) {
                            if (this.currentFetchController) {
                                this.currentFetchController.abort();
                            }
                        }
                    });

                    // Wait for DOM to be ready then initialize
                    this.loadJobs();
                },

                handleChildSpawned(spawnData) {
                    const parentId = spawnData.parent_job_id;
                    if (!this.childJobsList.has(parentId)) {
                        this.childJobsList.set(parentId, []);
                    }
                    const childMeta = {
                        id: spawnData.child_job_id,
                        url: spawnData.url,
                        depth: spawnData.depth,
                        status: 'pending',
                        timestamp: spawnData.timestamp,
                        job_type: spawnData.job_type || 'crawler_url'
                    };
                    const list = this.childJobsList.get(parentId);
                    list.unshift(childMeta);
                    if (list.length > this.childListCap) {
                        list.length = this.childListCap;
                    }

                    // If the parent is expanded and visible count is not set, initialize it to childJobsPageSize
                    if (this.expandedParents.has(parentId) && !this.childJobsVisibleCount.has(parentId)) {
                        this.childJobsVisibleCount.set(parentId, this.childJobsPageSize);
                    } else if (this.expandedParents.has(parentId) && this.childJobsVisibleCount.get(parentId) < this.childJobsList.get(parentId).length) {
                        // If we have room to show the new child, increase visible count by 1
                        const currentVisible = this.childJobsVisibleCount.get(parentId);
                        this.childJobsVisibleCount.set(parentId, currentVisible + 1);
                    }

                    const parentJob = this.allJobs.find(j => j.id === parentId);
                    if (parentJob) {
                        parentJob.child_count = (parentJob.child_count || 0) + 1;
                    }

                    this.renderJobs();
                },

                handleChildJobStatus(jobId, status, jobType) {
                    for (const [parentId, children] of this.childJobsList.entries()) {
                        const child = children.find(c => c.id === jobId);
                        if (child) {
                            child.status = status;
                            // Backfill missing job_type from update if available
                            if (jobType) {
                                child.job_type = child.job_type || jobType;
                            }
                            const parentJob = this.allJobs.find(j => j.id === parentId);
                            if (parentJob) {
                                if (status === 'completed') {
                                    parentJob.completed_children = (parentJob.completed_children || 0) + 1;
                                } else if (status === 'failed') {
                                    parentJob.failed_children = (parentJob.failed_children || 0) + 1;
                                }
                            }
                            this.renderJobs();
                            break;
                        }
                    }
                },

                handleDeleteCleanup(deleteData) {
                    const { jobId, parentId } = deleteData;

                    // Check if deleted job is a parent
                    if (!parentId) {
                        // This is a parent job - clean up childJobsList, expandedParents, childJobsVisibleCount, collapsedDepths, and collapsedNodes
                        this.childJobsList.delete(jobId);
                        this.expandedParents.delete(jobId);
                        this.childJobsVisibleCount.delete(jobId);
                        this.collapsedDepths.delete(jobId);
                        this.collapsedNodes.delete(jobId);
                    } else {
                        // This is a child job - find parent and remove child, decrement counts
                        if (this.childJobsList.has(parentId)) {
                            const children = this.childJobsList.get(parentId);
                            const childIndex = children.findIndex(c => c.id === jobId);
                            if (childIndex >= 0) {
                                const child = children[childIndex];
                                // Remove child from list
                                children.splice(childIndex, 1);

                                // Decrement parent's child counts
                                const parentJob = this.allJobs.find(j => j.id === parentId);
                                if (parentJob) {
                                    if (parentJob.child_count > 0) {
                                        parentJob.child_count--;
                                    }
                                    if (child.status === 'completed' && parentJob.completed_children > 0) {
                                        parentJob.completed_children--;
                                    }
                                    if (child.status === 'failed' && parentJob.failed_children > 0) {
                                        parentJob.failed_children--;
                                    }
                                }
                            }
                        }
                    }

                    // Trigger render to reflect cleanup
                    this.renderJobs();
                },

                retryLoadJobs() {
                    // Reset retry count and trigger load
                    this.retryCount = 0;
                    this.loadJobs();
                },

                async loadJobs() {
                    console.log('[Queue] loadJobs called at', new Date().toISOString());
                    console.log('[Queue] Setting isLoading to true and updating store, current value:', this.isLoading);
                    console.log('[Queue] Aborting previous request:', this.currentFetchController !== null);
                    console.log('[Queue] Loading page', this.currentPage, 'with filters:', window.activeFilters);

                    // Generate request sequence ID to prevent race conditions from aborted requests
                    const requestId = ++this._loadSeq;
                    console.log('[Queue] Generated request ID:', requestId);

                    try {
                        // Request deduplication - abort previous request if in-flight
                        if (this.currentFetchController) {
                            this.currentFetchController.abort();
                        }

                        // Create new AbortController for this request
                        this.currentFetchController = new AbortController();

                        // Set loading state - don't clear existing data
                        this.isLoading = true;
                        Alpine.store('queueState').setLoading(true);
                        this.loadError = null;

                        // Build query parameters from filters
                        const params = new URLSearchParams();
                        params.append('limit', this.pageSize);
                        params.append('offset', (this.currentPage - 1) * this.pageSize);
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'DESC');

                        // Always fetch parent jobs only
                        params.append('parent_id', 'root');

                        // Build filter parameters from activeFilters state (with safe checks)
                        if (window.activeFilters && window.activeFilters.status && window.activeFilters.status.size > 0) {
                            params.append('status', Array.from(window.activeFilters.status).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.source && window.activeFilters.source.size > 0) {
                            params.append('source', Array.from(window.activeFilters.source).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.entity && window.activeFilters.entity.size > 0) {
                            params.append('entity', Array.from(window.activeFilters.entity).join(','));
                        }

                        const response = await fetch(`/api/jobs?${params.toString()}`, {
                            signal: this.currentFetchController.signal
                        });
                        if (!response.ok) {
                            throw new Error('Failed to fetch jobs');
                        }

                        const data = await response.json();
                        const newJobs = data.jobs || [];

                        console.log('[Queue] Successfully loaded', newJobs.length, 'jobs, total count:', data.total_count);

                        // Update jobs arrays only after successful parse
                        this.allJobs = newJobs;
                        this.totalJobs = data.total_count || 0;
                        this.filteredJobs = [...newJobs];

                        // Store snapshot of successful data
                        this.lastSuccessfulJobs = [...newJobs];

                        // Reset retry count on success
                        this.retryCount = 0;
                        this.isInitialLoad = false;
                        console.log('[Queue] Cleared isInitialLoad flag, isLoading will be set to false in finally block');

                        // Update timestamp
                        this.lastUpdateTime = new Date();
                        console.log('[Queue] Last update time:', this.lastUpdateTime.toISOString());

                        // Apply any pending updates that arrived during fetch
                        if (this.pendingUpdates.length > 0) {
                            console.log('[Queue] Applying', this.pendingUpdates.length, 'pending updates');
                            this.pendingUpdates.forEach(update => this.updateJobInList(update));
                            this.pendingUpdates = [];
                        }

                        this.renderJobs();

                    } catch (error) {
                        // Handle AbortError separately - don't treat as error
                        if (error.name === 'AbortError') {
                            console.log('[Queue] Request aborted (isLoading:', this.isLoading, '), new request in progress');
                            return;
                        }

                        console.error('[Queue] Error loading jobs (attempt ' + (this.retryCount + 1) + '):', error);
                        this.loadError = error.message;

                        // Fall back to last successful data if available
                        if (this.lastSuccessfulJobs.length > 0) {
                            this.allJobs = [...this.lastSuccessfulJobs];
                            this.filteredJobs = [...this.lastSuccessfulJobs];
                            this.renderJobs();
                            console.log('[Queue] Rendered fallback data from last successful load');
                        }

                        // Increment retry count
                        this.retryCount++;
                        console.log('[Queue] Retry count incremented to', this.retryCount, 'of', this.maxRetries);

                        // Schedule automatic retry with exponential backoff if under max retries
                        if (this.retryCount < this.maxRetries) {
                            const delay = Math.min(1000 * Math.pow(2, this.retryCount), 30000);
                            console.log('[Queue] Scheduling retry in', delay, 'ms');
                            setTimeout(() => {
                                this.loadJobs();
                            }, delay);
                        }

                    } finally {
                        console.log('[Queue] loadJobs finally block executing for request ID:', requestId);
                        console.log('[Queue] Current sequence:', this._loadSeq, 'Latest request ID:', requestId);

                        // Only clear loading state if this is the latest request
                        // This prevents flicker from aborted requests that complete after a newer request
                        if (requestId === this._loadSeq) {
                            console.log('[Queue] Clearing loading state for latest request');
                            this.isLoading = false;
                            Alpine.store('queueState').setLoading(false);
                            Alpine.store('queueState').setLastUpdate(new Date());
                        } else {
                            console.log('[Queue] Skipping loading state clear for outdated request', requestId);
                        }

                        this.currentFetchController = null;
                        console.log('[Queue] isLoading after check:', this.isLoading);
                        console.log('[Queue] Store isLoading:', Alpine.store('queueState').isLoading);
                        console.log('[Queue] Clearing fetch controller:', this.currentFetchController !== null);
                    }
                },

                async loadChildJobs(parentId, offset = 0) {
                    // Guard against duplicate requests
                    if (this.childJobsFetchInProgress.get(parentId)) {
                        return [];
                    }

                    try {
                        this.childJobsFetchInProgress.set(parentId, true);

                        const params = new URLSearchParams();
                        params.append('parent_id', parentId);
                        params.append('limit', 500); // Load children in pages
                        params.append('offset', offset);
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'DESC');

                        const response = await fetch(`/api/jobs?${params.toString()}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch child jobs');
                        }

                        const data = await response.json();
                        const children = data.jobs || [];

                        // Store child metadata for inline display
                        const meta = children.map(c => ({
                            id: c.id,
                            url: c.url || (c.config && c.config.url) || '',
                            depth: c.depth || (c.config && c.config.depth) || 0,
                            status: c.status || 'pending',
                            timestamp: c.created_at || new Date().toISOString(),
                            job_type: c.job_type || 'crawler_url'
                        }));

                        // If this is the first page (offset 0), set the list and initialize
                        if (offset === 0) {
                            this.childJobsList.set(parentId, meta);
                            this.childJobsOffset.set(parentId, meta.length);
                            // Initialize visible count to childJobsPageSize for this parent
                            this.childJobsVisibleCount.set(parentId, this.childJobsPageSize);
                        } else {
                            // For subsequent pages, append to existing list
                            const existingChildren = this.childJobsList.get(parentId) || [];
                            existingChildren.push(...meta);
                            this.childJobsList.set(parentId, existingChildren);
                            this.childJobsOffset.set(parentId, existingChildren.length);
                        }

                        return children;
                    } catch (error) {
                        console.error('[Queue] Error loading child jobs:', error);
                        return [];
                    } finally {
                        this.childJobsFetchInProgress.set(parentId, false);
                    }
                },

                getVisibleChildJobs(parentId) {
                    const children = this.childJobsList.get(parentId);
                    if (!children) return [];

                    // Filter out completed jobs if hideCompletedChildren is enabled (default true)
                    const hideCompleted = this.hideCompletedChildren.has(parentId) ? this.hideCompletedChildren.get(parentId) : true;
                    let filteredChildren = children;
                    if (hideCompleted) {
                        filteredChildren = children.filter(child => child.status !== 'completed');
                    }

                    // Filter out collapsed items before computing visible count
                    const visibleChildren = filteredChildren.filter(child => !this.isChildCollapsed(parentId, child));

                    const visibleCount = this.childJobsVisibleCount.get(parentId) || this.childJobsPageSize;
                    return visibleChildren.slice(0, Math.min(visibleCount, visibleChildren.length));
                },

                async loadMoreChildJobs(parentId) {
                    const children = this.childJobsList.get(parentId);
                    if (!children) return;

                    const totalChildren = children.length;
                    const currentVisibleCount = this.childJobsVisibleCount.get(parentId) || this.childJobsPageSize;

                    // If we need more data from server
                    if (currentVisibleCount >= totalChildren) {
                        // Fetch more data from server using the current offset
                        const offset = this.childJobsOffset.get(parentId) || 0;
                        const moreChildren = await this.loadChildJobs(parentId, offset);

                        // Update visible count with new data
                        const newTotal = (this.childJobsList.get(parentId) || []).length;
                        const newVisibleCount = Math.min(currentVisibleCount + this.childJobsPageSize, newTotal);
                        this.childJobsVisibleCount.set(parentId, newVisibleCount);
                    } else {
                        // We have locally fetched data, just increase visible count
                        const newVisibleCount = Math.min(currentVisibleCount + this.childJobsPageSize, totalChildren);
                        this.childJobsVisibleCount.set(parentId, newVisibleCount);
                    }

                    this.renderJobs();
                },

                // Tree Collapse Management Functions (deprecated - kept for compatibility)
                // Per-node collapse is now the default behavior

                isChildCollapsed(parentId, child) {
                    // Depth 0 items are never collapsed
                    if (child.depth === 0) return false;

                    // Use branch-aware ancestor checking
                    const children = this.childJobsList.get(parentId);
                    if (!children) return false;

                    // Find this child in the list
                    const idx = children.findIndex(c => c.id === child.id);
                    if (idx === -1) return false;

                    // Walk backward through siblings to find ancestor chain
                    let neededDepth = child.depth - 1;
                    for (let i = idx - 1; i >= 0; i--) {
                        const prev = children[i];

                        // If we've gone too far back, stop
                        if (prev.depth < neededDepth) {
                            break;
                        }

                        // If we found the immediate ancestor
                        if (prev.depth === neededDepth) {
                            // Check if this ancestor is collapsed
                            if (this.isNodeCollapsed(parentId, prev.id)) {
                                return true;
                            }
                            // Move to next ancestor up the chain
                            neededDepth--;
                            // Stop when we've checked all ancestors
                            if (neededDepth < 0) {
                                break;
                            }
                        }
                    }

                    return false;
                },

                // Per-node collapse helpers
                toggleNodeCollapse(parentId, childId) {
                    if (!this.collapsedNodes.has(parentId)) {
                        this.collapsedNodes.set(parentId, new Set());
                    }
                    const collapsed = this.collapsedNodes.get(parentId);
                    if (collapsed.has(childId)) {
                        collapsed.delete(childId);
                        this.announceToScreenReader(`Node expanded`);
                    } else {
                        collapsed.add(childId);
                        this.announceToScreenReader(`Node collapsed`);
                    }
                    this.renderJobs();
                },

                isNodeCollapsed(parentId, childId) {
                    return this.collapsedNodes.get(parentId)?.has(childId) || false;
                },

                mightHaveChildren(parentId, child) {
                    const children = this.childJobsList.get(parentId);
                    if (!children) return false;

                    // Branch-aware check: find this child in the list and scan forward
                    const childIndex = children.findIndex(c => c.id === child.id);
                    if (childIndex === -1) return false;

                    // Scan forward until we find an item at depth <= current depth
                    for (let i = childIndex + 1; i < children.length; i++) {
                        const nextChild = children[i];
                        // If we find a child at depth == current + 1, this child has children
                        if (nextChild.depth === child.depth + 1) {
                            return true;
                        }
                        // If we find a child at depth <= current, we've left this branch
                        if (nextChild.depth <= child.depth) {
                            break;
                        }
                    }
                    return false;
                },

                hasVisibleChildren(child) {
                    // For our implementation, we'll check if this child has potential children at the next depth level
                    // This is checked dynamically when needed
                    return false; // This is a placeholder, actual implementation can be done as needed
                },

                // Status Icon Mapping Functions
                getStatusIcon(status) {
                    const iconMap = {
                        'pending': 'fa-circle',
                        'running': 'fa-spinner fa-pulse',
                        'completed': 'fa-check-circle',
                        'failed': 'fa-times-circle',
                        'cancelled': 'fa-ban'
                    };
                    return iconMap[status] || 'fa-question-circle';
                },

                getStatusDisplayText(status) {
                    const textMap = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return textMap[status] || 'Unknown';
                },

                // Keyboard Navigation Handler
                handleTreeKeydown(event, parentId, child) {
                    const visibleItems = this.getVisibleTreeItems(parentId);
                    const currentIndex = visibleItems.findIndex(c => c.id === child.id);

                    switch (event.key) {
                        case 'ArrowDown':
                            event.preventDefault();
                            if (currentIndex < visibleItems.length - 1) {
                                this.focusTreeItem(visibleItems[currentIndex + 1].id);
                            }
                            break;
                        case 'ArrowUp':
                            event.preventDefault();
                            if (currentIndex > 0) {
                                this.focusTreeItem(visibleItems[currentIndex - 1].id);
                            }
                            break;
                        case 'ArrowRight':
                            if (this.mightHaveChildren(parentId, child) && this.isNodeCollapsed(parentId, child.id)) {
                                event.preventDefault();
                                this.toggleNodeCollapse(parentId, child.id);
                            }
                            break;
                        case 'ArrowLeft':
                            if (this.mightHaveChildren(parentId, child) && !this.isNodeCollapsed(parentId, child.id)) {
                                event.preventDefault();
                                this.toggleNodeCollapse(parentId, child.id);
                            }
                            break;
                        case 'Enter':
                        case ' ':
                            if (this.mightHaveChildren(parentId, child)) {
                                event.preventDefault();
                                this.toggleNodeCollapse(parentId, child.id);
                            }
                            break;
                        case 'Home':
                            event.preventDefault();
                            if (visibleItems.length > 0) {
                                this.focusTreeItem(visibleItems[0].id);
                            }
                            break;
                        case 'End':
                            event.preventDefault();
                            if (visibleItems.length > 0) {
                                this.focusTreeItem(visibleItems[visibleItems.length - 1].id);
                            }
                            break;
                    }
                },

                focusTreeItem(childId) {
                    if (this.treeItemRefs.has(childId)) {
                        const element = this.treeItemRefs.get(childId);
                        element.focus();
                        this.focusedTreeItem = childId;
                    }
                },

                getVisibleTreeItems(parentId) {
                    const allChildren = this.getVisibleChildJobs(parentId);
                    return allChildren.filter(child => !this.isChildCollapsed(parentId, child));
                },

                getTreeItemIndex(parentId, childId) {
                    const visibleItems = this.getVisibleTreeItems(parentId);
                    return visibleItems.findIndex(item => item.id === childId);
                },

                visibleTreeItemCount(parentId) {
                    return this.getVisibleTreeItems(parentId).length;
                },

                announceToScreenReader(message) {
                    // Create an ARIA live region to announce changes to screen readers
                    let liveRegion = document.getElementById('aria-live-region');
                    if (!liveRegion) {
                        // Create the live region if it doesn't exist
                        const region = document.createElement('div');
                        region.setAttribute('id', 'aria-live-region');
                        region.setAttribute('aria-live', 'polite');
                        region.setAttribute('aria-atomic', 'true');
                        region.style.position = 'absolute';
                        region.style.left = '-10000px';
                        region.style.width = '1px';
                        region.style.height = '1px';
                        region.style.overflow = 'hidden';
                        document.body.appendChild(region);
                        liveRegion = region;
                    }

                    // Update live region content
                    liveRegion.textContent = message;

                    // Clear after a delay to avoid repeated announcements
                    setTimeout(() => {
                        liveRegion.textContent = '';
                    }, 1000);
                },

                async toggleParentExpansion(parentId) {
                    if (this.expandedParents.has(parentId)) {
                        // Collapse
                        this.expandedParents.delete(parentId);
                        // Clear visible count on collapse to free memory and avoid stale state
                        this.childJobsVisibleCount.delete(parentId);
                        // Clear collapsed depths on collapse to maintain consistent state
                        this.collapsedDepths.delete(parentId);
                        // Clear collapsed nodes on parent collapse
                        this.collapsedNodes.delete(parentId);
                        // Clear focused tree item
                        this.focusedTreeItem = null;
                    } else {
                        // Expand - load children and mark as expanded
                        this.expandedParents.add(parentId);
                        await this.loadChildJobs(parentId);

                        // Set default hide completed to true for new expansions
                        if (!this.hideCompletedChildren.has(parentId)) {
                            this.hideCompletedChildren.set(parentId, true);
                        }
                    }

                    // Re-render to show/hide children
                    this.renderJobs();
                },

                renderJobs() {
                    // Always render parent jobs with expand/collapse capability
                    const itemsToRender = this.filteredJobs.filter(job => !job.parent_id).map(parentJob => {
                        return { type: 'parent', job: parentJob, isExpanded: this.expandedParents.has(parentJob.id) };
                    });

                    this.itemsToRender = itemsToRender;

                    // Also update pagination
                    const totalPages = Math.max(1, Math.ceil(this.totalJobs / this.pageSize));
                    window.renderPagination(totalPages, this.currentPage);
                },


                getDocumentsCount(job) {
                    // For completed/failed/cancelled jobs, use result_count (authoritative snapshot)
                    // For running/pending jobs, use progress.completed_urls (real-time counter)
                    const terminalStatuses = ['completed', 'failed', 'cancelled'];

                    // Check if job is in terminal status and has result_count
                    if (terminalStatuses.includes(job.status) && job.result_count !== undefined && job.result_count !== null) {
                        return job.result_count;
                    }

                    // For active jobs or fallback, use progress.completed_urls
                    if (job.progress) {
                        try {
                            const progress = typeof job.progress === 'string' ? JSON.parse(job.progress) : job.progress;
                            if (progress && progress.completed_urls !== undefined) {
                                return progress.completed_urls;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to parse job progress:', error);
                        }
                    }

                    // Final fallback to result_count if available
                    if (job.result_count !== undefined && job.result_count !== null) {
                        return job.result_count;
                    }

                    return 'N/A';
                },

                getCreatedDate(job) {
                    return job.created_at ? new Date(job.created_at).toLocaleString() : 'N/A';
                },

                getStartedDate(job) {
                    if (!job.started_at) return null;
                    try {
                        return new Date(job.started_at).toLocaleString();
                    } catch (error) {
                        console.warn('[Queue] Failed to parse started_at:', error);
                        return 'Invalid Date';
                    }
                },

                getFinishedDate(job) {
                    if (!job.finished_at) return null;
                    try {
                        return new Date(job.finished_at).toLocaleString();
                    } catch (error) {
                        console.warn('[Queue] Failed to parse finished_at:', error);
                        return 'Invalid Date';
                    }
                },

                // New helper methods for UI improvements

                toggleHideCompletedChildren(parentId) {
                    const currentValue = this.hideCompletedChildren.get(parentId) !== undefined ? this.hideCompletedChildren.get(parentId) : true;
                    this.hideCompletedChildren.set(parentId, !currentValue);
                    this.renderJobs();
                },

                getChildJobsSummary(parentId) {
                    // Get parent job to access child statistics from backend
                    const parentJob = this.allJobs.find(j => j.id === parentId);
                    if (!parentJob || !parentJob.child_count || parentJob.child_count === 0) {
                        return 'No child jobs';
                    }

                    // Use child statistics from backend (sent with parent job)
                    const counts = {
                        pending: parentJob.pending_children || 0,
                        running: parentJob.running_children || 0,
                        completed: parentJob.completed_children || 0,
                        failed: parentJob.failed_children || 0,
                        cancelled: parentJob.cancelled_children || 0
                    };

                    const parts = [];
                    if (counts.pending > 0) parts.push(`${counts.pending} pending`);
                    if (counts.running > 0) parts.push(`${counts.running} running`);
                    if (counts.completed > 0) parts.push(`${counts.completed} completed`);
                    if (counts.failed > 0) parts.push(`${counts.failed} failed`);
                    if (counts.cancelled > 0) parts.push(`${counts.cancelled} cancelled`);

                    return parts.length > 0 ? parts.join(', ') : 'No jobs';
                },

                toggleChildJobLog(parentId, childId) {
                    if (!this.expandedChildLogs.has(parentId)) {
                        this.expandedChildLogs.set(parentId, new Set());
                    }
                    const expanded = this.expandedChildLogs.get(parentId);
                    if (expanded.has(childId)) {
                        expanded.delete(childId);
                    } else {
                        expanded.add(childId);
                        // Load logs if not already loaded
                        if (!this.childJobLogs.has(childId)) {
                            this.loadChildJobLogs(childId);
                        }
                    }
                },

                isChildLogExpanded(parentId, childId) {
                    return this.expandedChildLogs.has(parentId) && this.expandedChildLogs.get(parentId).has(childId);
                },

                async loadChildJobLogs(childId) {
                    this.childJobLogsLoading.set(childId, true);
                    try {
                        const response = await fetch(`/api/jobs/${childId}/logs?limit=10`);
                        if (response.ok) {
                            const data = await response.json();
                            this.childJobLogs.set(childId, data.logs || []);
                        } else {
                            console.error('[Queue] Failed to load child job logs:', response.statusText);
                            this.childJobLogs.set(childId, []);
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading child job logs:', error);
                        this.childJobLogs.set(childId, []);
                    } finally {
                        this.childJobLogsLoading.set(childId, false);
                    }
                },

                formatLogTime(timestamp) {
                    if (!timestamp) return '';
                    try {
                        const date = new Date(timestamp);
                        return date.toLocaleTimeString();
                    } catch (error) {
                        return '';
                    }
                },



                async refreshParentJob(parentId) {
                    try {
                        const response = await fetch(`/api/jobs/${parentId}`);
                        if (response.ok) {
                            const job = await response.json();
                            // Update the job in allJobs
                            const index = this.allJobs.findIndex(j => j.id === parentId);
                            if (index !== -1) {
                                this.allJobs[index] = job;
                                this.renderJobs();
                                window.showNotification('Job stats refreshed', 'success');
                            }
                            // Reload child jobs if parent is expanded
                            if (this.expandedParents.has(parentId)) {
                                await this.loadChildJobs(parentId);
                            }
                        } else {
                            window.showNotification('Failed to refresh job stats', 'error');
                        }
                    } catch (error) {
                        console.error('[Queue] Error refreshing parent job:', error);
                        window.showNotification('Failed to refresh job stats', 'error');
                    }
                },

                getJobURL(job) {
                    if (!job) return null;
                    // Priority: seed_urls > current_url
                    if (job.seed_urls && job.seed_urls.length > 0) {
                        return job.seed_urls[0];
                    }
                    if (job.progress?.current_url) {
                        return job.progress.current_url;
                    }
                    return null;
                },

                formatTimeSince(date) {
                    if (!date) return '';
                    const seconds = Math.floor((new Date() - date) / 1000);
                    if (seconds < 60) return seconds + 's ago';
                    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
                    return Math.floor(seconds / 3600) + 'h ago';
                },

                deriveParentStatus(job) {
                    // If not a parent job or no child stats, return original status
                    if (!job.child_count || job.child_count === 0) {
                        return { status: job.status, suffix: '' };
                    }

                    const total = job.child_count;
                    const completed = job.completed_children || 0;
                    const failed = job.failed_children || 0;

                    // All children completed
                    if (completed === total) {
                        return { status: 'completed', suffix: '' };
                    }

                    // Some children failed but job is still running
                    if (failed > 0 && job.status === 'running') {
                        return { status: 'running', suffix: ` (${failed} failed)` };
                    }

                    // Job is running with children in progress
                    if (job.status === 'running') {
                        return { status: 'running', suffix: '' };
                    }

                    // Default to job's own status
                    return { status: job.status, suffix: '' };
                },

                getStatusBadgeClass(type, status, job) {
                    // For parent jobs, derive status from children
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                    }

                    if (type === 'child') {
                        const childBadges = {
                            'pending': 'label-secondary',
                            'running': 'label-primary label-processing',
                            'completed': 'label-success label-done',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return childBadges[status] || 'label';
                    } else if (type === 'parent') {
                        const parentBadges = {
                            'pending': 'label-warning label-queued',
                            'running': 'label-primary label-orchestrating',
                            'completed': 'label-success',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return parentBadges[status] || 'label';
                    } else {
                        // In flat mode, determine if job is parent or child based on parent_id field
                        const isChild = !!job.parent_id;
                        if (isChild) {
                            const childBadges = {
                                'pending': 'label-secondary',
                                'running': 'label-primary label-processing',
                                'completed': 'label-success label-done',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return childBadges[status] || 'label';
                        } else {
                            const parentBadges = {
                                'pending': 'label-warning label-queued',
                                'running': 'label-primary label-orchestrating',
                                'completed': 'label-success',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return parentBadges[status] || 'label';
                        }
                    }
                },

                getStatusBadgeText(type, status, job) {
                    // For parent jobs, derive status from children
                    let suffix = '';
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                        suffix = derived.suffix;
                    }

                    // Return appropriate text based on the badge type
                    const statusTexts = {
                        'pending': type === 'child' ? 'Pending' : type === 'parent' ? 'Queued' : (!job || !job.parent_id ? 'Queued' : 'Pending'),
                        'running': type === 'child' ? 'Processing' : type === 'parent' ? 'Orchestrating' : (!job || !job.parent_id ? 'Orchestrating' : 'Processing'),
                        'completed': type === 'child' ? 'Done' : 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return (statusTexts[status] || 'Unknown') + suffix;
                },

                toggleJobSelection(jobId) {
                    if (this.selectedJobIds.has(jobId)) {
                        this.selectedJobIds.delete(jobId);
                    } else {
                        this.selectedJobIds.add(jobId);
                    }
                    this.updateDeleteSelectedButtonVisibility();
                    this.updateSelectAllCheckbox();
                },

                toggleSelectAll() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');

                    if (selectAllCheckbox.checked) {
                        // Select all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.add(jobId);
                            checkbox.checked = true;
                        });
                    } else {
                        // Deselect all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.delete(jobId);
                            checkbox.checked = false;
                        });
                    }

                    this.updateDeleteSelectedButtonVisibility();
                },

                updateSelectAllCheckbox() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');
                    const checkedCount = Array.from(jobCheckboxes).filter(cb => cb.checked).length;

                    if (checkedCount === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else if (checkedCount === jobCheckboxes.length) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true;
                    }
                },

                updateDeleteSelectedButtonVisibility() {
                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    if (this.selectedJobIds.size > 0) {
                        deleteButton.style.display = 'inline-block';
                        if (buttonSpan) {
                            buttonSpan.textContent = `Delete Selected (${this.selectedJobIds.size})`;
                        }
                    } else {
                        deleteButton.style.display = 'none';
                        if (buttonSpan) {
                            buttonSpan.textContent = 'Delete Selected';
                        }
                    }
                },

                async deleteSelectedJobs() {
                    // Idempotency check - prevent concurrent deletions
                    if (this.isDeletingJobs) {
                        console.log('Deletion already in progress, skipping');
                        return;
                    }

                    if (this.selectedJobIds.size === 0) {
                        window.showNotification('No jobs selected', 'warning');
                        return;
                    }

                    // Get job details for confirmation (BEFORE setting deletion flag)
                    const jobDetails = [];
                    const jobIdsArray = Array.from(this.selectedJobIds);
                    let totalChildren = 0;

                    for (const jobId of jobIdsArray) {
                        const job = this.allJobs.find(j => j.id === jobId);
                        if (job) {
                            const childCount = job.child_count || 0;
                            totalChildren += childCount;
                            jobDetails.push({
                                id: jobId,
                                name: job.name || `Job ${jobId.substring(0, 8)}`,
                                status: job.status,
                                childCount: childCount
                            });
                        }
                    }

                    // Show custom confirmation modal using event-based API (pass pre-built job details)
                    const confirmed = await openDeleteConfirmModal(jobDetails, totalChildren);

                    if (!confirmed) {
                        // User cancelled - no need to clear flag since it wasn't set yet
                        return;
                    }

                    // NOW set the deletion in progress flag (after user confirmed)
                    this.isDeletingJobs = true;
                    this.deletionProgress = { current: 0, total: this.selectedJobIds.size };

                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    const originalText = buttonSpan ? buttonSpan.textContent : 'Delete Selected';
                    deleteButton.disabled = true;
                    deleteButton.innerHTML = '<i class="fas fa-spinner fa-pulse"></i> <span>Deleting...</span>';

                    // Create snapshot for rollback on error
                    const jobsToDelete = jobIdsArray.map(jobId => {
                        const allJobsIndex = this.allJobs.findIndex(job => job.id === jobId);
                        const filteredJobsIndex = this.filteredJobs.findIndex(job => job.id === jobId);
                        return {
                            id: jobId,
                            job: this.allJobs[allJobsIndex],
                            allJobsIndex: allJobsIndex,
                            filteredJobsIndex: filteredJobsIndex
                        };
                    });

                    // Optimistic update: Remove jobs from UI immediately
                    this.allJobs = this.allJobs.filter(job => !this.selectedJobIds.has(job.id));
                    this.filteredJobs = this.filteredJobs.filter(job => !this.selectedJobIds.has(job.id));
                    this.renderJobs();

                    const results = {
                        successful: [],
                        failed: []
                    };

                    try {
                        // Delete each job
                        for (let i = 0; i < jobIdsArray.length; i++) {
                            const jobId = jobIdsArray[i];
                            this.deletionProgress.current = i + 1;

                            try {
                                const response = await fetch(`/api/jobs/${jobId}`, {
                                    method: 'DELETE'
                                });

                                if (response.ok) {
                                    const data = await response.json();
                                    results.successful.push({
                                        jobId: jobId,
                                        cascadeDeleted: data.cascade_deleted || 0
                                    });

                                    // Dispatch cleanup event for successful deletion to sync child-state maps
                                    window.dispatchEvent(new CustomEvent('jobList:deleteCleanup', {
                                        detail: { jobId: jobId, parentId: null }
                                    }));
                                } else {
                                    // Try to parse JSON error response
                                    let errorText = 'Unknown error';
                                    let errorData = null;
                                    try {
                                        errorData = await response.json();
                                        errorText = errorData.details || errorData.error || `HTTP ${response.status}`;
                                    } catch (e) {
                                        errorText = await response.text();
                                    }
                                    results.failed.push({
                                        jobId: jobId,
                                        error: errorText,
                                        status: errorData?.status,
                                        childCount: errorData?.child_count
                                    });
                                }
                            } catch (error) {
                                results.failed.push({ jobId, error: error.message });
                            }

                            // Re-render after each deletion for better UX
                            this.renderJobs();
                        }
                    } finally {
                        // Clear selections
                        this.selectedJobIds.clear();
                        const selectAllCheckbox = document.getElementById('select-all-checkbox');
                        if (selectAllCheckbox) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                        }

                        // Reset button
                        deleteButton.disabled = false;
                        deleteButton.innerHTML = `<i class="fa-solid fa-trash"></i> <span>${originalText}</span>`;
                        this.updateDeleteSelectedButtonVisibility();

                        // Clear deletion flags
                        this.isDeletingJobs = false;
                        this.deletionProgress = { current: 0, total: 0 };

                        // Show results - single notification with summary
                        if (results.successful.length > 0 && results.failed.length === 0) {
                            // All successful
                            const totalCascade = results.successful.reduce((sum, r) => sum + r.cascadeDeleted, 0);
                            window.showNotification(
                                `Successfully deleted ${results.successful.length} job${results.successful.length > 1 ? 's' : ''}${totalCascade > 0 ? ` (${totalCascade} children)` : ''}`,
                                'success'
                            );
                        } else if (results.successful.length === 0 && results.failed.length > 0) {
                            // All failed
                            const mostCommonError = this.getMostCommonError(results.failed);
                            window.showNotification(
                                `Failed to delete ${results.failed.length} job${results.failed.length > 1 ? 's' : ''}: ${mostCommonError}`,
                                'error'
                            );
                            console.error('Failed deletions:', results.failed);
                        } else {
                            // Partial success
                            const mostCommonError = this.getMostCommonError(results.failed);
                            window.showNotification(
                                `Deleted ${results.successful.length} of ${jobIdsArray.length} jobs. ${results.failed.length} failed: ${mostCommonError}`,
                                'warning'
                            );
                            console.error('Partial deletion failures:', results.failed);
                        }

                        // Refresh data
                        window.loadStats();
                        this.renderJobs();
                    }
                },

                // Helper function to get most common error message
                getMostCommonError(failures) {
                    const errorCounts = {};
                    failures.forEach(f => {
                        errorCounts[f.error] = (errorCounts[f.error] || 0) + 1;
                    });
                    let maxCount = 0;
                    let mostCommon = '';
                    for (const [error, count] of Object.entries(errorCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            mostCommon = error;
                        }
                    }
                    return mostCommon || failures[0].error;
                },

                async updateJobInList(update) {
                    console.log('[Queue] Job updated via WebSocket:', update.job_id.substring(0, 8), update.status);

                    // If loading, queue the update to apply after fetch completes
                    if (this.isLoading) {
                        // Coalesce updates by job_id - if update for same job exists, replace it
                        const existingIndex = this.pendingUpdates.findIndex(u => u.job_id === update.job_id);
                        if (existingIndex >= 0) {
                            // Replace existing update for this job (keep newest state)
                            this.pendingUpdates[existingIndex] = update;
                        } else {
                            // Add new update
                            this.pendingUpdates.push(update);
                        }

                        // Cap the queue size to prevent unbounded growth
                        if (this.pendingUpdates.length > this.pendingUpdatesMaxSize) {
                            // Remove oldest entries, keeping the most recent ones
                            this.pendingUpdates.splice(0, this.pendingUpdates.length - this.pendingUpdatesMaxSize);
                        }
                        return;
                    }

                    // Find job in allJobs array
                    let jobIndex = this.allJobs.findIndex(job => job.id === update.job_id);
                    let job = jobIndex >= 0 ? this.allJobs[jobIndex] : null;

                    // If job not found, fetch full job data regardless of status
                    if (!job) {
                        try {
                            const response = await fetch(`/api/jobs/${update.job_id}`);

                            // Handle 404 silently - job was deleted, ignore update
                            if (response.status === 404) {
                                console.debug('[Queue] Job deleted or not found:', update.job_id.substring(0, 8));
                                return;
                            }

                            if (response.ok) {
                                job = await response.json();
                                this.allJobs.unshift(job); // Insert at beginning (newest first)
                                jobIndex = 0;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to fetch new job:', error);
                            return;
                        }
                    }

                    // If job still not found, ignore update
                    if (!job) {
                        return;
                    }

                    // Update job fields - preserve existing values when fields are omitted
                    job.status = update.status;
                    // If this is a child job reaching a terminal state, update in-memory child list immediately
                    if (job.parent_id && (update.status === 'completed' || update.status === 'failed')) {
                        this.handleChildJobStatus(job.id, update.status, update.job_type);
                    }


                    if (update.result_count !== undefined && update.result_count !== null) {
                        job.result_count = update.result_count;
                    }
                    if (update.failed_count !== undefined && update.failed_count !== null) {
                        job.failed_count = update.failed_count;
                    }

                    // Update progress object
                    if (!job.progress) {
                        job.progress = {};
                    }
                    if (typeof job.progress === 'string') {
                        try {
                            job.progress = JSON.parse(job.progress);
                        } catch (e) {
                            job.progress = {};
                        }
                    }

                    if (update.completed_urls !== undefined && update.completed_urls !== null) {
                        job.progress.completed_urls = update.completed_urls;
                    }
                    if (update.pending_urls !== undefined && update.pending_urls !== null) {
                        job.progress.pending_urls = update.pending_urls;
                    }
                    if (update.total_urls !== undefined && update.total_urls !== null) {
                        job.progress.total_urls = update.total_urls;
                    }

                    // Set error if present
                    if (update.error !== undefined && update.error !== null) {
                        job.error = update.error;
                    }

                    // If this is a parent job (no parent_id), populate status_report from update fields immediately
                    // This ensures UI shows current progress without waiting for debounced refresh
                    if (!job.parent_id && (update.progress_text || update.errors || update.warnings || update.running_children !== undefined)) {
                        if (!job.status_report) {
                            job.status_report = {};
                        }
                        if (update.progress_text) {
                            job.status_report.progress_text = update.progress_text;
                        }
                        if (update.errors) {
                            job.status_report.errors = update.errors;
                        }
                        if (update.warnings) {
                            job.status_report.warnings = update.warnings;
                        }
                        if (update.running_children !== undefined) {
                            job.status_report.running_children = update.running_children;
                        }
                    }

                    // Find job in filteredJobs BEFORE checking filters
                    const filteredIndex = this.filteredJobs.findIndex(j => j.id === update.job_id);

                    // If job is already in filteredJobs, keep it visible and update in-place (sticky visibility)
                    if (filteredIndex >= 0) {
                        this.filteredJobs[filteredIndex] = job;
                    } else {
                        // For NEW jobs that are not yet in filteredJobs, apply filters as normal
                        const matchesFilters = window.matchesActiveFilters(job);

                        if (matchesFilters) {
                            // Insert at correct position (sorted by created_at DESC)
                            const insertIndex = this.filteredJobs.findIndex(j => {
                                return new Date(j.created_at) < new Date(job.created_at);
                            });
                            if (insertIndex >= 0) {
                                this.filteredJobs.splice(insertIndex, 0, job);
                            } else {
                                this.filteredJobs.push(job);
                            }
                        }
                        // If doesn't match filters, don't add to filteredJobs (as before)
                    }

                    // If child job updated, refresh parent stats (debounced per parent_id)
                    if (job.parent_id) {
                        this.debouncedRefreshParent(job.parent_id);
                    }

                    // Trim to pageSize if on first page to maintain pagination consistency
                    if (this.currentPage === 1 && this.filteredJobs.length > this.pageSize) {
                        this.filteredJobs.length = this.pageSize;
                    }

                    // Re-render jobs
                    this.renderJobs();
                },

                // Reload job statistics from backend API (triggered by WebSocket updates)
                // Backend counts ALL jobs (both parent and child jobs) from database
                async recalculateStats() {
                    try {
                        const response = await fetch('/api/jobs/stats');
                        if (response.ok) {
                            const stats = await response.json();
                            // Dispatch event to update jobStatsHeader component
                            window.dispatchEvent(new CustomEvent('jobStats:update', { detail: stats }));
                        }
                    } catch (error) {
                        console.error('[Queue] Error reloading job stats:', error);
                    }
                },

                // Update job progress from crawler_job_progress WebSocket event
                updateJobProgress(progress) {
                    const jobIndex = this.allJobs.findIndex(j => j.id === progress.job_id);
                    if (jobIndex < 0) {
                        return; // Job not in current view
                    }

                    const job = this.allJobs[jobIndex];

                    // Update child job statistics
                    if (progress.total_children !== undefined) {
                        job.child_count = progress.total_children;
                        job.completed_children = progress.completed_children || 0;
                        job.failed_children = progress.failed_children || 0;
                        job.cancelled_children = progress.cancelled_children || 0;
                        job.pending_children = progress.pending_children || 0;
                        job.running_children = progress.running_children || 0;
                    }

                    // Update status_report with progress text
                    if (!job.status_report) {
                        job.status_report = {};
                    }
                    if (progress.progress_text) {
                        job.status_report.progress_text = progress.progress_text;
                    }
                    if (progress.running_children !== undefined) {
                        job.status_report.running_children = progress.running_children;
                    }
                    if (progress.errors) {
                        job.status_report.errors = progress.errors;
                    }
                    if (progress.warnings) {
                        job.status_report.warnings = progress.warnings;
                    }

                    // Update progress object
                    if (!job.progress) {
                        job.progress = {};
                    }
                    if (progress.overall_progress !== undefined) {
                        job.progress.percentage = progress.overall_progress * 100;
                    }

                    // Re-render to show updated progress
                    this.renderJobs();
                },

                // Debounced parent refresh to reduce load under high child job churn
                debouncedRefreshParent(parentId) {
                    // Clear any existing timeout for this parent
                    if (this.parentRefreshTimeouts.has(parentId)) {
                        clearTimeout(this.parentRefreshTimeouts.get(parentId));
                    }

                    // Set new timeout to fetch parent after 400ms
                    const timeoutId = setTimeout(async () => {
                        try {
                            const parentResponse = await fetch(`/api/jobs/${parentId}`);
                            if (parentResponse.ok) {
                                const updatedParent = await parentResponse.json();

                                // Update parent in allJobs array
                                const parentIndex = this.allJobs.findIndex(j => j.id === parentId);
                                if (parentIndex >= 0) {
                                    this.allJobs[parentIndex] = updatedParent;
                                }

                                // Update parent in filteredJobs array if it exists there
                                const filteredParentIndex = this.filteredJobs.findIndex(j => j.id === parentId);
                                if (filteredParentIndex >= 0) {
                                    this.filteredJobs[filteredParentIndex] = updatedParent;
                                }

                                // Re-render to show updated parent stats
                                this.renderJobs();
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to update parent stats after child update:', error);
                        } finally {
                            // Remove timeout from map after execution
                            this.parentRefreshTimeouts.delete(parentId);
                        }
                    }, 400); // 400ms debounce window (within 300-500ms recommended range)

                    // Store timeout ID
                    this.parentRefreshTimeouts.set(parentId, timeoutId);
                },

                toggleJobJson(jsonId) {
                    const jsonElement = document.getElementById(jsonId);
                    if (jsonElement) {
                        if (jsonElement.style.display === 'none') {
                            jsonElement.style.display = 'block';
                        } else {
                            jsonElement.style.display = 'none';
                        }
                    }
                },

                // Helper function to get the correct status badge HTML based on type
                getStatusBadgeHtml(type, status) {
                    // This method is now handled via separate functions for Alpine binding
                    return this.getStatusBadgeClass(type, status);
                },

                // Open error details modal
                openErrorDetailsModal(job) {
                    window.dispatchEvent(new CustomEvent('errorDetailsModal:open', {
                        detail: { job: job }
                    }));
                },

                // Navigate to job details page
                navigateToJobDetails(jobId) {
                    if (jobId) {
                        window.location.href = `/job?id=${jobId}`;
                    }
                },

                // Crawler-specific helper functions
                isCrawlerJob(job) {
                    return job && (job.job_type === 'crawler' || job.job_type === 'parent' ||
                        (job.config && (job.config.start_urls || job.config.seed_urls)) ||
                        job.seed_urls || job.source_type === 'crawler');
                },

                getCrawlerProgressText(job) {
                    if (!job) return 'No data';

                    const progress = job.progress || {};
                    const completed = progress.completed_urls || 0;
                    const total = progress.total_urls || 0;
                    const failed = progress.failed_urls || 0;

                    if (total === 0) {
                        return job.status === 'running' ? 'Starting...' : 'No URLs processed';
                    }

                    return `${completed} of ${total} URLs processed${failed > 0 ? ` (${failed} failed)` : ''}`;
                },

                getCrawlerProgressPercentage(job) {
                    if (!job || !job.progress) return 0;

                    const progress = job.progress;
                    const completed = progress.completed_urls || 0;
                    const total = progress.total_urls || 0;

                    if (total === 0) return 0;
                    return Math.round((completed / total) * 100);
                },

                getCrawlerProgressColor(job) {
                    if (!job) return '#e0e0e0';

                    const status = job.status;
                    const progress = job.progress || {};
                    const failed = progress.failed_urls || 0;
                    const total = progress.total_urls || 0;

                    if (status === 'failed') return '#ef4444';
                    if (status === 'completed') return '#10b981';
                    if (status === 'running') return '#3b82f6';
                    if (failed > 0 && total > 0 && (failed / total) > 0.1) return '#f59e0b'; // Warning if >10% failed

                    return '#3b82f6';
                },

                getCrawlerStat(job, statName) {
                    if (!job) return 0;

                    // Check progress object first
                    if (job.progress && job.progress[statName] !== undefined) {
                        return job.progress[statName];
                    }

                    // Check status_report object
                    if (job.status_report && job.status_report[statName] !== undefined) {
                        return job.status_report[statName];
                    }

                    // Handle specific stat mappings
                    switch (statName) {
                        case 'links_found':
                            return job.progress?.total_urls || job.status_report?.total_urls || 0;
                        case 'links_filtered':
                            return job.progress?.filtered_urls || job.status_report?.filtered_urls || 0;
                        case 'links_followed':
                            return job.progress?.completed_urls || job.status_report?.completed_urls || 0;
                        case 'max_depth':
                            return job.config?.max_depth || job.progress?.max_depth || job.status_report?.max_depth || 1;
                        default:
                            return 0;
                    }
                }
            }));

            // Register jobLogsModal component
            Alpine.data('jobLogsModal', () => ({
                currentJobId: null,
                logs: [],
                loading: false,
                selectedLogLevel: 'all',
                includeChildren: true,
                autoScroll: true,
                isStreaming: false,
                logBuffer: [],
                flushTimer: null,
                flushBufferSize: 50, // Flush buffer when it reaches 50 entries
                maxLogs: 1000,
                childJobIds: new Set(),
                wsEventListener: null,
                wsStateListener: null,
                openListener: null,
                unloadListener: null,

                init() {
                    // Listen for external modal open requests
                    this.openListener = (e) => this.openModal(e.detail.jobId);
                    window.addEventListener('jobLogsModal:open', this.openListener);

                    // Add WebSocket log event listener
                    this.wsEventListener = (e) => this.handleWebSocketLog(e.detail);
                    window.addEventListener('jobLogs:newLog', this.wsEventListener);

                    // Listen for streaming state changes
                    this.wsStateListener = (e) => {
                        this.isStreaming = e.detail.isStreaming;
                    };
                    window.addEventListener('jobLogs:streamingStateChange', this.wsStateListener);

                    // Add page unload safety net to clean up listeners
                    this.unloadListener = () => this.destroy();
                    window.addEventListener('beforeunload', this.unloadListener);
                },

                destroy() {
                    // Remove all event listeners
                    if (this.openListener) {
                        window.removeEventListener('jobLogsModal:open', this.openListener);
                        this.openListener = null;
                    }
                    if (this.wsEventListener) {
                        window.removeEventListener('jobLogs:newLog', this.wsEventListener);
                        this.wsEventListener = null;
                    }
                    if (this.wsStateListener) {
                        window.removeEventListener('jobLogs:streamingStateChange', this.wsStateListener);
                        this.wsStateListener = null;
                    }
                    if (this.unloadListener) {
                        window.removeEventListener('beforeunload', this.unloadListener);
                        this.unloadListener = null;
                    }
                },

                async openModal(jobId) {
                    this.currentJobId = jobId;
                    this.includeChildren = true;
                    this.autoScroll = true;
                    this.isStreaming = wsConnected;
                    this.childJobIds.clear();

                    // Auto-filter to error level if job is failed
                    // Fetch job status to determine initial log level
                    this.selectedLogLevel = 'all';
                    try {
                        const response = await fetch(`/api/jobs/${jobId}`);
                        if (response.ok) {
                            const job = await response.json();
                            if (job.status === 'failed') {
                                this.selectedLogLevel = 'error';
                            }
                        }
                    } catch (error) {
                        console.warn('Failed to fetch job status:', error);
                        this.selectedLogLevel = 'all';
                    }

                    const modal = document.getElementById('job-logs-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');
                    await this.loadLogs();
                },

                closeModal() {
                    // Remove WebSocket state listener to minimize live listeners while closed
                    if (this.wsStateListener) {
                        window.removeEventListener('jobLogs:streamingStateChange', this.wsStateListener);
                        this.wsStateListener = null;
                    }

                    const modal = document.getElementById('job-logs-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');
                    this.currentJobId = null;
                    this.logs = [];
                    this.isStreaming = false;
                    this.clearLogBuffer();
                    this.childJobIds.clear();
                },

                // Normalize log level to canonical lowercase form
                normalizeLevel(str, forFilter = false) {
                    if (!str) return '';
                    let normalized = String(str).toLowerCase().trim();

                    // Special case: preserve 'all' for filter comparisons
                    if (forFilter && normalized === 'all') {
                        return 'all';
                    }

                    // Map warn -> warning
                    if (normalized === 'warn') {
                        normalized = 'warning';
                    }
                    // Validate known levels
                    const validLevels = ['error', 'warning', 'info', 'debug'];
                    if (!validLevels.includes(normalized)) {
                        console.debug('Unknown log level:', str, 'defaulting to info');
                        return 'info';
                    }
                    return normalized;
                },

                async loadLogs() {
                    if (!this.currentJobId) return;

                    this.loading = true;
                    try {
                        // First, fetch metadata to get child job IDs
                        // Clear childJobIds before rebuilding to reset scope
                        this.childJobIds.clear();

                        const metadataParams = new URLSearchParams();
                        metadataParams.append('include_children', String(this.includeChildren));
                        metadataParams.append('metadata_only', 'true');

                        const metadataResponse = await fetch(`/api/jobs/${this.currentJobId}/logs/aggregated?${metadataParams.toString()}`);
                        if (metadataResponse.ok) {
                            const metadataData = await metadataResponse.json();
                            // Rebuild childJobIds from metadata based on current includeChildren setting
                            if (metadataData.metadata) {
                                Object.keys(metadataData.metadata).forEach(id => this.childJobIds.add(id));
                            }
                        }

                        // Build query string with level and include_children parameters
                        const params = new URLSearchParams();
                        if (this.selectedLogLevel !== 'all') {
                            params.append('level', this.selectedLogLevel);
                        }
                        params.append('include_children', this.includeChildren);
                        params.append('order', 'asc');

                        const response = await fetch(`/api/jobs/${this.currentJobId}/logs/aggregated?${params.toString()}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch job logs');
                        }

                        const data = await response.json();
                        const rawLogs = data.logs || [];

                        // Parse logs into flat array
                        this.logs = rawLogs.map(log => this._parseEnrichedLogEntry(log));

                        // Scroll to bottom if auto-scroll is enabled
                        if (this.autoScroll) {
                            this.scrollToBottom();
                        }
                    } catch (error) {
                        console.error('Error loading job logs:', error);
                        window.showNotification('Failed to load logs: ' + error.message, 'error');
                        this.logs = [];
                    } finally {
                        this.loading = false;
                    }
                },

                handleWebSocketLog(logData) {
                    // Filter by job: check if log matches current job
                    if (logData.job_id !== this.currentJobId) {
                        // Only check child jobs if includeChildren is enabled
                        if (!this.includeChildren || !this.childJobIds.has(logData.job_id)) {
                            return;
                        }
                    }

                    // Apply level filter using normalized levels
                    // Use forFilter=true to preserve 'all' during filtering
                    const sel = this.normalizeLevel(this.selectedLogLevel, true);
                    const lvl = this.normalizeLevel(logData.level);
                    if (sel !== 'all' && lvl !== sel) {
                        return;
                    }

                    // Parse and add to buffer
                    const entry = this._parseLogEntry(logData);
                    this.logBuffer.push(entry);

                    // Flush immediately if buffer exceeds size threshold
                    if (this.logBuffer.length >= this.flushBufferSize) {
                        this.flushLogBuffer();
                    } else if (!this.flushTimer) {
                        // Schedule flush if not already scheduled
                        this.scheduleFlush();
                    }
                },

                scheduleFlush() {
                    this.flushTimer = setTimeout(() => this.flushLogBuffer(), 500);
                },

                flushLogBuffer() {
                    if (this.logBuffer.length === 0) {
                        this.flushTimer = null;
                        return;
                    }

                    // Append buffer to logs
                    this.logs.push(...this.logBuffer);
                    this.logBuffer = [];

                    // Clear timer
                    this.flushTimer = null;

                    // Trim logs if exceeds maxLogs
                    if (this.logs.length > this.maxLogs) {
                        this.logs = this.logs.slice(-this.maxLogs);
                    }

                    // Auto-scroll if enabled
                    if (this.autoScroll) {
                        this.scrollToBottom();
                    }
                },

                clearLogBuffer() {
                    this.logBuffer = [];
                    if (this.flushTimer) {
                        clearTimeout(this.flushTimer);
                        this.flushTimer = null;
                    }
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const container = this.$refs.logContainer;
                        if (container) {
                            container.scrollTop = container.scrollHeight;
                        }
                    });
                },

                handleScroll() {
                    const container = this.$refs.logContainer;
                    const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
                    this.autoScroll = isAtBottom;
                },

                toggleAutoScroll() {
                    this.autoScroll = !this.autoScroll;
                    if (this.autoScroll) {
                        this.scrollToBottom();
                    }
                },

                clearLogs() {
                    this.logs = [];
                    this.clearLogBuffer();
                    window.showNotification('Logs cleared', 'info');
                },

                downloadLogs() {
                    const content = this.logs.map(log => {
                        const jobContext = log.job_name ? `[${log.job_name}] ` : '';
                        return `[${log.timestamp}] [${log.level}] ${jobContext}${log.message}`;
                    }).join('\n');

                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const filename = `job-logs-${this.currentJobId.substring(0, 8)}-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    window.showNotification('Logs downloaded', 'success');
                },

                _parseEnrichedLogEntry(logData) {
                    const timestamp = logData.timestamp || logData.time || new Date().toISOString();
                    const level = (logData.level || 'INFO').toUpperCase();
                    const message = logData.message || logData.msg || '';
                    // Store canonical lowercase level for downstream logic
                    const canonicalLevel = this.normalizeLevel(logData.level);

                    return {
                        timestamp: this._formatLogTime(timestamp),
                        full_timestamp: timestamp,
                        level: canonicalLevel,
                        levelClass: this._getLevelClass(level.toUpperCase()),
                        message: message,
                        job_id: logData.job_id,
                        job_name: logData.job_name,
                        job_url: logData.job_url,
                        job_depth: logData.job_depth,
                        job_type: logData.job_type,
                        parent_id: logData.parent_id
                    };
                },

                _parseLogEntry(logData) {
                    const timestamp = logData.timestamp || logData.time || new Date().toISOString();
                    const level = (logData.level || 'INFO').toUpperCase();
                    const message = logData.message || logData.msg || '';
                    // Store canonical lowercase level for downstream logic
                    const canonicalLevel = this.normalizeLevel(logData.level);

                    return {
                        timestamp: this._formatLogTime(timestamp),
                        full_timestamp: timestamp,
                        level: canonicalLevel,
                        levelClass: this._getLevelClass(level.toUpperCase()),
                        message: message,
                        job_id: logData.job_id,
                        job_name: logData.job_name,
                        job_url: logData.job_url,
                        job_depth: logData.job_depth,
                        job_type: logData.job_type,
                        parent_id: logData.parent_id
                    };
                },

                _formatLogTime(timestamp) {
                    // If timestamp is already formatted as HH:MM:SS, return as-is
                    if (typeof timestamp === 'string' && /^\d{2}:\d{2}:\d{2}$/.test(timestamp)) {
                        return timestamp;
                    }

                    // Otherwise try to parse as date
                    const date = new Date(timestamp);
                    if (isNaN(date.getTime())) {
                        return timestamp; // Return original if can't parse
                    }

                    return date.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },

                _getLevelClass(level) {
                    const levelMap = {
                        'ERROR': 'terminal-error',
                        'WARN': 'terminal-warning',
                        'WARNING': 'terminal-warning',
                        'INFO': 'terminal-info',
                        'DEBUG': 'terminal-time'
                    };
                    return levelMap[level] || 'terminal-info';
                },

                toggleErrorsOnly() {
                    this.selectedLogLevel = this.selectedLogLevel.toLowerCase() === 'error' ? 'all' : 'error';
                    this.loadLogs();
                }
            }));

            // Register deleteConfirmModal component
            Alpine.data('deleteConfirmModal', () => ({
                jobs: [],
                totalChildren: 0,
                checkboxChecked: false,
                resolvePromise: null,
                currentResolverId: null,

                init() {
                    // Listen for deleteConfirmModal:open events
                    window.addEventListener('deleteConfirmModal:open', async (e) => {
                        const { jobDetails, totalChildren, resolverId } = e.detail;
                        await this.open(jobDetails, totalChildren, resolverId);
                    });
                },

                async open(jobDetails, totalChildren, resolverId = null) {
                    // Use the pre-built job details passed from caller
                    this.jobs = jobDetails || [];
                    this.totalChildren = totalChildren || 0;

                    // Show modal
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');

                    // Create promise and store resolver
                    this.currentResolverId = resolverId;
                    return new Promise((resolve) => {
                        this.resolvePromise = resolve;
                        // Store resolver in global map if resolverId provided
                        if (resolverId && window.deleteModalResolvers) {
                            window.deleteModalResolvers.set(resolverId, resolve);
                        }
                    });
                },

                closeModal() {
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');

                    if (this.resolvePromise) {
                        this.resolvePromise(false);
                        this.resolvePromise = null;
                    }
                    // Clean up resolver from global map
                    if (this.currentResolverId && window.deleteModalResolvers) {
                        window.deleteModalResolvers.delete(this.currentResolverId);
                        this.currentResolverId = null;
                    }

                    // Clear data after resolving to prevent race condition with modal message
                    this.checkboxChecked = false;
                    this.jobs = [];
                    this.totalChildren = 0;
                },

                confirm() {
                    const modal = document.getElementById('delete-confirm-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');

                    if (this.resolvePromise) {
                        this.resolvePromise(true);
                        this.resolvePromise = null;
                    }
                    // Clean up resolver from global map
                    if (this.currentResolverId && window.deleteModalResolvers) {
                        window.deleteModalResolvers.delete(this.currentResolverId);
                        this.currentResolverId = null;
                    }

                    // Clear data after resolving to prevent race condition with modal message
                    this.checkboxChecked = false;
                    this.jobs = [];
                    this.totalChildren = 0;
                },

                getStatusDisplayText(status) {
                    const statusTexts = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return statusTexts[status] || 'Unknown';
                },

                getStatusBadgeClass(status) {
                    const badgeClasses = {
                        'pending': 'label-warning',
                        'running': 'label-primary',
                        'completed': 'label-success',
                        'failed': 'label-error',
                        'cancelled': 'label'
                    };
                    return badgeClasses[status] || 'label';
                }
            }));

            // Register errorDetailsModal component
            Alpine.data('errorDetailsModal', () => ({
                job: null,

                init() {
                    // Listen for errorDetailsModal:open events
                    window.addEventListener('errorDetailsModal:open', async (e) => {
                        const { job } = e.detail;
                        await this.open(job);
                    });
                },

                async open(job) {
                    this.job = job;
                    const modal = document.getElementById('error-details-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');
                },

                closeModal() {
                    const modal = document.getElementById('error-details-modal');
                    modal.classList.remove('active');
                    document.body.classList.remove('modal-open');
                    this.job = null;
                },

                getStatusDisplayText(status) {
                    const statusTexts = {
                        'pending': 'Pending',
                        'running': 'Running',
                        'completed': 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return statusTexts[status] || 'Unknown';
                },

                getStatusBadgeClass(status) {
                    const badgeClasses = {
                        'pending': 'label-warning',
                        'running': 'label-primary',
                        'completed': 'label-success',
                        'failed': 'label-error',
                        'cancelled': 'label'
                    };
                    return badgeClasses[status] || 'label';
                },

                getJobURL(job) {
                    if (!job) return null;
                    // Priority: seed_urls > current_url
                    if (job.seed_urls && job.seed_urls.length > 0) {
                        return job.seed_urls[0];
                    }
                    if (job.progress?.current_url) {
                        return job.progress.current_url;
                    }
                    return null;
                }
            }));
        });

        // Window helper function - dispatches event to Alpine component
        function deleteSelectedJobs() {
            window.dispatchEvent(new CustomEvent('jobList:deleteSelected'));
        }

        // Global function to open delete confirmation modal using event-based API
        async function openDeleteConfirmModal(jobDetails, totalChildren) {
            const resolverId = 'delete-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            return new Promise((resolve) => {
                window.deleteModalResolvers.set(resolverId, resolve);
                window.dispatchEvent(new CustomEvent('deleteConfirmModal:open', {
                    detail: { jobDetails: jobDetails, totalChildren: totalChildren, resolverId: resolverId }
                }));
            });
        }

        // Global function to open job logs modal
        function openJobLogsModal(jobId) {
            window.dispatchEvent(new CustomEvent('jobLogsModal:open', {
                detail: { jobId: jobId }
            }));
        }

        // Initialize highlight.js - only for job detail
        if (typeof hljs !== 'undefined') {
            const codeBlock = document.querySelector('#job-detail-json code');
            if (codeBlock) {
                hljs.highlightElement(codeBlock);
            }
        }
    </script>
</body>

</html>