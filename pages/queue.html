<!DOCTYPE html>
<html lang="en">

<head>
    {{template "head.html" .}}
    <title>Queue Management - Quaero</title>
    <style>
        /* Progress Bar Styles */
        .progress-container {
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 4px;
            height: 20px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #5755d9;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .progress-bar.progress-success {
            background-color: #32b643;
        }

        .progress-bar.progress-warning {
            background-color: #ffb700;
        }

        .progress-bar.progress-error {
            background-color: #e85600;
        }

        /* Parent Job Indicator */
        .parent-job-badge {
            display: inline-block;
            padding: 0.1rem 0.3rem;
            font-size: 0.7rem;
            border-radius: 2px;
            background-color: #5755d9;
            color: white;
            margin-left: 0.25rem;
        }
    </style>
</head>

<body>

    {{template "navbar.html" .}}

    <main class="page-container">

        <!-- Page Title -->
        <div class="page-title">
            <h1>Queue Management</h1>
            <p>Monitor and manage running crawler jobs</p>
            <div class="text-small text-gray" style="margin-top: 0.5rem;">
                <i class="fa-solid fa-lightbulb"></i>
                To create or edit job definitions, visit the <a href="/jobs">Jobs</a> page
            </div>
        </div>

        <!-- Job Statistics -->
        <section>
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Statistics</h3>
                        </section>
                        <section class="navbar-section">
                            <button class="btn btn-sm" onclick="loadStats()">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body">
                    <div class="columns">
                        <div class="column text-center">
                            <p class="text-small text-gray">TOTAL JOBS</p>
                            <p class="h2" id="stat-total">-</p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">PENDING</p>
                            <p class="h2 text-warning" id="stat-pending">-</p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">RUNNING</p>
                            <p class="h2 text-primary" id="stat-running">-</p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">COMPLETED</p>
                            <p class="h2 text-success" id="stat-completed">-</p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">FAILED</p>
                            <p class="h2 text-error" id="stat-failed">-</p>
                        </div>
                        <div class="column text-center">
                            <p class="text-small text-gray">CANCELLED</p>
                            <p class="h2 text-warning" id="stat-cancelled">-</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Job Queue -->
        <section>
            <div class="card">
                <div class="card-header">
                    <header class="navbar">
                        <section class="navbar-section">
                            <h3>Job Queue</h3>
                        </section>
                        <section class="navbar-section">
                            <div x-data="queueStatsHeader" x-init="init()" style="display: flex; align-items: center; gap: 1rem; font-size: 0.8rem; margin-right: 1rem;">
                                <span class="text-gray">
                                    <span x-text="pending">0</span> Pending
                                </span>
                                <span class="text-gray">
                                    <span x-text="inFlight">0</span> In-Flight
                                </span>
                                <span class="text-gray">
                                    <span x-text="workers">0</span> Workers
                                </span>
                                <span class="label" :class="connected ? 'label-success' : 'label-error'" x-text="connected ? 'Connected' : 'Disconnected'"></span>
                            </div>
                            <button id="delete-selected-btn" class="btn btn-sm btn-error" onclick="deleteSelectedJobs()" title="Delete Selected" style="display: none;">
                                <i class="fa-solid fa-trash"></i>
                                <span id="delete-selected-text">Delete Selected</span>
                            </button>
                            <button class="btn btn-sm" onclick="event.preventDefault(); window.dispatchEvent(new CustomEvent('jobList:load'))" title="Refresh Jobs">
                                <i class="fa-solid fa-rotate-right"></i>
                            </button>
                        </section>
                    </header>
                </div>
                <div class="card-body" x-data="jobList" x-init="init()">
                    <!-- Filter Button and Chips -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <button type="button" class="btn btn-sm" onclick="showFilterModal()">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                        <button type="button" class="btn btn-sm" @click="toggleShowChildJobs()" :class="showChildJobs ? 'btn-primary' : ''" id="toggle-children-btn">
                            <i class="fas fa-sitemap"></i> <span x-text="showChildJobs ? 'Show Parent Jobs Only' : 'Show All Jobs'" id="toggle-children-text"></span>
                        </button>
                        <div id="filter-chips-container"></div>
                    </div>

                    <!-- Select All Checkbox -->
                    <div style="margin-bottom: 0.8rem;">
                        <label class="form-checkbox">
                            <input type="checkbox" id="select-all-checkbox" @change="toggleSelectAll()">
                            <i class="form-icon"></i> Select All
                        </label>
                    </div>

                    <!-- Jobs Cards Container -->
                    <div id="jobs-cards-container">
                        <template x-for="item in itemsToRender" :key="item.job.id + (item.type || 'flat')">
                            <div>
                                <!-- Loading indicator for expanding parents -->
                                <template x-if="item.type === 'loading'">
                                    <div class="loading-children" style="margin-left: 2rem; margin-bottom: 0.8rem; padding: 0.5rem; color: #888;">
                                        <i class="fas fa-spinner fa-pulse"></i>
                                        <span>Loading children...</span>
                                    </div>
                                </template>

                                <!-- Job card -->
                                <template x-if="item.type !== 'loading'">
                                    <div class="card" :class="{
                                            'bg-gray': selectedJob && selectedJob.id === item.job.id,
                                            'job-card-parent': item.type === 'parent',
                                            'job-card-child': item.type === 'child',
                                            'job-card-flat': item.type === 'flat'
                                        }" style="margin-bottom: 0.8rem;">
                                <div class="card-body">
                                    <div class="columns">
                                        <!-- Left side: Checkbox and Content -->
                                        <div class="column col-1" @click.stop>
                                            <label class="form-checkbox">
                                                <input type="checkbox" class="job-checkbox" :data-job-id="item.job.id"
                                                       @change="toggleJobSelection(item.job.id)" :checked="selectedJobIds.has(item.job.id)">
                                                <i class="form-icon"></i>
                                            </label>
                                        </div>
                                        <div class="column col-9">
                                            <div class="card-title h5" :title="item.job.id || 'N/A'">
                                                <template x-if="item.type === 'parent'">
                                                    <button class="expand-collapse-btn" @click.stop="toggleParentExpansion(item.job.id)"
                                                            :class="expandedParents.has(item.job.id) ? 'expanded' : ''">
                                                        <i class="fas fa-chevron-right"></i>
                                                    </button>
                                                </template>
                                                <i class="fas" :class="item.type === 'child' ? 'fa-file job-type-icon child-icon' : 'fa-folder job-type-icon parent-icon'"></i>
                                                Job ID: <span x-text="item.job.id ? item.job.id.substring(0, 8) : 'N/A'"></span>
                                                <template x-if="item.type === 'parent'">
                                                    <span class="parent-job-badge">PARENT</span>
                                                </template>
                                                <template x-if="item.type === 'parent' && item.job.entity_type === 'job_definition'">
                                                    <span class="label label-info" style="margin-left: 0.5rem; font-size: 0.7rem;">JOB DEFINITION</span>
                                                </template>
                                            </div>
                                            <div class="card-subtitle text-gray" x-text="'Source: ' + (item.job.source_type || 'N/A')"></div>

                                            <!-- Metadata -->
                                            <div style="margin-top: 0.8rem; display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem;">
                                                <!-- Status Badge -->
                                                <div>
                                                    <span class="label"
                                                          :class="getStatusBadgeClass(item.type, item.job.status, item.job)"
                                                          x-text="getStatusBadgeText(item.type, item.job.status, item.job)"></span>
                                                </div>
                                                <!-- Documents -->
                                                <div>
                                                    <i class="fas fa-file-alt"></i>
                                                    <span x-text="(() => { const count = getDocumentsCount(item.job); return (typeof count === 'number' ? count : 'N/A') + ' Documents'; })()"></span>
                                                </div>
                                                <!-- Created Date -->
                                                <div>
                                                    <i class="fas fa-calendar"></i>
                                                    <span x-text="getCreatedDate(item.job)"></span>
                                                </div>
                                                <!-- Toggle JSON -->
                                                <div>
                                                    <a href="#" class="text-primary" @click.prevent.stop="toggleJobJson('job-json-' + $id(item.job.id))">
                                                        <i class="fas fa-code"></i> Show Configuration
                                                    </a>
                                                </div>
                                            </div>
                                            
                                            <!-- Parent progress display -->
                                            <template x-if="item.type === 'parent'">
                                                <div class="parent-progress">
                                                    <div class="parent-progress-text" 
                                                         x-text="getParentProgressText(item.job)"
                                                         :style="getParentProgressStyle(item.job)"></div>
                                                    <div class="parent-progress-bar">
                                                        <div class="parent-progress-bar-fill" 
                                                             :style="getParentProgressBarStyle(item.job)"></div>
                                                    </div>
                                                </div>
                                            </template>
                                        </div>

                                        <!-- Right side: Actions -->
                                        <div class="column col-2 text-right" style="flex-shrink: 0;" @click.stop>
                                            <template x-if="item.job.status !== 'running'">
                                                <button class="btn btn-sm" @click="window.rerunJob(item.job.id)" title="Copy Job and Add to Queue">
                                                    <i class="fa-solid fa-rotate-right"></i>
                                                </button>
                                            </template>
                                            <template x-if="item.job.status === 'running'">
                                                <button class="btn btn-sm btn-warning" @click="window.cancelJob(item.job.id)" title="Cancel Job">
                                                    <i class="fas fa-stop"></i>
                                                </button>
                                            </template>
                                            <template x-if="item.job.status !== 'running'">
                                                <button class="btn btn-sm btn-error" @click="window.deleteJob(item.job.id)" title="Delete Job">
                                                    <i class="fas fa-trash"></i>
                                                </button>
                                            </template>
                                        </div>
                                    </div>

                                    <!-- Job Configuration (Collapsible JSON) -->
                                    <div :id="'job-json-' + $id(item.job.id)" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                                        <pre style="background-color: #ffffff; padding: 1rem; border: 1px solid #e0e0e0; border-radius: 4px; overflow-x: auto; max-height: 400px;"><code class="language-json" x-text="JSON.stringify(item.job, null, 2)"></code></pre>
                                    </div>
                                </div>
                            </div>
                                </template>
                            </div>
                        </template>

                        <!-- No jobs message -->
                        <template x-if="itemsToRender.length === 0">
                            <div class="text-center text-gray" style="padding: 2rem;">
                                <span x-text="filteredJobs.length === 0 ? 'No jobs found matching the current filters.' : 'Loading jobs...'"></span>
                            </div>
                        </template>
                    </div>

                    <!-- Pagination Controls -->
                    <div id="job-pagination-container" class="pagination-container">
                        <!-- Pagination handled by separate function -->
                    </div>
                </div>
            </div>
        </section>


        <!-- Service Logs -->
        <section>
            {{template "service-logs.html" .}}
        </section>

    </main>

    {{template "footer.html" .}}

    {{template "snackbar.html" .}}

    <!-- Filter Modal -->
    <div id="filter-modal" class="modal">
        <a href="#close" class="modal-overlay" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
        <div class="modal-container" role="dialog" aria-modal="true">
            <div class="modal-header">
                <a href="#close" class="btn btn-clear float-right" aria-label="Close" onclick="event.preventDefault(); closeFilterModal()"></a>
                <div class="modal-title h5">Filter Crawler Jobs</div>
            </div>
            <div class="modal-body">
                <div class="content">
                    <!-- Status Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Status</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="pending" checked>
                            <i class="form-icon"></i> Pending
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="running" checked>
                            <i class="form-icon"></i> Running
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="completed" checked>
                            <i class="form-icon"></i> Completed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="failed" checked>
                            <i class="form-icon"></i> Failed
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-status" value="cancelled" checked>
                            <i class="form-icon"></i> Cancelled
                        </label>
                    </div>

                    <!-- Source Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Source Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="jira">
                            <i class="form-icon"></i> Jira
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-source" value="confluence">
                            <i class="form-icon"></i> Confluence
                        </label>
                    </div>

                    <!-- Entity Type Filters -->
                    <div class="form-group">
                        <label class="form-label"><strong>Entity Type</strong></label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="projects">
                            <i class="form-icon"></i> Projects
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="spaces">
                            <i class="form-icon"></i> Spaces
                        </label>
                        <label class="form-checkbox">
                            <input type="checkbox" class="filter-entity" value="repos">
                            <i class="form-icon"></i> Repos
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" onclick="clearAllFilters()">Clear All</button>
                <button type="button" class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
            </div>
        </div>
    </div>

    <script>
        // State management (moved to Alpine component jobList)
        let allJobs = [];
        let filteredJobs = [];
        let selectedJob = null;

        // Hierarchy state management
        let showChildJobs = false; // Toggle between parent-only and all-jobs view
        let expandedParents = new Set(); // Track expanded parent jobs
        let childJobsCache = new Map(); // Cache: parentID -> array of child jobs
        let loadingParents = new Set(); // Track parents currently loading children

        // WebSocket connection state
        let jobsWS = null;
        let wsConnected = false;
        let wsReconnectAttempts = 0;
        const WS_MAX_RECONNECT_DELAY = 30000; // 30 seconds
        const WS_INITIAL_RECONNECT_DELAY = 1000; // 1 second

        // Default filters - include all statuses
        const defaultFilters = {
            status: new Set(['pending', 'running', 'completed', 'failed', 'cancelled']),
            source: new Set(),
            entity: new Set()
        };

        // Filter state - initialize immediately with defaults to prevent undefined errors
        let activeFilters = {
            status: new Set(defaultFilters.status),
            source: new Set(defaultFilters.source),
            entity: new Set(defaultFilters.entity)
        };

        // Initialize filters immediately on script load
        window.activeFilters = activeFilters;

        // Load filters from localStorage
        function loadFiltersFromStorage() {
            try {
                const stored = localStorage.getItem('quaero-job-filters');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    activeFilters.status = new Set(parsed.status || []);
                    activeFilters.source = new Set(parsed.source || []);
                    activeFilters.entity = new Set(parsed.entity || []);

                    // If no filters were saved, use defaults
                    if (activeFilters.status.size === 0 && activeFilters.source.size === 0 && activeFilters.entity.size === 0) {
                        activeFilters = {
                            status: new Set(defaultFilters.status),
                            source: new Set(defaultFilters.source),
                            entity: new Set(defaultFilters.entity)
                        };
                    }
                } else {
                    // Use defaults for first time users
                    activeFilters = {
                        status: new Set(defaultFilters.status),
                        source: new Set(defaultFilters.source),
                        entity: new Set(defaultFilters.entity)
                    };
                }
            } catch (error) {
                console.warn('Failed to load filters from localStorage:', error);
                // Use defaults on error
                activeFilters = {
                    status: new Set(defaultFilters.status),
                    source: new Set(defaultFilters.source),
                    entity: new Set(defaultFilters.entity)
                };
            }
        }

        // Save filters to localStorage
        function saveFiltersToStorage() {
            try {
                const toSave = {
                    status: Array.from(activeFilters.status),
                    source: Array.from(activeFilters.source),
                    entity: Array.from(activeFilters.entity)
                };
                localStorage.setItem('quaero-job-filters', JSON.stringify(toSave));
            } catch (error) {
                console.warn('Failed to save filters to localStorage:', error);
            }
        }

        // Load job statistics
        async function loadStats() {
            console.log('[Queue] loadStats() called');
            try {
                console.log('[Queue] Fetching stats from /api/jobs/stats');
                const response = await fetch('/api/jobs/stats');
                console.log('[Queue] Stats response status:', response.status);

                if (!response.ok) throw new Error('Failed to fetch stats');

                const stats = await response.json();
                console.log('[Queue] Stats data:', stats);

                document.getElementById('stat-total').textContent = stats.total_jobs || 0;
                document.getElementById('stat-pending').textContent = stats.pending_jobs || 0;
                document.getElementById('stat-running').textContent = stats.running_jobs || 0;
                document.getElementById('stat-completed').textContent = stats.completed_jobs || 0;
                document.getElementById('stat-failed').textContent = stats.failed_jobs || 0;
                document.getElementById('stat-cancelled').textContent = stats.cancelled_jobs || 0;

            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('stat-total').textContent = 'Error';
                document.getElementById('stat-running').textContent = 'Error';
                document.getElementById('stat-completed').textContent = 'Error';
                document.getElementById('stat-failed').textContent = 'Error';
                document.getElementById('stat-cancelled').textContent = 'Error';
            }
        }

        // Load all jobs - dispatches event to Alpine component
        function loadJobs() {
            window.dispatchEvent(new CustomEvent('jobList:load'));
        }

        // Wrapper function for loadJobs() - maintains compatibility
        function loadJobQueue() {
            loadJobs();
        }


        // Update job in list from WebSocket update - dispatches event to Alpine component
        async function updateJobInList(update) {
            window.dispatchEvent(new CustomEvent('jobList:updateJob', { detail: update }));
        }

        // Check if job matches active filters
        function matchesActiveFilters(job) {
            // Check status filter
            if (activeFilters.status.size > 0 && !activeFilters.status.has(job.status)) {
                return false;
            }

            // Check source filter
            if (activeFilters.source.size > 0 && !activeFilters.source.has(job.source_type)) {
                return false;
            }

            // Check entity filter
            if (activeFilters.entity.size > 0 && !activeFilters.entity.has(job.entity_type)) {
                return false;
            }

            return true;
        }

        // Show filter modal
        function showFilterModal() {
            const modal = document.getElementById('filter-modal');

            // Sync modal checkboxes with activeFilters state
            document.querySelectorAll('.filter-status').forEach(checkbox => {
                checkbox.checked = activeFilters.status.has(checkbox.value);
            });
            document.querySelectorAll('.filter-source').forEach(checkbox => {
                checkbox.checked = activeFilters.source.has(checkbox.value);
            });
            document.querySelectorAll('.filter-entity').forEach(checkbox => {
                checkbox.checked = activeFilters.entity.has(checkbox.value);
            });

            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }

        // Close filter modal
        function closeFilterModal() {
            const modal = document.getElementById('filter-modal');
            modal.classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Apply filters from modal
        function applyFilters() {
            // Update activeFilters from modal checkboxes
            activeFilters.status.clear();
            document.querySelectorAll('.filter-status:checked').forEach(cb => {
                activeFilters.status.add(cb.value);
            });

            activeFilters.source.clear();
            document.querySelectorAll('.filter-source:checked').forEach(cb => {
                activeFilters.source.add(cb.value);
            });

            activeFilters.entity.clear();
            document.querySelectorAll('.filter-entity:checked').forEach(cb => {
                activeFilters.entity.add(cb.value);
            });

            // Save filters to localStorage
            saveFiltersToStorage();

            // Close modal and refresh
            closeFilterModal();
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
        }

        // Clear all filters
        function clearAllFilters() {
            // Uncheck all checkboxes in modal
            document.querySelectorAll('.filter-status, .filter-source, .filter-entity').forEach(cb => {
                cb.checked = false;
            });
        }

        // Render filter chips
        function renderFilterChips() {
            const container = document.getElementById('filter-chips-container');
            let html = '';

            // Status chips
            activeFilters.status.forEach(status => {
                const colorClass = {
                    'pending': 'label-warning',
                    'running': 'label-primary',
                    'completed': 'label-success',
                    'failed': 'label-error',
                    'cancelled': 'label-warning'
                }[status] || 'label-default';

                html += `
                    <span class="label ${colorClass}">
                        ${status.charAt(0).toUpperCase() + status.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('status', '${status}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Source chips
            activeFilters.source.forEach(source => {
                html += `
                    <span class="label label-primary">
                        ${source.charAt(0).toUpperCase() + source.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('source', '${source}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            // Entity chips
            activeFilters.entity.forEach(entity => {
                html += `
                    <span class="label label-primary">
                        ${entity.charAt(0).toUpperCase() + entity.slice(1)}
                        <a href="#" onclick="event.preventDefault(); removeFilter('entity', '${entity}')" class="btn btn-clear btn-sm" aria-label="Remove"></a>
                    </span>
                `;
            });

            container.innerHTML = html;
        }

        // Remove individual filter
        function removeFilter(category, value) {
            activeFilters[category].delete(value);
            saveFiltersToStorage(); // Save after removing filter
            renderFilterChips();
            // Reset to first page and reload jobs
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: 1 }
            }));
        }

        // Connect to WebSocket for real-time job updates
        function connectJobsWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            console.log('[Queue] Connecting to Jobs WebSocket:', wsUrl);
            jobsWS = new WebSocket(wsUrl);

            jobsWS.onopen = () => {
                console.log('[Queue] Jobs WebSocket connected');
                wsConnected = true;
                wsReconnectAttempts = 0;
                // Update queue stats header to show connected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: true }
                }));
            };

            jobsWS.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // console.log(`[Queue] WebSocket message received, type: ${message.type}`);

                    // Handle queue stats updates and forward to queueStatsHeader component
                    if (message.type === 'queue_stats' && message.payload) {
                        window.dispatchEvent(new CustomEvent('queueStats:update', {
                            detail: {
                                pending: message.payload.pending_messages || 0,
                                inFlight: message.payload.in_flight_messages || 0,
                                workers: message.payload.concurrency || 0,
                                connected: true
                            }
                        }));
                    }

                    // Handle job status change events
                    if (message.type === 'job_status_change' && message.payload) {
                        const update = message.payload;
                        updateJobInList(update);

                        // Update stats for terminal states
                        if (update.status === 'completed' || update.status === 'failed' || update.status === 'cancelled') {
                            loadStats();
                        }
                    }

                    // Handle job created events (future-proof)
                    if (message.type === 'job_created' && message.payload) {
                        updateJobInList(message.payload);
                        loadStats();
                    }

                    // Handle job progress events
                    if (message.type === 'job_progress' && message.payload) {
                        updateJobInList(message.payload);
                    }

                    // Handle job completed events
                    if (message.type === 'job_completed' && message.payload) {
                        updateJobInList(message.payload);
                        loadStats();
                    }
                } catch (error) {
                    console.error('[Queue] Error parsing WebSocket message:', error);
                }
            };

            jobsWS.onerror = (error) => {
                console.error('[Queue] Jobs WebSocket error:', error);
                wsConnected = false;
                // Update queue stats header to show disconnected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: false }
                }));
            };

            jobsWS.onclose = () => {
                wsConnected = false;
                // Update queue stats header to show disconnected
                window.dispatchEvent(new CustomEvent('queueStats:update', {
                    detail: { connected: false }
                }));

                // Calculate exponential backoff delay
                const delay = Math.min(
                    WS_INITIAL_RECONNECT_DELAY * Math.pow(2, wsReconnectAttempts),
                    WS_MAX_RECONNECT_DELAY
                );
                wsReconnectAttempts++;

                console.log('[Queue] Jobs WebSocket disconnected, reconnecting in', delay, 'ms');

                // Schedule reconnection
                setTimeout(() => {
                    connectJobsWebSocket();
                }, delay);
            };
        }

        // Render jobs - dispatches event to Alpine component
        function renderJobs() {
            window.dispatchEvent(new CustomEvent('jobList:render'));
        }

        // Custom pagination rendering - reads state from Alpine component
        function renderPagination(totalPages, currentPage) {
            const container = document.getElementById('job-pagination-container');
            if (!container) return;

            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let html = '<ul class="pagination">';

            // Previous button
            if (currentPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage - 1})">Previous</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Previous</a></li>';
            }

            // Page numbers (show max 7 pages)
            const maxVisible = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
            let endPage = Math.min(totalPages, startPage + maxVisible - 1);

            if (endPage - startPage < maxVisible - 1) {
                startPage = Math.max(1, endPage - maxVisible + 1);
            }

            if (startPage > 1) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(1)">1</a></li>`;
                if (startPage > 2) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
            }

            for (let i = startPage; i <= endPage; i++) {
                if (i === currentPage) {
                    html += `<li class="page-item active"><a href="#">${i}</a></li>`;
                } else {
                    html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${i})">${i}</a></li>`;
                }
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += '<li class="page-item disabled"><a href="#">...</a></li>';
                }
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${totalPages})">${totalPages}</a></li>`;
            }

            // Next button
            if (currentPage < totalPages) {
                html += `<li class="page-item"><a href="#" onclick="event.preventDefault(); changePage(${currentPage + 1})">Next</a></li>`;
            } else {
                html += '<li class="page-item disabled"><a href="#">Next</a></li>';
            }

            html += '</ul>';
            container.innerHTML = html;
        }

        // Pagination page change handler - dispatches event to Alpine component
        function changePage(pageNumber) {
            window.dispatchEvent(new CustomEvent('jobList:changePage', {
                detail: { page: pageNumber }
            }));
        }

        // Rerun a job
        async function rerunJob(jobId) {
            if (!confirm(`Copy and queue job ${jobId.substring(0, 8)}?\n\nThis will create a NEW job (copy) with the same configuration and add it to the queue.\nThe job will NOT execute immediately - it will be queued as "pending".\nThe original job will remain unchanged.`)) {
                return;
            }

            let button = null;
            if (typeof event !== 'undefined' && event && event.target && typeof event.target.closest === 'function') {
                button = event.target.closest('button');
            }

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/rerun`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to rerun job');
                }

                const result = await response.json();
                const newJobIdShort = result.new_job_id.substring(0, 8);

                // Show clear notification about the NEW job queued
                window.showNotification(
                    `Job copied and added to queue!\n` +
                    `Original: ${jobId.substring(0, 8)}... (unchanged)\n` +
                    `New Job: ${newJobIdShort}... (pending in queue)`,
                    'success'
                );

                // Refresh stats immediately
                loadStats();

                // Wait a moment for the new job to be inserted, then refresh and highlight
                setTimeout(async () => {
                    await loadJobs();

                    // Try to find and highlight the new job row
                    const newJobRow = document.querySelector(`td[title="${result.new_job_id}"]`)?.closest('tr');
                    if (newJobRow) {
                        // Briefly highlight the new job with animation
                        newJobRow.style.backgroundColor = '#48c774';
                        newJobRow.style.transition = 'background-color 2s ease-out';
                        setTimeout(() => {
                            newJobRow.style.backgroundColor = '';
                        }, 2000);
                    }
                }, 500);

            } catch (error) {
                console.error('Error rerunning job:', error);
                window.showNotification('Failed to rerun job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Cancel a running job
        async function cancelJob(jobId) {
            if (!confirm(`Cancel job ${jobId.substring(0, 8)}?\n\nThe job will be stopped immediately.`)) {
                return;
            }

            let button = null;
            if (typeof event !== 'undefined' && event && event.target && typeof event.target.closest === 'function') {
                button = event.target.closest('button');
            }

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}/cancel`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to cancel job');
                }

                window.showNotification('Job cancelled successfully', 'success');
                loadStats();
                // Note: loadJobs() removed - WebSocket will update job status automatically
            } catch (error) {
                console.error('Error cancelling job:', error);
                window.showNotification('Failed to cancel job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Delete a job
        async function deleteJob(jobId) {
            if (!confirm(`Delete job ${jobId.substring(0, 8)}?\n\nThis will permanently remove the job from the database.`)) {
                return;
            }

            let button = null;
            if (typeof event !== 'undefined' && event && event.target && typeof event.target.closest === 'function') {
                button = event.target.closest('button');
            }

            let originalIcon = null;
            if (button) {
                button.disabled = true;
                const iconElement = button.querySelector('i');
                if (iconElement) {
                    originalIcon = iconElement.className;
                    iconElement.className = 'fas fa-spinner fa-pulse';
                }
            }

            try {
                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete job');
                }

                window.showNotification('Job deleted successfully', 'success');

                // Remove job from allJobs array
                const allJobsIndex = allJobs.findIndex(job => job.id === jobId);
                if (allJobsIndex >= 0) {
                    allJobs.splice(allJobsIndex, 1);
                }

                // Remove job from filteredJobs array
                const filteredJobsIndex = filteredJobs.findIndex(job => job.id === jobId);
                if (filteredJobsIndex >= 0) {
                    filteredJobs.splice(filteredJobsIndex, 1);
                }

                // Re-render without API call
                renderJobs();
                loadStats();
            } catch (error) {
                console.error('Error deleting job:', error);
                window.showNotification('Failed to delete job: ' + error.message, 'error');
            } finally {
                if (button) {
                    button.disabled = false;
                    const iconElement = button.querySelector('i');
                    if (iconElement && originalIcon) {
                        iconElement.className = originalIcon;
                    }
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            console.log('[Queue] ==================== PAGE LOAD ====================');
            console.log('[Queue] DOMContentLoaded event fired');
            console.log('[Queue] Current URL:', window.location.href);
            console.log('[Queue] Initializing page components...');

            // Load filters from localStorage first
            loadFiltersFromStorage();
            console.log('[Queue] Loaded filters from storage:', activeFilters);

            // Initialize WebSocket connection for real-time job updates
            console.log('[Queue] Initializing WebSocket connection for job updates');
            connectJobsWebSocket();

            // Real-time updates via WebSocket (no polling fallback)
            // - Server pushes job status changes via job_status_change events
            // - Exponential backoff reconnection handles temporary disconnections
            // - Manual page refresh available as ultimate fallback

            renderFilterChips(); // Render initial filter chips
            loadStats();
            loadJobs();

            // Add ESC key handler for filter modal and other shortcuts
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('filter-modal');
                    if (modal && modal.classList.contains('active')) {
                        closeFilterModal();
                    }
                }
                // Toggle hierarchy view with 'h' key
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) {
                    const activeElement = document.activeElement;
                    if (activeElement.tagName !== 'INPUT' && activeElement.tagName !== 'TEXTAREA') {
                        window.dispatchEvent(new CustomEvent('jobList:toggleHierarchy'));
                    }
                }
            });

            console.log('[Queue] Page initialization complete');
            console.log('[Queue] ====================================================');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            // Close WebSocket connection
            if (jobsWS) {
                console.log('[Queue] Closing WebSocket connection');
                jobsWS.close();
                jobsWS = null;
            }
        });

        // Ensure Alpine.js is fully initialized
        document.addEventListener('alpine:init', function () {
            console.log('[Queue] Alpine.js initialized');

            // Register queueStatsHeader component
            // Note: WebSocket connection is now handled by the main job WebSocket (connectJobsWebSocket)
            // to avoid duplicate connections. Queue stats are forwarded from the main WebSocket.
            Alpine.data('queueStatsHeader', () => ({
                pending: 0,
                inFlight: 0,
                workers: 0,
                connected: false,

                init() {
                    // Add event listeners for external updates
                    window.addEventListener('queueStats:update', (e) => {
                        if (e.detail) {
                            this.pending = e.detail.pending || 0;
                            this.inFlight = e.detail.inFlight || 0;
                            this.workers = e.detail.workers || 0;
                            this.connected = e.detail.connected !== undefined ? e.detail.connected : true;
                        }
                    });

                    // Load initial stats from API
                    this.loadStats();
                },

                async loadStats() {
                    try {
                        const response = await fetch('/api/jobs/queue');
                        if (response.ok) {
                            const data = await response.json();
                            this.pending = data.pending_messages || 0;
                            this.inFlight = data.in_flight_messages || 0;
                            this.workers = data.concurrency || 0;
                            this.connected = true;
                        } else {
                            this.connected = false;
                        }
                    } catch (error) {
                        console.error('[Queue] Error loading queue stats:', error);
                        this.connected = false;
                    }
                }
            }));
            
            // Register jobList component
            Alpine.data('jobList', () => ({
                // State management
                showChildJobs: false, // Toggle between parent-only and all-jobs view
                expandedParents: new Set(), // Track expanded parent jobs
                childJobsCache: new Map(), // Cache: parentID -> array of child jobs
                loadingParents: new Set(), // Track parents currently loading children
                allJobs: [],
                filteredJobs: [],
                selectedJob: null,
                selectedJobIds: new Set(), // Track selected jobs for batch operations
                currentPage: 1,
                totalJobs: 0,
                pageSize: 50,
                itemsToRender: [],
                parentRefreshTimeouts: new Map(), // Debounce parent refreshes per parent_id

                init() {
                    // Add event listeners for external commands
                    window.addEventListener('jobList:load', () => this.loadJobs());
                    window.addEventListener('jobList:render', () => this.renderJobs());
                    window.addEventListener('jobList:updateJob', (e) => this.updateJobInList(e.detail));
                    window.addEventListener('jobList:changePage', (e) => {
                        this.currentPage = e.detail.page;
                        this.loadJobs();
                    });
                    window.addEventListener('jobList:toggleHierarchy', () => this.toggleShowChildJobs());
                    window.addEventListener('jobList:deleteSelected', () => this.deleteSelectedJobs());

                    // Wait for DOM to be ready then initialize
                    this.loadJobs();
                },
                
                async loadJobs() {
                    try {
                        // Build query parameters from filters
                        const params = new URLSearchParams();
                        params.append('limit', this.pageSize);
                        params.append('offset', (this.currentPage - 1) * this.pageSize);
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'DESC');

                        // Add parent filter for hierarchy view
                        // When showing only parent jobs, send parent_id=root to server
                        if (!this.showChildJobs) {
                            params.append('parent_id', 'root');
                        }

                        // Build filter parameters from activeFilters state (with safe checks)
                        if (window.activeFilters && window.activeFilters.status && window.activeFilters.status.size > 0) {
                            params.append('status', Array.from(window.activeFilters.status).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.source && window.activeFilters.source.size > 0) {
                            params.append('source', Array.from(window.activeFilters.source).join(','));
                        }
                        if (window.activeFilters && window.activeFilters.entity && window.activeFilters.entity.size > 0) {
                            params.append('entity', Array.from(window.activeFilters.entity).join(','));
                        }

                        const response = await fetch(`/api/jobs?${params.toString()}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch jobs');
                        }

                        const data = await response.json();
                        this.allJobs = data.jobs || [];
                        this.totalJobs = data.total_count || 0;
                        this.filteredJobs = [...this.allJobs];

                        if (!this.showChildJobs) {
                            this.expandedParents.clear(); // Reset expanded state when switching to parent-only view
                        }
                        
                        this.renderJobs();

                    } catch (error) {
                        console.error('[Queue] Error loading jobs:', error);
                        console.error('[Queue] Error stack:', error.stack);
                        const container = document.getElementById('jobs-cards-container');
                        container.innerHTML = `
                            <div class="text-center text-error" style="padding: 2rem;">
                                Failed to load jobs. Please try again.
                            </div>
                        `;
                    }
                },
                
                async loadChildJobs(parentId) {
                    // Check cache first
                    if (this.childJobsCache.has(parentId)) {
                        return this.childJobsCache.get(parentId);
                    }
                    
                    try {
                        const params = new URLSearchParams();
                        params.append('parent_id', parentId);
                        params.append('limit', 1000); // Load all children (reasonable limit)
                        params.append('order_by', 'created_at');
                        params.append('order_dir', 'DESC');
                        
                        const response = await fetch(`/api/jobs?${params.toString()}`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch child jobs');
                        }
                        
                        const data = await response.json();
                        const children = data.jobs || [];
                        
                        // Cache the results
                        this.childJobsCache.set(parentId, children);
                        
                        return children;
                    } catch (error) {
                        console.error('[Queue] Error loading child jobs:', error);
                        return [];
                    }
                },
                
                async toggleParentExpansion(parentId) {
                    if (this.expandedParents.has(parentId)) {
                        // Collapse
                        this.expandedParents.delete(parentId);
                    } else {
                        // Expand - add to loading state and load children
                        this.loadingParents.add(parentId);
                        
                        await this.loadChildJobs(parentId);
                        
                        // Remove from loading and add to expanded
                        this.loadingParents.delete(parentId);
                        this.expandedParents.add(parentId);
                    }
                    
                    // Re-render to show/hide children
                    this.renderJobs();
                },
                
                toggleShowChildJobs() {
                    this.showChildJobs = !this.showChildJobs;
                    const btn = document.getElementById('toggle-children-btn');
                    
                    this.currentPage = 1; // Reset to first page
                    this.loadJobs();
                },
                
                renderJobs() {
                    // Build hierarchical structure if showChildJobs is false
                    let itemsToRender = [];
                    if (!this.showChildJobs) {
                        // Only show parent jobs with their children if expanded
                        itemsToRender = this.filteredJobs.filter(job => !job.parent_id).map(parentJob => {
                            return { type: 'parent', job: parentJob, isExpanded: this.expandedParents.has(parentJob.id) };
                        });

                        // Add loading indicators for parents currently loading and child jobs for expanded parents
                        for (let i = 0; i < itemsToRender.length; i++) {
                            const item = itemsToRender[i];
                            if (item.type === 'parent') {
                                // Add loading indicator if parent is currently loading
                                if (this.loadingParents.has(item.job.id)) {
                                    const loadingItem = { type: 'loading', job: item.job, parentId: item.job.id };
                                    itemsToRender.splice(i + 1, 0, loadingItem);
                                }
                                // Add child jobs if parent is expanded and not loading
                                else if (item.isExpanded) {
                                    const children = this.childJobsCache.get(item.job.id) || [];
                                    const childItems = children.map(child => ({ type: 'child', job: child }));
                                    // Insert children right after the parent
                                    itemsToRender.splice(i + 1, 0, ...childItems);
                                    i += children.length; // Skip the inserted children when continuing the loop
                                }
                            }
                        }
                    } else {
                        // Show all jobs in flat structure when showing all
                        itemsToRender = this.filteredJobs.map(job => ({ type: 'flat', job: job }));
                    }

                    this.itemsToRender = itemsToRender;

                    // Also update pagination
                    const totalPages = Math.max(1, Math.ceil(this.totalJobs / this.pageSize));
                    window.renderPagination(totalPages, this.currentPage);
                },
                
                getParentProgressText(job) {
                    // Check if currently loading children
                    if (this.loadingParents.has(job.id)) {
                        return 'Loading children...';
                    }

                    // Use child statistics from job if available
                    const completed = job.completed_children || 0;
                    const total = job.child_count || 0;
                    const failed = job.failed_children || 0;
                    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

                    if (total > 0) {
                        let text = `${completed}/${total} URLs completed (${percentage}%)`;
                        if (failed > 0) {
                            text += ` - ${failed} failed`;
                        }
                        return text;
                    } else {
                        return 'No child jobs';
                    }
                },
                
                getParentProgressBarStyle(job) {
                    const completed = job.completed_children || 0;
                    const total = job.child_count || 0;
                    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
                    
                    return {
                        width: `${percentage}%`
                    };
                },
                
                getParentProgressStyle(job) {
                    return {};
                },
                
                getDocumentsCount(job) {
                    // For completed/failed/cancelled jobs, use result_count (authoritative snapshot)
                    // For running/pending jobs, use progress.completed_urls (real-time counter)
                    const terminalStatuses = ['completed', 'failed', 'cancelled'];

                    // Check if job is in terminal status and has result_count
                    if (terminalStatuses.includes(job.status) && job.result_count !== undefined && job.result_count !== null) {
                        return job.result_count;
                    }

                    // For active jobs or fallback, use progress.completed_urls
                    if (job.progress) {
                        try {
                            const progress = typeof job.progress === 'string' ? JSON.parse(job.progress) : job.progress;
                            if (progress && progress.completed_urls !== undefined) {
                                return progress.completed_urls;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to parse job progress:', error);
                        }
                    }

                    // Final fallback to result_count if available
                    if (job.result_count !== undefined && job.result_count !== null) {
                        return job.result_count;
                    }

                    return 'N/A';
                },
                
                getCreatedDate(job) {
                    return job.created_at ? new Date(job.created_at).toLocaleString() : 'N/A';
                },

                deriveParentStatus(job) {
                    // If not a parent job or no child stats, return original status
                    if (!job.child_count || job.child_count === 0) {
                        return { status: job.status, suffix: '' };
                    }

                    const total = job.child_count;
                    const completed = job.completed_children || 0;
                    const failed = job.failed_children || 0;

                    // All children completed
                    if (completed === total) {
                        return { status: 'completed', suffix: '' };
                    }

                    // Some children failed but job is still running
                    if (failed > 0 && job.status === 'running') {
                        return { status: 'running', suffix: ` (${failed} failed)` };
                    }

                    // Job is running with children in progress
                    if (job.status === 'running') {
                        return { status: 'running', suffix: '' };
                    }

                    // Default to job's own status
                    return { status: job.status, suffix: '' };
                },

                getStatusBadgeClass(type, status, job) {
                    // For parent jobs, derive status from children
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                    }

                    if (type === 'child') {
                        const childBadges = {
                            'pending': 'label-secondary',
                            'running': 'label-primary label-processing',
                            'completed': 'label-success label-done',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return childBadges[status] || 'label';
                    } else if (type === 'parent') {
                        const parentBadges = {
                            'pending': 'label-warning label-queued',
                            'running': 'label-primary label-orchestrating',
                            'completed': 'label-success',
                            'failed': 'label-error',
                            'cancelled': 'label'
                        };
                        return parentBadges[status] || 'label';
                    } else {
                        // In flat mode, determine if job is parent or child based on parent_id field
                        const isChild = !!job.parent_id;
                        if (isChild) {
                            const childBadges = {
                                'pending': 'label-secondary',
                                'running': 'label-primary label-processing',
                                'completed': 'label-success label-done',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return childBadges[status] || 'label';
                        } else {
                            const parentBadges = {
                                'pending': 'label-warning label-queued',
                                'running': 'label-primary label-orchestrating',
                                'completed': 'label-success',
                                'failed': 'label-error',
                                'cancelled': 'label'
                            };
                            return parentBadges[status] || 'label';
                        }
                    }
                },
                
                getStatusBadgeText(type, status, job) {
                    // For parent jobs, derive status from children
                    let suffix = '';
                    if ((type === 'parent' || (type === 'flat' && !job.parent_id)) && job.child_count > 0) {
                        const derived = this.deriveParentStatus(job);
                        status = derived.status;
                        suffix = derived.suffix;
                    }

                    // Return appropriate text based on the badge type
                    const statusTexts = {
                        'pending': type === 'child' ? 'Pending' : type === 'parent' ? 'Queued' : (!job || !job.parent_id ? 'Queued' : 'Pending'),
                        'running': type === 'child' ? 'Processing' : type === 'parent' ? 'Orchestrating' : (!job || !job.parent_id ? 'Orchestrating' : 'Processing'),
                        'completed': type === 'child' ? 'Done' : 'Completed',
                        'failed': 'Failed',
                        'cancelled': 'Cancelled'
                    };
                    return (statusTexts[status] || 'Unknown') + suffix;
                },
                
                toggleJobSelection(jobId) {
                    if (this.selectedJobIds.has(jobId)) {
                        this.selectedJobIds.delete(jobId);
                    } else {
                        this.selectedJobIds.add(jobId);
                    }
                    this.updateDeleteSelectedButtonVisibility();
                    this.updateSelectAllCheckbox();
                },

                toggleSelectAll() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');

                    if (selectAllCheckbox.checked) {
                        // Select all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.add(jobId);
                            checkbox.checked = true;
                        });
                    } else {
                        // Deselect all visible jobs
                        jobCheckboxes.forEach(checkbox => {
                            const jobId = checkbox.dataset.jobId;
                            this.selectedJobIds.delete(jobId);
                            checkbox.checked = false;
                        });
                    }

                    this.updateDeleteSelectedButtonVisibility();
                },

                updateSelectAllCheckbox() {
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    const jobCheckboxes = document.querySelectorAll('.job-checkbox');
                    const checkedCount = Array.from(jobCheckboxes).filter(cb => cb.checked).length;

                    if (checkedCount === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else if (checkedCount === jobCheckboxes.length) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true;
                    }
                },

                updateDeleteSelectedButtonVisibility() {
                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    if (this.selectedJobIds.size > 0) {
                        deleteButton.style.display = 'inline-block';
                        if (buttonSpan) {
                            buttonSpan.textContent = `Delete Selected (${this.selectedJobIds.size})`;
                        }
                    } else {
                        deleteButton.style.display = 'none';
                        if (buttonSpan) {
                            buttonSpan.textContent = 'Delete Selected';
                        }
                    }
                },

                async deleteSelectedJobs() {
                    if (this.selectedJobIds.size === 0) {
                        window.showNotification('No jobs selected', 'warning');
                        return;
                    }

                    const jobCount = this.selectedJobIds.size;
                    const jobList = Array.from(this.selectedJobIds).map(id => id.substring(0, 8) + '...').join(', ');

                    if (!confirm(`Delete ${jobCount} selected job${jobCount > 1 ? 's' : ''}?\n\nJobs: ${jobList}\n\nThis will permanently remove the job${jobCount > 1 ? 's' : ''} from the database.`)) {
                        return;
                    }

                    const deleteButton = document.getElementById('delete-selected-btn');
                    const buttonSpan = deleteButton.querySelector('span');
                    const originalText = buttonSpan ? buttonSpan.textContent : 'Delete Selected';
                    deleteButton.disabled = true;
                    deleteButton.innerHTML = '<i class="fas fa-spinner fa-pulse"></i> <span>Deleting...</span>';

                    const results = {
                        successful: [],
                        failed: []
                    };

                    // Delete each job
                    for (const jobId of this.selectedJobIds) {
                        try {
                            const response = await fetch(`/api/jobs/${jobId}`, {
                                method: 'DELETE'
                            });

                            if (response.ok) {
                                results.successful.push(jobId);
                                // Remove from allJobs and filteredJobs arrays
                                const allJobsIndex = this.allJobs.findIndex(job => job.id === jobId);
                                if (allJobsIndex >= 0) {
                                    this.allJobs.splice(allJobsIndex, 1);
                                }
                                const filteredJobsIndex = this.filteredJobs.findIndex(job => job.id === jobId);
                                if (filteredJobsIndex >= 0) {
                                    this.filteredJobs.splice(filteredJobsIndex, 1);
                                }
                            } else {
                                const errorText = await response.text();
                                results.failed.push({ jobId, error: errorText });
                            }
                        } catch (error) {
                            results.failed.push({ jobId, error: error.message });
                        }
                    }

                    // Clear selections
                    this.selectedJobIds.clear();
                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    selectAllCheckbox.checked = false;
                    selectAllCheckbox.indeterminate = false;

                    // Reset button
                    deleteButton.disabled = false;
                    deleteButton.innerHTML = `<i class="fa-solid fa-trash"></i> <span>${originalText}</span>`;
                    this.updateDeleteSelectedButtonVisibility();

                    // Show results
                    if (results.successful.length > 0) {
                        window.showNotification(`Successfully deleted ${results.successful.length} job${results.successful.length > 1 ? 's' : ''}`, 'success');
                    }

                    if (results.failed.length > 0) {
                        window.showNotification(`Failed to delete ${results.failed.length} job${results.failed.length > 1 ? 's' : ''}: ${results.failed[0].error}`, 'error');
                        console.error('Failed deletions:', results.failed);
                    }

                    // Refresh data
                    window.loadStats();
                    this.loadJobs();
                    this.renderJobs();
                },
                
                async updateJobInList(update) {
                    console.log('[Queue] Job updated via WebSocket:', update.job_id.substring(0, 8), update.status);

                    // Find job in allJobs array
                    let jobIndex = this.allJobs.findIndex(job => job.id === update.job_id);
                    let job = jobIndex >= 0 ? this.allJobs[jobIndex] : null;

                    // If job not found, fetch full job data regardless of status
                    if (!job) {
                        try {
                            const response = await fetch(`/api/jobs/${update.job_id}`);
                            if (response.ok) {
                                job = await response.json();
                                this.allJobs.unshift(job); // Insert at beginning (newest first)
                                jobIndex = 0;
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to fetch new job:', error);
                            return;
                        }
                    }

                    // If job still not found, ignore update
                    if (!job) {
                        return;
                    }

                    // Update job fields - preserve existing values when fields are omitted
                    job.status = update.status;

                    if (update.result_count !== undefined && update.result_count !== null) {
                        job.result_count = update.result_count;
                    }
                    if (update.failed_count !== undefined && update.failed_count !== null) {
                        job.failed_count = update.failed_count;
                    }

                    // Update progress object
                    if (!job.progress) {
                        job.progress = {};
                    }
                    if (typeof job.progress === 'string') {
                        try {
                            job.progress = JSON.parse(job.progress);
                        } catch (e) {
                            job.progress = {};
                        }
                    }

                    if (update.completed_urls !== undefined && update.completed_urls !== null) {
                        job.progress.completed_urls = update.completed_urls;
                    }
                    if (update.pending_urls !== undefined && update.pending_urls !== null) {
                        job.progress.pending_urls = update.pending_urls;
                    }
                    if (update.total_urls !== undefined && update.total_urls !== null) {
                        job.progress.total_urls = update.total_urls;
                    }

                    // Set error if present
                    if (update.error !== undefined && update.error !== null) {
                        job.error = update.error;
                    }

                    // Check if job matches active filters
                    const matchesFilters = window.matchesActiveFilters(job);

                    // Find job in filteredJobs
                    const filteredIndex = this.filteredJobs.findIndex(j => j.id === update.job_id);

                    if (matchesFilters) {
                        if (filteredIndex >= 0) {
                            // Update in place
                            this.filteredJobs[filteredIndex] = job;
                        } else {
                            // Insert at correct position (sorted by created_at DESC)
                            const insertIndex = this.filteredJobs.findIndex(j => {
                                return new Date(j.created_at) < new Date(job.created_at);
                            });
                            if (insertIndex >= 0) {
                                this.filteredJobs.splice(insertIndex, 0, job);
                            } else {
                                this.filteredJobs.push(job);
                            }
                        }
                    } else {
                        // Remove from filteredJobs if doesn't match filters
                        if (filteredIndex >= 0) {
                            this.filteredJobs.splice(filteredIndex, 1);
                        }
                    }

                    // If this is a child job and parent is expanded, update cache
                    if (job.parent_id && this.childJobsCache.has(job.parent_id)) {
                        const cachedChildren = this.childJobsCache.get(job.parent_id);
                        const childIndex = cachedChildren.findIndex(c => c.id === job.id);
                        if (childIndex >= 0) {
                            cachedChildren[childIndex] = job;
                        } else {
                            cachedChildren.unshift(job); // Add new child
                        }
                    }

                    // If child job updated, refresh parent stats (debounced per parent_id)
                    if (job.parent_id) {
                        this.debouncedRefreshParent(job.parent_id);
                    }

                    // Trim to pageSize if on first page to maintain pagination consistency
                    if (this.currentPage === 1 && this.filteredJobs.length > this.pageSize) {
                        this.filteredJobs.length = this.pageSize;
                    }

                    // Re-render jobs
                    this.renderJobs();
                },

                // Debounced parent refresh to reduce load under high child job churn
                debouncedRefreshParent(parentId) {
                    // Clear any existing timeout for this parent
                    if (this.parentRefreshTimeouts.has(parentId)) {
                        clearTimeout(this.parentRefreshTimeouts.get(parentId));
                    }

                    // Set new timeout to fetch parent after 400ms
                    const timeoutId = setTimeout(async () => {
                        try {
                            const parentResponse = await fetch(`/api/jobs/${parentId}`);
                            if (parentResponse.ok) {
                                const updatedParent = await parentResponse.json();

                                // Update parent in allJobs array
                                const parentIndex = this.allJobs.findIndex(j => j.id === parentId);
                                if (parentIndex >= 0) {
                                    this.allJobs[parentIndex] = updatedParent;
                                }

                                // Update parent in filteredJobs array if it exists there
                                const filteredParentIndex = this.filteredJobs.findIndex(j => j.id === parentId);
                                if (filteredParentIndex >= 0) {
                                    this.filteredJobs[filteredParentIndex] = updatedParent;
                                }

                                // Re-render to show updated parent stats
                                this.renderJobs();
                            }
                        } catch (error) {
                            console.warn('[Queue] Failed to update parent stats after child update:', error);
                        } finally {
                            // Remove timeout from map after execution
                            this.parentRefreshTimeouts.delete(parentId);
                        }
                    }, 400); // 400ms debounce window (within 300-500ms recommended range)

                    // Store timeout ID
                    this.parentRefreshTimeouts.set(parentId, timeoutId);
                },

                toggleJobJson(jsonId) {
                    const jsonElement = document.getElementById(jsonId);
                    if (jsonElement) {
                        if (jsonElement.style.display === 'none') {
                            jsonElement.style.display = 'block';
                        } else {
                            jsonElement.style.display = 'none';
                        }
                    }
                },
                
                // Helper function to get the correct status badge HTML based on type
                getStatusBadgeHtml(type, status) {
                    // This method is now handled via separate functions for Alpine binding
                    return this.getStatusBadgeClass(type, status);
                }
            }));
        });

        // Window helper function - dispatches event to Alpine component
        function deleteSelectedJobs() {
            window.dispatchEvent(new CustomEvent('jobList:deleteSelected'));
        }

        // Initialize highlight.js - only for job detail
        if (typeof hljs !== 'undefined') {
            const codeBlock = document.querySelector('#job-detail-json code');
            if (codeBlock) {
                hljs.highlightElement(codeBlock);
            }
        }
    </script>
</body>

</html>