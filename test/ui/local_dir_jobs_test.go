package ui

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/chromedp/chromedp"
	"github.com/ternarybob/quaero/test/common"
)

// localDirTestContext holds shared state for local_dir job tests
type localDirTestContext struct {
	t         *testing.T
	env       *common.TestEnvironment
	ctx       context.Context
	jobsURL   string
	queueURL  string
	jobAddURL string
	testDir   string
}

// newLocalDirTestContext creates a new test context with browser and environment
func newLocalDirTestContext(t *testing.T, timeout time.Duration) (*localDirTestContext, func()) {
	// Setup Test Environment
	env, err := common.SetupTestEnvironment(t.Name())
	if err != nil {
		t.Fatalf("Failed to setup test environment: %v", err)
	}

	// Create a timeout context for the entire test
	ctx, cancelTimeout := context.WithTimeout(context.Background(), timeout)

	// Create allocator context
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.WindowSize(1920, 1080),
	)
	allocCtx, cancelAlloc := chromedp.NewExecAllocator(ctx, opts...)

	// Create browser context
	browserCtx, cancelBrowser := chromedp.NewContext(allocCtx)

	baseURL := env.GetBaseURL()

	ltc := &localDirTestContext{
		t:         t,
		env:       env,
		ctx:       browserCtx,
		jobsURL:   baseURL + "/jobs",
		queueURL:  baseURL + "/queue",
		jobAddURL: baseURL + "/jobs/add",
	}

	// Return cleanup function
	cleanup := func() {
		// Clean up test directory if created
		if ltc.testDir != "" {
			os.RemoveAll(ltc.testDir)
		}

		// Properly close the browser before canceling contexts
		if err := chromedp.Cancel(browserCtx); err != nil {
			t.Logf("Warning: browser cancel returned: %v", err)
		}
		cancelBrowser()
		cancelAlloc()
		cancelTimeout()
		env.Cleanup()
	}

	return ltc, cleanup
}

// createTestDirectory creates a temporary directory with test files for local_dir testing
func (ltc *localDirTestContext) createTestDirectory() error {
	ltc.env.LogTest(ltc.t, "Creating test directory with sample files...")

	// Create temp directory
	tempDir, err := os.MkdirTemp("", "quaero-ui-local-dir-test-*")
	if err != nil {
		return fmt.Errorf("failed to create temp directory: %w", err)
	}

	// Create test files
	testFiles := map[string]string{
		"README.md":          "# Test Project\n\nThis is a test project for local_dir worker UI testing.\n\n## Features\n- File indexing\n- Content extraction\n",
		"main.go":            "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, World!\")\n}\n",
		"config.txt":         "# Configuration file\nkey=value\nfoo=bar\nenvironment=test\n",
		"src/utils.go":       "package src\n\n// Helper is a utility function\nfunc Helper() string {\n\treturn \"helper\"\n}\n",
		"src/models/user.go": "package models\n\n// User represents a user in the system\ntype User struct {\n\tID   int\n\tName string\n}\n",
		"docs/api.md":        "# API Documentation\n\n## Endpoints\n\n### GET /api/status\nReturns the service status.\n",
		"docs/guide.md":      "# User Guide\n\n## Getting Started\n\n1. Install the application\n2. Configure settings\n3. Run the service\n",
	}

	for path, content := range testFiles {
		fullPath := filepath.Join(tempDir, path)

		// Create parent directories
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			return fmt.Errorf("failed to create directory for %s: %w", path, err)
		}

		// Write file
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to create test file %s: %w", path, err)
		}
	}

	ltc.testDir = tempDir
	ltc.env.LogTest(ltc.t, "Created test directory with %d files at: %s", len(testFiles), tempDir)
	return nil
}

// generateTOMLConfig generates TOML configuration for a local_dir job
func (ltc *localDirTestContext) generateTOMLConfig(name, dirPath string) string {
	// Escape backslashes for TOML on Windows
	escapedPath := filepath.ToSlash(dirPath)

	// Generate a unique ID based on timestamp
	jobID := fmt.Sprintf("local-dir-test-%d", time.Now().UnixNano())

	return fmt.Sprintf(`# Local Directory Indexing Job
# Generated by UI test: %s
# Timestamp: %s

id = "%s"
name = "%s"
description = "Test local directory indexing job created via UI test"
tags = ["test", "local_dir", "ui-test"]
schedule = ""
enabled = true

[step.index]
type = "local_dir"
dir_path = "%s"

# File filtering
include_extensions = [".go", ".md", ".txt"]
exclude_paths = [".git", "node_modules"]

# Limits
max_file_size = 1048576  # 1MB
max_files = 50
`, ltc.t.Name(), time.Now().Format(time.RFC3339), jobID, name, escapedPath)
}

// saveTOMLConfig saves the TOML configuration to the results directory
func (ltc *localDirTestContext) saveTOMLConfig(filename, content string) error {
	// Get the results directory from the environment
	resultsDir := ltc.env.GetResultsDir()
	if resultsDir == "" {
		ltc.env.LogTest(ltc.t, "Warning: results directory not available, skipping TOML save")
		return nil
	}

	// Create the TOML file path
	tomlPath := filepath.Join(resultsDir, filename)

	// Write the TOML content
	if err := os.WriteFile(tomlPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write TOML config: %w", err)
	}

	ltc.env.LogTest(ltc.t, "Saved TOML config to: %s", tomlPath)
	return nil
}

// createLocalDirJobDefinition creates a local_dir job definition via API
func (ltc *localDirTestContext) createLocalDirJobDefinition(name, dirPath string) (string, error) {
	ltc.env.LogTest(ltc.t, "Creating local_dir job definition: %s", name)

	helper := ltc.env.NewHTTPTestHelper(ltc.t)

	// Generate unique ID
	defID := fmt.Sprintf("local-dir-test-%d", time.Now().UnixNano())

	// Generate and save TOML config
	tomlConfig := ltc.generateTOMLConfig(name, dirPath)
	tomlFilename := fmt.Sprintf("job_config_%s.toml", strings.ReplaceAll(strings.ToLower(name), " ", "_"))
	if err := ltc.saveTOMLConfig(tomlFilename, tomlConfig); err != nil {
		ltc.env.LogTest(ltc.t, "Warning: failed to save TOML config: %v", err)
	}

	body := map[string]interface{}{
		"id":          defID,
		"name":        name,
		"description": "Test local directory indexing job created via UI test",
		"type":        "local_dir",
		"enabled":     true,
		"steps": []map[string]interface{}{
			{
				"name": "index-files",
				"type": "local_dir",
				"config": map[string]interface{}{
					"dir_path":           dirPath,
					"include_extensions": []string{".go", ".md", ".txt"},
					"exclude_paths":      []string{".git", "node_modules"},
					"max_file_size":      1048576,
					"max_files":          50,
				},
			},
		},
	}

	resp, err := helper.POST("/api/job-definitions", body)
	if err != nil {
		return "", fmt.Errorf("failed to create job definition: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 {
		return "", fmt.Errorf("job definition creation failed with status: %d", resp.StatusCode)
	}

	var result map[string]interface{}
	if err := helper.ParseJSONResponse(resp, &result); err != nil {
		return "", fmt.Errorf("failed to parse response: %w", err)
	}

	ltc.env.LogTest(ltc.t, "Created local_dir job definition: %s (ID: %s)", name, defID)
	return defID, nil
}

// deleteJobDefinition deletes a job definition via API
func (ltc *localDirTestContext) deleteJobDefinition(defID string) {
	helper := ltc.env.NewHTTPTestHelper(ltc.t)
	resp, err := helper.DELETE("/api/job-definitions/" + defID)
	if err != nil {
		ltc.env.LogTest(ltc.t, "Warning: failed to delete job definition %s: %v", defID, err)
		return
	}
	resp.Body.Close()
	ltc.env.LogTest(ltc.t, "Deleted job definition: %s", defID)
}

// triggerJob triggers a job by name via the Jobs page UI
func (ltc *localDirTestContext) triggerJob(jobName string) error {
	ltc.env.LogTest(ltc.t, "Triggering job: %s", jobName)

	// Navigate to Jobs page
	if err := chromedp.Run(ltc.ctx, chromedp.Navigate(ltc.jobsURL)); err != nil {
		return fmt.Errorf("failed to navigate to jobs page: %w", err)
	}

	// Wait for page to load
	if err := chromedp.Run(ltc.ctx,
		chromedp.WaitVisible(`.page-title`, chromedp.ByQuery),
		chromedp.Sleep(2*time.Second),
	); err != nil {
		return fmt.Errorf("jobs page did not load: %w", err)
	}

	// Take screenshot
	screenshotName := fmt.Sprintf("jobs_page_%s", strings.ReplaceAll(strings.ToLower(jobName), " ", "_"))
	ltc.env.TakeScreenshot(ltc.ctx, screenshotName)

	// Convert job name to button ID format
	buttonID := strings.ToLower(jobName)
	re := regexp.MustCompile(`[^a-z0-9]+`)
	buttonID = re.ReplaceAllString(buttonID, "-")
	buttonID = buttonID + "-run"

	ltc.env.LogTest(ltc.t, "Looking for button with ID: %s", buttonID)

	// Click the run button
	runBtnSelector := fmt.Sprintf(`#%s`, buttonID)
	if err := chromedp.Run(ltc.ctx,
		chromedp.WaitVisible(runBtnSelector, chromedp.ByQuery),
		chromedp.Click(runBtnSelector, chromedp.ByQuery),
	); err != nil {
		ltc.env.TakeScreenshot(ltc.ctx, "run_click_failed_"+jobName)
		return fmt.Errorf("failed to click run button for %s: %w", jobName, err)
	}

	// Handle Confirmation Modal
	ltc.env.LogTest(ltc.t, "Waiting for confirmation modal")
	if err := chromedp.Run(ltc.ctx,
		chromedp.WaitVisible(`.modal.active`, chromedp.ByQuery),
		chromedp.Sleep(500*time.Millisecond),
	); err != nil {
		ltc.env.TakeScreenshot(ltc.ctx, "modal_wait_failed_"+jobName)
		return fmt.Errorf("confirmation modal did not appear: %w", err)
	}

	ltc.env.TakeScreenshot(ltc.ctx, fmt.Sprintf("confirmation_modal_%s", strings.ReplaceAll(strings.ToLower(jobName), " ", "_")))

	// Click Confirm button
	ltc.env.LogTest(ltc.t, "Confirming run")
	if err := chromedp.Run(ltc.ctx,
		chromedp.Click(`.modal.active .modal-footer .btn-primary`, chromedp.ByQuery),
		chromedp.Sleep(1*time.Second),
	); err != nil {
		ltc.env.TakeScreenshot(ltc.ctx, "confirm_click_failed_"+jobName)
		return fmt.Errorf("failed to confirm run: %w", err)
	}

	ltc.env.LogTest(ltc.t, "Job triggered: %s", jobName)
	return nil
}

// monitorJob monitors a job on the Queue page until completion
func (ltc *localDirTestContext) monitorJob(jobName string, timeout time.Duration) (string, error) {
	ltc.env.LogTest(ltc.t, "Monitoring job: %s (timeout: %v)", jobName, timeout)

	// Navigate to Queue page
	if err := chromedp.Run(ltc.ctx, chromedp.Navigate(ltc.queueURL)); err != nil {
		return "", fmt.Errorf("failed to navigate to queue page: %w", err)
	}

	// Wait for page to load
	if err := chromedp.Run(ltc.ctx,
		chromedp.WaitVisible(`.page-title`, chromedp.ByQuery),
		chromedp.Sleep(2*time.Second),
	); err != nil {
		return "", fmt.Errorf("queue page did not load: %w", err)
	}

	ltc.env.LogTest(ltc.t, "Queue page loaded, looking for job...")

	// Poll for job to appear in the queue
	var jobID string
	pollErr := chromedp.Run(ltc.ctx,
		chromedp.Poll(
			fmt.Sprintf(`
				(() => {
					const element = document.querySelector('[x-data="jobList"]');
					if (!element) return null;
					const component = Alpine.$data(element);
					if (!component || !component.allJobs) return null;
					const job = component.allJobs.find(j => j.name && j.name.includes('%s'));
					return job ? job.id : null;
				})()
			`, jobName),
			&jobID,
			chromedp.WithPollingTimeout(30*time.Second),
			chromedp.WithPollingInterval(1*time.Second),
		),
	)
	if pollErr != nil || jobID == "" {
		ltc.env.TakeScreenshot(ltc.ctx, "job_not_found_"+jobName)
		return "", fmt.Errorf("job %s not found in queue: %w", jobName, pollErr)
	}
	ltc.env.LogTest(ltc.t, "Job found in queue (ID: %s)", jobID)

	// Monitor status
	startTime := time.Now()
	lastStatus := ""
	var currentStatus string
	pollStart := time.Now()

	for {
		if err := ltc.ctx.Err(); err != nil {
			return lastStatus, fmt.Errorf("context cancelled: %w", err)
		}

		if time.Since(pollStart) > timeout {
			ltc.env.TakeFullScreenshot(ltc.ctx, "job_timeout_"+jobName)
			return lastStatus, fmt.Errorf("job did not complete within %v (last status: %s)", timeout, lastStatus)
		}

		// Trigger refresh
		chromedp.Run(ltc.ctx, chromedp.Evaluate(`typeof loadJobs === 'function' && loadJobs()`, nil))
		time.Sleep(200 * time.Millisecond)

		// Get current status
		err := chromedp.Run(ltc.ctx,
			chromedp.Evaluate(fmt.Sprintf(`
				(() => {
					const cards = document.querySelectorAll('.card');
					for (const card of cards) {
						const titleEl = card.querySelector('.card-title');
						if (titleEl && titleEl.textContent.includes('%s')) {
							const statusBadge = card.querySelector('span.label[data-status]');
							if (statusBadge) {
								return statusBadge.getAttribute('data-status');
							}
						}
					}
					return null;
				})()
			`, jobName), &currentStatus),
		)

		if err != nil {
			continue
		}

		// Log status changes
		if currentStatus != lastStatus && currentStatus != "" {
			elapsed := time.Since(startTime)
			ltc.env.LogTest(ltc.t, "  Status: %s -> %s (at %v)", lastStatus, currentStatus, elapsed.Round(time.Millisecond))
			lastStatus = currentStatus
			ltc.env.TakeScreenshot(ltc.ctx, fmt.Sprintf("status_%s_%s", strings.ReplaceAll(strings.ToLower(jobName), " ", "_"), currentStatus))
		}

		// Check terminal states
		if currentStatus == "completed" || currentStatus == "failed" || currentStatus == "cancelled" {
			ltc.env.LogTest(ltc.t, "Job reached terminal status: %s", currentStatus)
			break
		}

		time.Sleep(500 * time.Millisecond)
	}

	ltc.env.TakeFullScreenshot(ltc.ctx, fmt.Sprintf("final_%s", strings.ReplaceAll(strings.ToLower(jobName), " ", "_")))
	return currentStatus, nil
}

// TestLocalDirJobAddPage tests the job add page basic functionality
func TestLocalDirJobAddPage(t *testing.T) {
	ltc, cleanup := newLocalDirTestContext(t, 3*time.Minute)
	defer cleanup()

	ltc.env.LogTest(t, "--- Starting Test: Local Dir Job Add Page ---")

	// Navigate to job add page
	if err := chromedp.Run(ltc.ctx,
		chromedp.Navigate(ltc.jobAddURL),
		chromedp.WaitVisible(`.page-title`, chromedp.ByQuery),
		chromedp.Sleep(2*time.Second),
	); err != nil {
		t.Fatalf("Failed to navigate to job add page: %v", err)
	}

	ltc.env.TakeScreenshot(ltc.ctx, "job_add_page_initial")
	ltc.env.LogTest(t, "Job add page loaded successfully")

	// Verify TOML editor exists
	ltc.env.LogTest(t, "Step 1: Verifying TOML editor exists")
	var editorExists bool
	if err := chromedp.Run(ltc.ctx,
		chromedp.Evaluate(`document.getElementById('toml-editor') !== null`, &editorExists),
	); err != nil {
		t.Fatalf("Failed to check for TOML editor: %v", err)
	}

	if !editorExists {
		ltc.env.TakeScreenshot(ltc.ctx, "editor_missing")
		t.Fatal("TOML editor not found on page")
	}
	ltc.env.LogTest(t, "TOML editor found")

	// Check if there's an example button and try clicking it
	ltc.env.LogTest(t, "Step 2: Checking for example button")
	var exampleButtonExists bool
	if err := chromedp.Run(ltc.ctx,
		chromedp.Evaluate(`document.querySelector('button[onclick*="example"], button.example-btn, .load-example') !== null`, &exampleButtonExists),
	); err == nil && exampleButtonExists {
		ltc.env.LogTest(t, "Example button found, attempting to load example")

		// Try to click example button
		if err := chromedp.Run(ltc.ctx,
			chromedp.Click(`button[onclick*="example"], button.example-btn, .load-example`, chromedp.ByQuery),
			chromedp.Sleep(1*time.Second),
		); err == nil {
			ltc.env.TakeScreenshot(ltc.ctx, "example_loaded")

			// Check if TOML content was populated
			var tomlContent string
			if err := chromedp.Run(ltc.ctx,
				chromedp.Evaluate(`document.getElementById('toml-editor')?.value || ''`, &tomlContent),
			); err == nil && tomlContent != "" {
				ltc.env.LogTest(t, "Example content loaded into TOML editor")

				// Save TOML content to results directory
				if err := ltc.saveTOMLConfig("loaded_example.toml", tomlContent); err != nil {
					ltc.env.LogTest(t, "Warning: failed to save TOML: %v", err)
				}
			}
		}
	} else {
		ltc.env.LogTest(t, "No example button found - page may have simplified UI")
	}

	ltc.env.LogTest(t, "Test completed successfully")
}

// TestLocalDirJobExecution tests executing a local_dir job via UI
func TestLocalDirJobExecution(t *testing.T) {
	ltc, cleanup := newLocalDirTestContext(t, 5*time.Minute)
	defer cleanup()

	ltc.env.LogTest(t, "--- Starting Test: Local Dir Job Execution ---")

	// Create test directory
	if err := ltc.createTestDirectory(); err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create job definition via API
	jobName := "Local Dir UI Test"
	defID, err := ltc.createLocalDirJobDefinition(jobName, ltc.testDir)
	if err != nil {
		t.Fatalf("Failed to create job definition: %v", err)
	}
	defer ltc.deleteJobDefinition(defID)

	// Take screenshot before triggering
	if err := chromedp.Run(ltc.ctx, chromedp.Navigate(ltc.queueURL)); err != nil {
		t.Fatalf("Failed to navigate to queue page: %v", err)
	}
	ltc.env.TakeScreenshot(ltc.ctx, "local_dir_before")

	// Trigger the job via UI
	if err := ltc.triggerJob(jobName); err != nil {
		t.Fatalf("Failed to trigger job: %v", err)
	}

	// Monitor job execution
	finalStatus, err := ltc.monitorJob(jobName, 2*time.Minute)
	if err != nil {
		t.Fatalf("Job monitoring failed: %v", err)
	}

	// Verify completion
	if finalStatus != "completed" {
		t.Errorf("Expected job status 'completed', got '%s'", finalStatus)
	}

	ltc.env.LogTest(t, "Test completed - job status: %s", finalStatus)
}

// TestLocalDirJobWithEmptyDirectory tests local_dir job behavior with empty directory
func TestLocalDirJobWithEmptyDirectory(t *testing.T) {
	ltc, cleanup := newLocalDirTestContext(t, 3*time.Minute)
	defer cleanup()

	ltc.env.LogTest(t, "--- Starting Test: Local Dir Job With Empty Directory ---")

	// Create empty test directory
	tempDir, err := os.MkdirTemp("", "quaero-ui-empty-dir-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	ltc.testDir = tempDir
	ltc.env.LogTest(t, "Created empty test directory: %s", tempDir)

	// Create job definition
	jobName := "Local Dir Empty Test"
	defID, err := ltc.createLocalDirJobDefinition(jobName, tempDir)
	if err != nil {
		t.Fatalf("Failed to create job definition: %v", err)
	}
	defer ltc.deleteJobDefinition(defID)

	// Trigger job
	if err := ltc.triggerJob(jobName); err != nil {
		t.Fatalf("Failed to trigger job: %v", err)
	}

	// Monitor job
	finalStatus, err := ltc.monitorJob(jobName, 1*time.Minute)
	if err != nil {
		// Empty directory may cause job to complete quickly or fail
		ltc.env.LogTest(t, "Job monitoring ended: %v (status: %s)", err, finalStatus)
	}

	// Job should complete (possibly with 0 documents)
	ltc.env.LogTest(t, "Test completed - final status: %s", finalStatus)
}

// TestLocalDirJobQueueDisplay tests that local_dir jobs display correctly in queue
func TestLocalDirJobQueueDisplay(t *testing.T) {
	ltc, cleanup := newLocalDirTestContext(t, 4*time.Minute)
	defer cleanup()

	ltc.env.LogTest(t, "--- Starting Test: Local Dir Job Queue Display ---")

	// Create test directory
	if err := ltc.createTestDirectory(); err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create and trigger job
	jobName := "Local Dir Display Test"
	defID, err := ltc.createLocalDirJobDefinition(jobName, ltc.testDir)
	if err != nil {
		t.Fatalf("Failed to create job definition: %v", err)
	}
	defer ltc.deleteJobDefinition(defID)

	if err := ltc.triggerJob(jobName); err != nil {
		t.Fatalf("Failed to trigger job: %v", err)
	}

	// Navigate to queue page
	if err := chromedp.Run(ltc.ctx,
		chromedp.Navigate(ltc.queueURL),
		chromedp.WaitVisible(`.page-title`, chromedp.ByQuery),
		chromedp.Sleep(3*time.Second),
	); err != nil {
		t.Fatalf("Failed to navigate to queue page: %v", err)
	}

	// Verify job card elements
	ltc.env.LogTest(t, "Verifying job card display elements")

	// Check job name is displayed
	var jobNameDisplayed bool
	if err := chromedp.Run(ltc.ctx,
		chromedp.Evaluate(fmt.Sprintf(`
			Array.from(document.querySelectorAll('.card-title')).some(el => el.textContent.includes('%s'))
		`, jobName), &jobNameDisplayed),
	); err != nil {
		t.Fatalf("Failed to check job name: %v", err)
	}

	if !jobNameDisplayed {
		ltc.env.TakeScreenshot(ltc.ctx, "job_name_not_displayed")
		t.Error("Job name not displayed in queue")
	} else {
		ltc.env.LogTest(t, "Job name displayed correctly")
	}

	// Check status badge exists
	var statusBadgeExists bool
	if err := chromedp.Run(ltc.ctx,
		chromedp.Evaluate(`document.querySelector('.card span.label[data-status]') !== null`, &statusBadgeExists),
	); err == nil && statusBadgeExists {
		ltc.env.LogTest(t, "Status badge displayed correctly")
	}

	ltc.env.TakeFullScreenshot(ltc.ctx, "local_dir_queue_display")

	// Wait for job to complete
	finalStatus, err := ltc.monitorJob(jobName, 2*time.Minute)
	if err != nil {
		ltc.env.LogTest(t, "Job monitoring ended: %v", err)
	}

	ltc.env.LogTest(t, "Test completed - final status: %s", finalStatus)
}
